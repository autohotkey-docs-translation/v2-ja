<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>v1.1からの変更点｜AutoHotkey v2</title>
<meta name="description" content="v1.1とv2.0の間の変更点。" />
<meta name="ahk:equiv-v1" content="AHKL_ChangeLog.htm" />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
</head>
<body>
<h1>v1.1からv2.0への変更点</h1>

<h2 id="language">言語</h2>
<h3 id="legacy-syntax-removed">レガシーシンタックス削除</h3>
<p>リテラルの割り当てを削除しました：<code>var = value</code></p>
<p>従来のIf文をすべて削除し、<code>if式</code>のみを残し、括弧を必要としない（ただし、あらゆる式と同様に括弧を使用できる）ようにしました。</p>
<p>Removed "command syntax". コマンド」は存在せず、ただ <a href="Language.htm#function-call-statements"><em>関数呼び出し文</em></a>これは、括弧のない単なる関数やメソッドの呼び出しです。That means:</p>
<ul>
<li>以前のコマンドはすべて関数になりました（制御フロー文は除く）。</li>
<li>戻り値が不要な場合は、すべての関数を括弧なしで呼び出すことができます（ただし、従来通り、式内の呼び出しでは括弧を省略できません）。</li>
<li>すべてのパラメータは式なので、すべてのテキストは「引用」され、カンマをエスケープする必要はありません。現在、一部のディレクティブ（コマンドでも関数でもない）を除いています。</li>
<li>パラメータは括弧の有無にかかわらず同じである。すなわち、戻り値の出力変数は存在しないので、括弧が省略された場合は廃棄されることになる。</li>
<li>通常の変数参照はパーセント記号で囲むことはありません（<a href="lib/_Include.htm">#Include</a>と <a href="lib/_DllLoad.htm">#DllLoad</a>を除く）。テキストに変数を含めるには、<a href="Variables.htm#concat">連結</a>や <a href="lib/Format.htm">Format</a>を使用します。</li>
<li>関数名とパラメータの間にカンマはないので、<code>MouseGetPos(, y)</code>=<code>MouseGetPos , y</code>（xは省略）。わかりやすくするために、スペースまたはタブが必要です。一貫性を保つため、ディレクティブも新しい規約に従っています（ディレクティブ名とパラメータの間にコンマがあってはいけません）。</li>
<li>式を強制するためのパーセンテージスペース接頭辞はありません。式中の引用符なしのパーセント記号は、二重参照／動的参照にのみ使用され、奇数個あると構文エラーになります。</li>
<li>メソッド呼び出し文（括弧を省略したメソッド呼び出し）は、<code>MyVar.MyProperty.MyMethod "String to pass"</code> のように、プレーン変数の後にドットで区切られた1つまたは複数の識別子を持つものに限定されます。</li>
</ul>
<p>v1-commandから関数への変換は概ね以下の通りです（ただし、一部の関数は後述するように変更されています）：</p>
<ul>
<li>コマンドの第1パラメータが出力変数で、第2パラメータが出力変数でない場合、そのパラメータは戻り値となり、パラメータリストから削除されます。</li>
<li>残りの出力変数は、書き込み可能な組み込み変数への参照を許可する以外は、<a href="#byref">ByRefパラメータ</a>（使い方と構文が変更されている）と同様に扱われる。</li>
<li>ErrorLevelを設定する代わりに、失敗時に例外がスローされる。</li>
<li>以前はErrorLevelで返されていた値は、他の手段で返されるか、例外で置き換えられるか、優先されるか、単に返されないかである。</li>
</ul>
<p>以下に記す場合を除き、すべての制御フロー文は式も受け付ける。</p>
<p>パラメータを取るすべての制御フロー文（現在、2語のLoop文を除く）は、パラメータリストを括弧で囲み、名前と括弧の間にスペースを入れずにサポートします。例えば、<code>return(var)</code>。しかし、これらは関数ではないので、例えば、<code>x := return(y)</code>は無効である。<a href="lib/If.htm">If</a>と <a href="lib/While.htm">While</a>は、すでにサポートしています。</p>
<p><a href="#loop-sub-commands">Loop</a>(<a href="lib/Loop.htm">Loop <em>Countを</em></a>除く)の後に、"引用"したり変数で囲むことのできない副キーワード(Files, Parse, Read or Reg)が続くようになった。現在、キーワードの後にカンマを付けることができますが、これはパラメータではないので必須ではありません。OTBは全モードで対応しています。</p>
<p><a href="lib/Goto.htm">Goto</a>、<a href="lib/Break.htm">break</a>、<a href="lib/Continue.htm">continue</a>は、v1<code>（goto label</code>jumps to<code>label:</code>）と同様、引用符のないラベル名を必要とします。ラベルに動的にジャンプするには、名前のすぐ後に括弧を使用します：<code>goto(expression)</code>. ただし、これは関数ではないので、式の途中で使用することはできません。括弧はbreakやcontinueでも使えますが、その場合、パラメータは1つのリテラル数値か引用符で囲まれた文字列でなければなりません。</p>
<p>Gosubが削除され、<a href="lib/SetTimer.htm">SetTimer</a>や <a href="lib/Hotkey.htm">Hotkey</a>などの機能でラベルが使用できなくなりました。</p>
<ul>
<li>ローカル変数も戻り値もなく、独立した名前空間にある、基本的に限定的な関数の一種だったのです。関数は、これまでラベルサブルーチンが使われていた場所ならどこでも（<a href="Functions.htm#nested">他の関数</a>の中でも）使うことができます。</li>
<li>機能は重複できない（ただし、機能内に含めることはできる）。その代わり、複数の機能を使い、他の機能から呼び出すようにします。A_ThisLabelの代わりに、関数パラメータを使用します。</li>
<li>サブルーチンとは異なり、関数の<em>終わり</em>を定義し忘れると、<code>{</code>には、それぞれ対応する<code>}</code>が必要なので、通常、エラーになります。また、ラベルサブルーチンよりも関数の方が境界を特定しやすい場合もあります。</li>
<li>関数を自動実行部に割り込ませることなく配置することができます。自動実行セクションは、スクリプト全体を容易にカバーできるようになったので、<a href="Scripts.htm#auto">自動実行スレッド</a>内で実行される<a href="Language.htm#global-code">グローバルコード</a>と呼ばれることもあります。</li>
<li>関数は、「goto」（ユーザーがループするために現在のサブルーチンをgosubすることで、必然的にスタックスペースを使い果たしてプログラムを終了させること）として悪用される可能性が少し低くなるかもしれません。</li>
<li>（<a href="lib/Hotkey.htm">Hotkey</a>のように）ラベルや機能を受け入れる機能がなく、同じ名前で両方が同時に存在できるため、あいまいさが少なくなります。</li>
<li>ラベルの残りのすべての用途において、関数内部からグローバルラベルを参照することは無効である。そのため、ラベル検索をローカルラベルリストに限定することができる。そのため、（これまでサポートされていなかった）関数内部から外部への無効なジャンプをチェックする必要がありません。</li>
</ul>
<h3 id="hotkey-and-hotstring-labels">ホットキーとホットストリングラベル</h3>
<p><a href="Hotkeys.htm">ホットキー</a>や自動置換でない<a href="Hotstrings.htm">ホットストリング</a>は、ラベルではなくなり、代わりに（自動的に）機能を定義するようになりました。複数行のホットキーの場合、<code>return</code>で終了させるのではなく、中括弧を使ってホットキーの本体を囲みます（終了中括弧はこれを意味します）。ホットキーを明示的に呼び出すには、<code>:</code>と<code>{</code>の間に<code>funcName(ThisHotkey)</code>を指定します - これは v1.1.20+ でも行えますが、現在はパラメータがあります。関数定義が明示されていない場合、パラメータはThisHotkeyと命名されます。</p>
<p><strong>注：</strong>ホットキー関数はデフォルトで<a href="Functions.htm#AssumeLocal">assume-local</a>であるため、宣言なしで<a href="Functions.htm#Global">グローバル変数</a>に代入することはできません。</p>
<h3 id="names">名称</h3>
<p>関数名と変数名が共有名前空間に配置されるようになりました。</p>
<ul>
<li>各関数定義は、現在のスコープ内に定数（読み取り専用変数）を作成します。</li>
<li><code>Func("MyFunc")</code>の代わりに<code>MyFunc</code>を使用する。</li>
<li><a href="lib/SetTimer.htm">SetTimer</a>や <a href="lib/Hotkey.htm">Hotkey</a>などの組み込み関数に渡す場合は、<code>MyFunc</code>の代わりに "MyFunc"</code>を使用してください。名前（文字列）の受け渡しはサポートされなくなりました。</li>
<li>関数を値で呼び出す場合、<code>%myVar%()</code>の代わりに<code>myVar()</code>を使用します。</li>
<li>関数名（文字列）しかないときに関数を呼び出すには、まず<a href="Variables.htm#deref">double-deref</a>で名前を変数に解決し、その値（関数オブジェクト）を取得する。<code>myVar%()</code>は、実際にダブルデフを行い、その結果を呼び出すようになり、<code>f := %myVar%, f()</code>と同等になりました。関数を名前（文字列）で扱うことはできるだけ避け、代わりにリファレンスを使用する。</li>
</ul>
<p>氏名は数字で始まることはできず、従来は認められていた以下の文字を含むことはできません：<code>@ # $</code>. 使用できる文字は、英字、数字、アンダースコア、非ASCII文字のみです。</p>
<p><strong>予約語：</strong>宣言キーワードや制御フロー文の名前は、変数名、関数名、クラス名として使用することはできません。<code class="no-highlight">local</code>, <code class="no-highlight">global</code>, <code class="no-highlight">static</code>, <code class="no-highlight">if</code>, <code class="no-highlight">else</code>, <code class="no-highlight">loop</code>, <code class="no-highlight">for</code>, <code class="no-highlight">while</code>, <code class="no-highlight">until</code>, <code class="no-highlight">break</code>, <code class="no-highlight">continue</code>, <code class="no-highlight">goto</code>, <code class="no-highlight">return</code>, <code class="no-highlight">switch</code>, <code class="no-highlight">case</code>, <code class="no-highlight">try</code>, <code class="no-highlight">catch</code>, <code class="no-highlight">finally</code> および <code class="no-highlight">throw</code> を含んでいます。これは主に<code>if (ex) break</code>のようなエラーを検出するためです。</p>
<p><strong>予約語：</strong> <code class="no-highlight">as</code>,<code class="no-highlight">and</code>,<code class="no-highlight">contains</code>,<code class="no-highlight">false</code>,<code class="no-highlight">in</code>,<code class="no-highlight">is</code>,<code class="no-highlight">IsSet</code>,<code class="no-highlight">not</code>,<code class="no-highlight">or</code>,<code class="no-highlight">super</code>,<code class="no-highlight">true</code>,<code class="no-highlight">unset</code>. これらの単語は、将来の使用やその他の特定の目的のために予約されており、曖昧でない場合でも、変数名や関数名として許可されていません。これは主に一貫性を保つためです：v1では、<code>and := 1</code>は、単独で行えたが、<code>(and := 1)</code>は動作しない。</p>
<p>上記の単語は、プロパティ名やウィンドウグループ名として許可されています。一般的に使用されるプロパティ名の前には、演算子として解釈されることを防ぐために、<code>.</code>が付いています。一方、キーワードは式中の変数名や関数名として解釈されることはない。例えば、<code>not(x)</code>は<code>not(x)</code>または<code>(not x)</code>と同じ意味です。</p>
<p>多くのクラスが事前に定義されており、ユーザー定義クラスと同じように、グローバル変数名を効果的に予約することができます。(ただし、後述する<a href="#scope">スコープの変更</a>により、このことから生じる問題はほとんど緩和されます)。クラスの一覧は、「<a href="ObjList.htm">組み込みクラス</a>」を参照してください。</p>
<h3 id="scope">スコープ</h3>
<p><em>スーパーグローバル</em>変数が削除されました（組み込み変数を除く、再宣言やシャドウができないので同じではありません）。</p>
<p><a href="Functions.htm#AssumeLocal">想定ローカル</a>関数内で、与えられた名前が宣言や非動的代入、<a href="Variables.htm#ref">参照（&amp;）演算子</a>のターゲットとして使用されていない場合、既存のグローバル変数に解決することがあります。</p>
<p>つまりは、"忖度 "：</p>
<ul>
<li>関数がグローバル変数を宣言せずに読み込めるようになりました。</li>
<li><code>グローバル</code>宣言を持たない関数は、グローバル変数を直接変更することはできません（意図しない副作用の原因の1つを排除する）。</li>
<li>クラスはスーパーグローバルではないので、スクリプトに新しい<code>クラス</code>を追加しても、既存の関数の動作に影響を与える可能性ははるかに低くなります。</li>
<li><code>グローバル</code>キーワードは、現在、グローバルスコープで使用すると冗長になりますが、明確にするために使用することができます。このように宣言された変数は、スーパーグローバルではないため、ローカル変数と衝突する可能性が非常に低くなりました（手動でスクリプトを組み合わせる場合や<a href="lib/_Include.htm">#Include</a>を使用する場合など）。その反面、利便性が失われる部分もあります。</li>
<li>宣言は一般的にあまり必要ありません。</li>
</ul>
<p><em>強制ローカル</em>モードは削除されました。</p>
<h3 id="variables">変数</h3>
<p>ローカル<a href="Functions.htm#static">静的</a>変数は、自動実行セクションが始まる前に線形順序で実行されるのではなく、実行が到達したときに初期化されます。各イニシャライザーは、2回目に到達したときには何の効果もない。複数の宣言を行うことができ、同じ変数に対して異なるタイミングで実行することができる。メリットは複数あります：</p>
<ul>
<li>静的イニシャライザが静的変数を持つ他の関数を呼び出す場合、関数定義の順序によりイニシャライザが未実行となる危険性が少ないです。</li>
<li>関数が呼び出されたので、パラメータ、<a href="Variables.htm#ThisFunc">A_ThisFunc</a>、クロージャが利用できるようになりました（以前は利用できませんでした）。</li>
<li>静的変数は条件付きで初期化できるため柔軟性があり、しかも<code>IsSet()</code>を必要とせず1回しか実行しない。</li>
<li>一つの静的変数に対して複数の初期化子が存在する可能性があるため、<code>static x += 1</code>のような複合代入が許可される。(この変更は、<code>ローカル</code>と <code>グローバル</code>ですでに許可されていたため、コードサイズをわずかに減らすことができました)。</li>
</ul>
<p class="note"><strong>注：</strong> <code>static init := somefunction()</code>は、<em>somefunction</em>の自動実行には使えなくなりました。しかし、ラベルとリターンに基づくサブルーチンを完全に回避できるようになったため、自動実行セクションはスクリプト全体に及ぶことができるようになりました。</p>
<p>変数を<code>local</code>で宣言しても、その関数が<a href="Functions.htm#AssumeGlobal">assume-global</a>にならなくなった。</p>
<p><a href="Variables.htm#deref">ダブルデフ</a>がロード時に解決される変数との整合性が高くなり、新しい変数を作成することができなくなりました。これにより、いくつかの矛盾や共通の混乱点を回避することができます。</p>
<p>ダブルデフが何らかの理由で失敗した場合、エラーが発生するようになりました。以前は、無効な名前を持つケースは黙って空文字列を生成し、その他のケースは空の変数を生成して返していました。</p>
<h3 id="expressions">式</h3>
<p>引用リテラル文字列は、<code>「ダブル」</code>または<code>「シングル」</code>の引用符で書くことができますが、同じ符で始まり、同じ符で終わらなければなりません。直訳の引用符は、マークの前にエスケープ文字 - <code>`"</code>または<code>`'</code> を置くか、反対のタイプの引用符を使用することで記述します：<code>''42 "が答え'</code>です。引用符を二重にしても特別な意味はなく、auto-concatではスペースが必要なのでエラーになる。</p>
<p>演算子<code>&amp;&amp;</code>,<code>||</code>,<code>and</code> <code>or</code>は、JavaScript や Lua と同様に、結果を決定したいずれかの値を出力します。例えば、<code>""や "default "</code>は、<code>1</code>ではなく、<code>"default"</code>を出力します。純粋なブール値（0または1）を必要とするスクリプトでは、<code>!!!(x or y)</code>または<code>(x or y)?1 : 0</code>を使うことができます。</p>
<p>Auto-concatでは、すべてのケースで少なくとも1つのスペースまたはタブが必要になりました（v1のドキュメントでは、スペースが「あるべき」とされています）。</p>
<p><code>x(), y()</code>のような複数文の式の結果は、最初の（一番左の）部分式ではなく、最後の（一番右の）部分式になります。v1、v2ともに、部分式は左から右の順番で評価される。</p>
<p>カンマの後のEqualsは割り当てられなくなりました：<code>x:=y,y=z</code>の<code>y=zは</code>、代入ではなく非効率的な比較である。</p>
<p><code>:= += -= *= /= ++ --</code> <code>x := y, y += 2</code>のように、単独で使うか、他の演算子と組み合わせて使うかにかかわらず、一貫した動作をする。従来は、式内でエラーが発生した場合や、数学演算で空白の値が使用された場合に、動作に違いがありました。</p>
<p><code>!=</code>は <code>=</code>と同様に常に大文字と小文字を区別するようになり、<code>!==は</code> <code>==</code>と対になるものとして追加された。</p>
<p><code>&lt;&gt;</code>は削除されました。</p>
<p><code>//</code> 浮動小数点数が与えられた場合、例外を投げるようになりました。以前は、負の浮動小数点と負の整数で結果が矛盾していました。</p>
<p><code>|</code>,<code>^</code>,<code>&amp;</code>,<code>&lt;&lt;</code>、および、<code>&gt;&gt;</code>は、浮動小数点数が与えられた場合、整数に切り捨てられるのではなく、例外を投げるようになりました。</p>
<p>科学的記数法は、小数点以下がなくても使用可能です（ただし、いずれにせよ浮動小数点数を生成します）。数値文字列を整数に変換する際、科学的表記もサポートされます（例えば、"1e3"は1ではなく1000と解釈されます）。</p>
<p>関数呼び出しでは、パラメータリストの開括弧の前にスペースやタブがなければ、どの関数を呼び出すかを指定するために、事実上どんな下位式でも使用できるようになりました。例えば、<code>MyFunc()</code>は、それが関数の実際の名前か関数オブジェクトを含む変数かにかかわらず、値<code>MyFunc</code>を呼び出し、<code>(a?b:c)()</code>は、<code>a</code>に応じて<code>b</code>または<code>cを</code>呼び出します。なお、<code>x.y()</code>はまだ<code>(x.y)(x)</code>とほぼ同等のメソッド呼び出しですが、<code>a[i]()</code>は<code>(a[i])()</code>と同等になったことに注意してください。</p>
<p>ダブルデフでは、変数名のソースとして（変数に限らず）ほぼすべての式が使用できるようになりました。例えば、<code>DoNotUseArray%n+1%</code>や <code>%(%triple%)%</code>は有効である。<code>ref := &amp;var, value := %ref</code>%のように、VarRefの再参照にもダブルデリフ構文が使われるようになりました。</p>
<p><code>funcName[""]()</code>および<code>funcName.()</code>式は、関数を名前で呼び出さなくなりました。<code>.()</code> のようにメソッド名を省略すると、ロードタイムエラーメッセージが表示されるようになりました。関数は、名前ではなく、参照によって呼び出したり、扱ったりする必要があります。</p>
<p>r値を持たない<code>var :=</code>は、ロード時にエラーとして扱われます。v1では<code>var := ""</code>と等価でしたが、他の式と組み合わせると無言で失敗します：<code>x :=, y :=</code>.</p>
<p>リテラル文字列の後に曖昧な単項/二項演算子が続く場合、ロード時にエラーが報告されます。例えば、<code>"new counter:"++counter</code>は、おそらく<code>カウンター</code>をインクリメントして表示するものと思われますが、厳密には無効な<em>加算</em>と <em>単項式プラス</em>になります。</p>
<p><code>word ++</code>と<code>word --</code>は、<code>word</code>がユーザー定義関数である可能性があるため、もはや式ではありません（また ++/- の後に変数参照を生成する式が続くことがあります）。単独でポストインクリメント式やポストデクリメント式を書くには、変数と演算子の間のスペースを省くか、変数や式を括弧で囲むかします。</p>
<p><code>word ? x : y</code>はまだ3項表現ですが、<code>word1 word2 ? x : y</code>のように単語で始まるより複雑な場合は、常に<em>word1</em>への関数呼び出しと解釈されます（そのような関数が存在しない場合でも）。複雑な条件を持つ単体の3元式を書くには、条件を括弧で囲む。</p>
<p><code>x is y</code>のような new<a href="Variables.htm#is"><code>is</code>演算子</a>は、値<em>x</em>がクラス<em>y</em>のインスタンスであるかどうかを確認するために使用されます（<em>y</em>は<code>プロトタイププロパティ</code>を持つオブジェクト（すなわちクラス）でなければなりません）。これには、<code>xがInteger</code>である（<code>IsInteger(x)</code>が変換の可能性をチェックするのに対し、これは厳密には型チェックである）のようなプリミティブな値も含まれます。</p>
<p>キーワード<code>contains</code>と <code>in</code>は将来の使用のために予約されています。</p>
<p><code>&amp;var</code>(address-of) が<code>StrPtr(var)</code>と<code>ObjPtr(obj)</code>に置き換えられ、より明確に意図を示し、エラーチェックを強化しました。v1では、address-ofは、<em>var</em>の内部文字列バッファのアドレスを返し、たとえそれが数値（オブジェクトではない）を含んでいたとしても、そのアドレスを返していました。また、オブジェクトのアドレスを取得するために使用され、間違ったタイプのアドレスを取得すると、悲惨な結果になることがあります。</p>
<p><code>&amp;var</code>が<a href="Variables.htm#ref">参照演算子</a>になり、すべての<a href="#byref">ByRef</a>と OutputVar パラメータで使用され、明快さと柔軟性が向上しました（他の言語の変更も可能になります）。詳しくは、「<a href="Concepts.htm#variable-references">変数参照（VarRef）</a>」を参照してください。</p>
<p>式の評価時に文字列の長さがキャッシュされるようになりました。これにより、パフォーマンスが向上し、文字列が2進数の0を含むことができるようになります。特に：</p>
<ul>
<li>2つの文字列の一方または両方にバイナリゼロが含まれる場合に、2つの文字列を連結しても、データが切り捨てられることがなくなりました。</li>
<li>バイナリデータの比較には、大文字と小文字を区別する等号演算子（<code>==と</code> <code>!</code>）が使えます。他の比較演算子は、最初の2進数のゼロまでしか「見えない」のです。</li>
<li>バイナリデータは、関数から返したり、オブジェクトに割り当てたりすることができます。</li>
</ul>
<p>ほとんどの関数はまだヌル終端文字列を想定しているので、最初の2進数のゼロまでしか「見えない」のです。例えば、<a href="lib/MsgBox.htm">MsgBox</a>は、文字列のうち最初の2進数のゼロより前の部分のみを表示します。</p>
<p><code>*</code>(deref)演算子は削除されました。代わりに<a href="lib/NumGet.htm">NumGet</a>を使用してください。</p>
<p><code>~</code> (<a href="Variables.htm#unary">bitwise-NOT</a>) 演算子は、常に入力を64ビットの符号付き整数として扱うようになりました。0から4294967295までの値を符号なし32ビットとして扱わなくなりました。</p>
<p>論理右ビットシフトに<code>&gt;&gt;&gt;</code>と<code>&gt;&gt;&gt;=</code>が追加されました。。</p>
<p><a href="Variables.htm#fat-arrow">太矢印の関数</a>を追加しました。<code>Fn(Parameters) =&gt; Expression</code>は、<em>Fn</em>という名前の関数（空白でも可）を定義し、<a href="lib/Func.htm">Func</a>またはClosureオブジェクトを返します。呼び出されると、この関数は<em>Expression</em>を評価し、結果を返します。他の関数の内部で使用する場合、<em>Expression</em>は外部関数の変数を参照することができます（これは通常の関数定義でも可能です）。</p>
<p>ファットアロー構文は、メソッドやプロパティのゲッター/セッターの定義にも使用できます（この場合、メソッド/プロパティの定義自体は式ではなく、その本体が式を返すだけです）。</p>
<p>メンバーアクセス（ドット）の左側で、リテラルナンバーが完全にサポートされるようになりました。例えば、<code>0.1</code>は数値ですが、<code>0.min</code>と <code>0.1.min</code>は、ベースオブジェクトが扱える<em>min</em>プロパティにアクセスします（「<a href="Objects.htm#primitive">プリミティブ値</a>」参照）。1.<code>.2</code>または<code>1.0.2</code>は、数字 1.0 の後にプロパティ 2 が続く。使用例としては、測定単位、リテラルバージョン番号、範囲などを実装することが考えられる。</p>
<p><code>x**y</code>:<code>x</code>と <code>y</code>が整数で<code>y</code>が正の場合、以前は内部で浮動小数点演算を使用していたため精度が落ちていましたが、範囲内であればすべての入力に対して正しい結果を与えるようになりました。オーバーフロー時の動作は未定義です。</p>
<h3 id="objects-misc">Objects (Misc)</h3>
<p>こちらもご覧ください：<a href="#objects">オブジェクト</a></p>
<p><code>.</code>でアクセスするプロパティと、<code>[]</code>でアクセスするデータ（アイテム、配列、マップ要素）は区別されるようになりました。例えば、<code>dictionary["Count"]</code>は "Count"の定義を返し、<code>dictionary.Count</code>は、その中に含まれる単語の数を返すことができる。ユーザー定義オブジェクトは、<a href="Objects.htm#__Item">__Itemプロパティ</a>を定義することでこれを利用することができます。</p>
<p>プロパティやメソッドの名前が事前にわからない場合、パーセント記号を使ってアクセスすることができる（しなければならない）。例えば、<code>obj.%varname%()</code>は、<code>obj[varname]()</code>と同等のv2です。<code>[]</code>は、データ（配列要素など）に使用します。</p>
<p>アドホック・オブジェクトを構築するためのリテラル構文は、やはり基本的に<code>{name：value}</code>しかし、プレーンオブジェクトは現在「配列要素」ではなく「プロパティ」しか持たないため、他のコンテキストでプロパティにアクセスする方法との一貫性を保つために、ルールが少し変更されました：</p>
<ul>
<li><code>o := {a:b}</code> は、従来通り「a」という名前を使用します。</li>
<li><code>o := {%a%:b}</code> は、<code>a</code>のプロパティ名を変数名とし、ダブルデフを行い、結果の変数の内容を使用するのではなく、<code>a</code>のプロパティ名を使用します。つまり、<code>o := {}, o.%a% := b</code>と同じ効果を発揮するのです。</li>
<li>それ以外の<code>:</code>の左側の表現は違法です。例えば、<code>{(a)：b}</code> または<code>{an error:1}</code>.</li>
</ul>
<p><code>base.Method()</code>の「base」という言葉の使用は、2つの概念をよりよく区別するために、<a href="Objects.htm#Custom_Classes_super">super</a>（<code>super.Method()</code>）に置き換えられています：</p>
<ul>
<li><code>super.</code>または<code>super[</code>は、メソッド/プロパティのスーパークラス版を呼び出します。"super-class"は、現在の関数の定義にもともと関連付けられていたプロトタイプオブジェクトのベースです。</li>
<li><code>super</code>は予約語です。<code>.</code>または<code>[</code>]または<code>()</code>の接尾辞を付けずに、またはクラスの外で使用しようとすると、ロードタイムエラーになります。</li>
<li><code>base</code>は、オブジェクトの直接のベース・オブジェクトを取得または設定する事前定義プロパティです（<a href="lib/Object.htm#SetBase">ObjGetBase</a><a href="lib/Any.htm#GetBase">/ObjSetBase</a>のように）。予約ではなく、通常のプロパティ名です。</li>
<li>スーパークラスにxの定義がない場合に<code>super.x</code>を起動するとエラーが発生しますが、これまでは<code>base.x</code>は無視されていました（たとえそれが代入であっても）。</li>
</ul>
<p>Fnがオブジェクトの場合、<code>Fn()</code>（以前は<code>%Fn%()</code>と表記）は、<code>Fn.()</code>（現在は<code>Fn.%""%()</code>としか表記できない）の代わりに<code>Fn.Call()</code>を呼ぶようになりました。関数がnamelessメソッドに対応しなくなった。</p>
<p><code>this.Method()</code>は、<code>Fn[this]()</code>の代わりに<code>Fn.Call(this)</code>（<em>Fn</em>はメソッドを実装した関数オブジェクト）を呼び出します（v1では<code>Fn[this]()</code>に関数が含まれていない限り<code>Fn.__Call(this)</code>を呼び出すことになります）。関数オブジェクトは、明示的なメソッド呼び出しにのみ使用される<em>__Call</em>の代わりに、<em>Call</em>メソッドを実装する必要があります。</p>
<p><code><i>Classname</i>()</code>（以前の<code>new <i>Classname</i>()</code>）は、<code>__New</code>メソッドが定義されているのに呼び出せなかった場合（例：パラメータ数が不正確なため）、またはパラメータが渡されたのに<code>__New</code>が定義されていない場合、オブジェクトの作成に失敗するようになりました。</p>
<p>式内で生成されたオブジェクトや関数から返されたオブジェクトは、式の評価が完了するまで保持され、その後解放されるようになりました。これにより、パフォーマンスが若干向上し、オブジェクトが早期に解放される心配がなく、式内のメモリ管理に一時的なオブジェクトを使用することができます。</p>
<p>オブジェクトには、2進数0を含む文字列値（キーは不可）を含めることができます。オブジェクトのクローンは、文字列のバイナリデータを、保存された文字列の長さまで保存します（容量ではありません）。歴史的には、バイナリデータや構造体を扱う場合、値の長さを超えてデータを書き込んでいましたが、現在では、代わりに<a href="lib/Buffer.htm">Buffer</a>オブジェクトを使用する必要があります。</p>
<p><code>x.y := z</code>のような代入式は、<code>x.y</code> の実装方法に関係なく、常に<code>z</code> の値を返すようになりました。プロパティセッターの戻り値は無視されるようになりました。以前：</p>
<ul>
<li>組み込みオブジェクトの中には<code>z</code>を返すもの、<code>x.y</code>を返すもの（<code>c := GuiObj.BackColor := "red"</code>で<code>c</code>を <code>0xFF0000</code>に設定するなど）、不正確な値を返すものがありました。</li>
<li>ユーザー定義のプロパティセッターが予期せぬ値を返したり、何も返せなかったりした可能性があります。</li>
</ul>
<p><code>x.y(z) := v</code>がシンタックスエラーになりました。以前は<code>x.y[z] := v</code>と同等でした。一般に、<code>x.y(z)</code>（メソッドコール）と<code>x.y[z]</code>（パラメータ化されたプロパティ）は異なる操作ですが、<code>x</code>がCOMオブジェクトの場合は（COMインターフェースの制限により）同等である場合があります。</p>
<p>オブジェクトを他の値と連結したり、Loopに渡すと、以前は空文字列として扱われていましたが、現在はエラーとして扱われます。これは、暗黙のうちに<code>.ToString()</code>を呼び出すように変更することができる。値を文字列に変換するには<code>String(x)</code>を使用します。<code>x</code>がオブジェクトの場合、<code>.ToString()</code>を呼び出します。</p>
<p>IDispatch（COMインターフェース）を介してオブジェクトが呼び出された場合、呼び出し元に引き渡せない捕捉できない例外は、エラーダイアログを発生させます。(呼び出し側は、具体的な詳細を伴わない追加のエラーダイアログを表示することも、しないこともあります)。これは、<a href="lib/ComObjConnect.htm">ComObjConnect</a>の使用により呼び出されるイベントハンドラにも適用されます。</p>
<h3 id="functions">機能紹介</h3>
<p>関数が正式に受け付ける以上のパラメータで動的に呼び出すことができなくなりました。</p>
<p>可変個体関数は上記の制限の影響を受けませんが、通常、呼び出されるたびに配列を作成し、剰余パラメータを保持します。この配列が不要な場合は、パラメータ名を省略できるようになり、作成されないようになりました：</p>
<pre>AcceptsOneOrMoreArgs(first, *) {
  ...
}
</pre>
<p>これは、追加パラメータが不要なコールバックに使用することができます。</p>
<p>従来は数値キーが連続する標準的なオブジェクトが必要でしたが、変種関数呼び出しでは、列挙可能なオブジェクトが使用できるようになりました。列挙者が1回の反復で複数の値を返す場合、最初の値のみが使用される。例えば、<code>Array(mymap*)</code>は、<em>mymap</em>のキーを含む配列を作成します。</p>
<p>変数型関数呼び出しは、以前は名前付きパラメータを中途半端にサポートしていました。これは、名前付きパラメータの適切な実装を妨げる可能性を排除するために、無効化されています。</p>
<p>ユーザー定義関数は、新しいキーワード<code>unset</code>をパラメータのデフォルト値として使用し、値が提供されていない場合にパラメータを「unset」にすることができます。その後、この関数は IsSet() を使用して、値が提供されたかどうかを判断することができます。<code>unset</code>は現在、他のコンテキストでは許可されていません。</p>
<p>スクリプトは、関数呼び出しが定義なしで存在する場合、複雑さと事故の可能性のため、関数ライブラリ（Lib）フォルダから自動的に含まれなくなりました（<code>MyFunc()</code>の<code>MyFunc</code>が任意の変数になることができるようになりました）。<code>#Include &lt;LibName&gt;</code>は従来通り動作します。将来のリリースでは、モジュールのサポートに取って代わられる可能性があります。</p>
<p>可変引数組込関数の<code>MaxParams</code>の値が、任意の数値（255 や 10000 など）ではなく、<code>MinParams</code>と同じになるようになりました。<code>IsVariadic</code>を使用して、上限がないことを検出します。</p>
<h4 id="byref">ByRef</h4>
<p><a href="Functions.htm#ByRef">ByRefパラメータ</a>は、<code>ByRef param</code>の代わりに<code>&amp;param</code>を使用して宣言されるようになり、使い方に若干の違いがあります。</p>
<p>ByRefパラメータが暗黙のうちに呼び出し元の変数への参照を取ることはなくなりました。その代わり、呼び出し側は<a href="Variables.htm#ref">参照演算子</a>（<code>&amp;var</code>）を使って明示的に参照を渡す必要があります。これにより、参照を別の場所に保存し、バリアド関数で受け入れ、バリアドコールで渡すなど、より柔軟な対応が可能になります。</p>
<p>パラメータがByRefとマークされている場合、VarRef以外の値を明示的に渡そうとすると、エラーが発生します。それ以外の場合は，<code>param is VarRef</code>で参照を確認し，<code>IsSetRef(param)</code>で対象の変数に値があるかどうかを確認し，<code>%param%</code>で明示的に参照解除することができます．</p>
<p>ByRefパラメータは、同じ関数が再帰的に呼び出されたときに、前のインスタンスからローカル変数への参照を受け取ることができるようになりました。</p>
<h3 id="nested-functions">ネストされた関数</h3>
<p>ある関数は、別の関数の内部で定義することができる。ネストされた関数は、（適切な条件下で）包含関数から非静的ローカル変数を自動的に「捕捉」し、包含関数が戻った後に使用できるようにすることができます。</p>
<p>また、新しい"太矢印"<code>=&gt;</code>演算子を使って、ネストした関数を作成することができます。</p>
<p>詳しくは、「<a href="Functions.htm#nested">ネストされた関数</a>」をご覧ください。</p>
<h3 id="uncategorized">未分類（Uncategorized）</h3>
<p>宣言された変数やオプションのパラメータを初期化する場合は、<code>=</code>の代わりに<code>:=</code> を使用する必要があります。</p>
<p><code>return %var%</code>が二重参照になりました。以前は<code>return var</code>と同等でした。</p>
<p><a href="lib/_Include.htm">#Include</a>は、デフォルトでカレントファイルを含むディレクトリからの相対パスとなります。そのパラメータは、オプションで引用符で囲むことができるようになりました。</p>
<p><a href="lib/_ErrorStdOut.htm">#ErrorStdOut</a>のパラメータを引用符で囲むことができるようになりました（オプション）。</p>
<p>ラベル名は、文字、数字、アンダースコア、非ASCII文字（変数、関数などと同じ）のみで構成することが求められるようになりました。</p>
<p>関数内で定義されたラベルはローカルスコープを持ち、その関数内でのみ表示され、他の場所で定義されたラベルと衝突することはありません。ローカルラベルを外部から呼び出すことはできません（組み込み関数でも）。代わりにネストされた関数を使用することで、ローカル変数を完全に使用することができます。</p>
<p><code>for k, v in obj</code>:</p>
<ul>
<li>オブジェクトの呼び出し方が変わりました。<em>エニュメレーション</em>を参照してください。</li>
<li><code>for</code>は、ループが切れたり完了した後、kとvをループ開始前の値に戻すようにしました。</li>
<li><em>obj</em>がオブジェクトでない場合、またはその列挙体の取得や呼び出しに問題がある場合は、例外が発生します。</li>
<li>最大19個の変数を使用することができます。</li>
<li>変数は省略可能です。</li>
</ul>
<p>コンマのエスケープには、もはや何の意味もありません。以前は、コマンドのパラメータ内の式で、括弧内ではなくカンマを使用すると、パラメータ間の区切り文字としてではなく、マルチステートメント演算子として解釈されるようになっていました。このように動作するのはコマンドのみで、関数や変数宣言は対象外でした。</p>
<p>エスケープシーケンス<code>`s</code>は、<code>`t</code>がサポートされている場所であればどこでも許可されるようになりました。これまでは #IfWin と (Join でしか認められていなかった。</p>
<p><code>*/</code> を行末に置いて複数行のコメントを終了できるようになり、他の言語での <code>/* */</code> の動作に関する共通の混乱点を解決しました。(例えば、<code>*/</code>で終わるホットストリングでは)曖昧さが生じる恐れがあるため、<code>*/</code>の前に<code>/*</code>がないものは無視されるようになりました(AHK_L revision 54での変更点を取り消します)。</p>
<p>64ビット符号付き整数のサポート範囲外の整数定数や数値文字列は、最小/最大値で上限が設定されるのではなく、オーバーフロー/ラップアラウンドするようになりました。これは数学の演算子と一致しているので、<code>9223372036854775807+1 == 9223372036854775808</code>（ただしどちらも-9223372036854775808が出る）。これにより、64ビット値に対するビット演算が容易になります。</p>
<p>数値文字列の場合、数字の前にスペースとタブ以外の空白文字が許されるケースは少なくなっています。一般的なルールとして（v1、v2ともに）スペースとタブのみが許可されていますが、Cランタイムライブラリの規約により他の空白文字が許容される場合もあります。</p>
<p><code>else</code>は <code>loop</code>、<code>for</code>、<code>while</code>、<code>catchと</code>一緒に使えるようになりました。For loops の場合は、ループの反復回数が0回だった場合に実行されます。For <code>catch</code>、<code>try</code>内で例外が発生しなかった場合に実行されます（エラーや値が発生した場合は、値のクラスに合致する<code>catch</code>がなくても実行されません）。そのため、<code>else</code>を中括弧なしで使用する場合、以前のバージョンと解釈が異なる場合があります。事例：</p>
<pre>if condition
{
    while condition
        <em>; 各繰り返しで実行される ;ステートメント</em>
}<em>; これらの中括弧は現在必須であり、そうでなければ else は while と関連付けられる。</em>
else
    <em>; 条件が偽の場合に実行されるステートメント</em>
</pre>
<h3 id="continuation-sections">継続の部</h3>
<p>Smart LTrim:デフォルトの動作は、継続セクションオプション以下の最初の行の先頭のスペースまたはタブの数を数え、それ以降の各行からその数のスペースまたはタブを削除することです。最初の行にスペースとタブが混在している場合、最初の種類の文字だけがインデントとして扱われます。もし、ある行が最初の行より小さくインデントされたり、間違った文字でインデントされた場合、その行のすべての先頭の空白はそのまま残されます。</p>
<p>引用符は、継続部分が引用符で囲まれた文字列の中で始まる場合、自動的にエスケープされます（すなわち、リテラル文字として解釈されます）。これにより、複数行の文字列で引用符をエスケープする必要がなくなり（開始と終了の引用符が継続部分の外にある場合）、かつ複数行の式に引用符付きの文字列を含めることができる。</p>
<p>継続セクションの上の行が名前文字で終わり、そのセクションが引用文字列の中で始まらない場合、名前と継続セクションの内容を分離するために、1つのスペースが自動的に挿入されます。これにより、<code>return</code>や関数呼び出し文などに続く複数行の表現に、継続セクションを使用することができます。また、変数名が他のトークン（または名前）と結合して無効な式になることがないようにします。</p>
<p>式中の改行文字（<code>`n</code>）はスペースとして扱われる。これにより、複数行の式を、デフォルトのオプション（<code>Join</code>の省略など）で継続セクションを使って書くことができます。</p>
<p>これらの文字をエスケープする必要がなくなったため、<code>,</code>と<code>%</code> のオプションは削除されました。</p>
<p>継続セクションの可能性のあるオプションに（<code>Join</code>オプションの一部以外として）<code>(</code>または<code>)</code>が現れる場合、全体の行は継続セクションの開始として解釈されない。つまり、<code>(x.y)()</code>や<code>(x=y) &amp;&amp; z()</code>のような行は、式として解釈されます。複数行の表現は、最初の物理行に少なくとも1つの他の<code>(</code>または<code>)</code>がある場合に限り、行頭の開括弧で始めることもできる。例えば、式全体を<code>((</code> ... <code>))</code>で囲むことができます。</p>
<p>上記の場合を除き、無効なオプションが存在する場合、無効なオプションを無視するのではなく、ロードタイムエラーを表示する。</p>
<p><code>(</code>で始まり、<code>:</code>で終わる行は、<code>(</code>がラベル名として有効でなくなったため、ラベルのように見えることを理由に継続セクションの開始対象から除外されなくなりました。これにより、<code>（Join:</code>のようなものが続き部分を開始することが可能になります。ただし、<code>(:</code>はエラーで、<code>(::</code>はホットキーのままです。</p>
<p>式や関数・プロパティ定義では、<code>(</code>/<code>[</code>/<code>{</code>は、対応する<code>)</code>/<code>]</code>/<code>}</code>と一致させなければならないという事実を利用した新しい行継続の方法がサポートされています。つまり、ある行に閉じない<code>(</code>/<code>[</code>/<code>{</code> が含まれている場合、開閉記号の数が釣り合うまで、後続の行と結合されます。行末のブレース<code>{</code>は、他に閉じない記号がなく、ブレースの直前に演算子がない場合、（オブジェクトリテラルの開始ではなく）ワントゥルーブレースとみなされます。</p>
<h3 id="continuation-lines">コンティニュエーションライン</h3>
<p>行の継続は、記号が式演算子とみなされる文脈について、より選択的になりました。一般に、カンマや式演算子は、ホットストリングやディレクティブ（#HotIf以外）、閉じない引用文字列の後など、テキスト文脈での継続に使用できなくなりました。</p>
<p>行末の式演算子に対して、行の継続が機能するようになりました。</p>
<p><code>is</code>, <code>in</code>, <code>contains</code> は行の継続に使えますが、<code>in</code>,<code>contains</code> は演算子としてまだ予約/未実装となっています。</p>
<p><code>and</code>、<code>or</code>、<code>is</code>、<code>in</code>、<code>contains</code>は、代入や他の二項演算子が続いても、もはや有効な変数名ではないので、行継続演算子として機能します。一方、v1では、<code>and</code>/<code>or</code>の後にany ofが続く場合は例外とした：<code>&lt;&gt;=/|^:,</code></p>
<p><code>VeryLongNestedClassName</code>のように、行頭で<code>.</code>の右側にスペースやタブがなかった場合、継続に<code>.</code>が使われると、2つの行は自動的にスペースで区切られなくなります。なお、<code>x .123</code>は常にプロパティアクセス（自動連結ではない）、<code>x+.123</code>はスペースの有無にかかわらず動作します。</p>
<h3 id="types">種類</h3>
<p>一般的に、値の型に依存するようなコードでは、v2の方がより一貫した結果を得ることができます。</p>
<p>v1では、変数に文字列とキャッシュされた2進数の両方を含めることができ、変数が数値として使用されるたびに更新される。このキャッシュされた2進数が値の型を検出する唯一の手段であるため、<code>var+1</code>や <code>abs(var)</code>などの式で内部的に行われるキャッシュは、副作用として<code>var</code>の「型」を効果的に変更する。v2はこのキャッシュを無効にするため、<code>str := "123"</code>は常に文字列、<code>int := 123</code>は常に整数になります。そのため、<code>str</code>はもともと純粋な数字が割り当てられている場合を除き、数字として使われるたびに（初回だけでなく）変換する必要がある。</p>
<p>組み込みの「変数」の<code>true</code>,<code>false</code>,<code>A_PtrSize</code>,<code>A_IsUnicode</code>,<code>A_Index</code>,<code>A_EventInfo</code>は常に純粋な整数を返し、文字列は返しません。v1では特定の最適化により文字列を返すことがありましたが、v2ではそのようなことはありません。</p>
<p>すべてのリテラル数値は、ロード時に純粋な2進数に変換され、その文字列表現は破棄されます。例えば、<code>MsgBox 0x1</code>は<code>MsgBox 1</code>と同等であり、<code>MsgBox 1.0000</code>は<code>MsgBox 1.0</code>と同等です（フロートのフォーマットが変更されたため）。数値を変数に格納したり、ユーザー定義関数から返したりしても、純粋な数値の状態を維持することができます。</p>
<p>浮動小数点数のデフォルトのフォーマット指定子が<code>0.17g</code>（<code>0.6f</code>だった）になり、よりコンパクトで多くのケースでより正確になっています。デフォルトは変更できませんが、<code>Format</code>を使用することで異なる書式を得ることができます。</p>
<p>引用リテラル文字列および引用リテラル文字列を連結した文字列は、無条件に非数値と見なされなくなりました。代わりに、変数に格納された文字列や関数から返された文字列と同じように扱われます。これには次のような意味があります：</p>
<ul>
<li>引用されたリテラル<code>"0</code>"は偽とみなされる。</li>
<li><code>("0xA") + 1</code>と <code>("0x" Chr(65)) + 1</code>は失敗ではなく11を生成します。</li>
<li><code>x[y:="0"]</code>と<code>x["0"]</code>が同じ挙動になりました。</li>
</ul>
<p>演算子<code>=</code>と<code>!=</code>は、オペランドが文字列の場合はアルファベット順に比較し、数値文字列の場合はアルファベット順に比較するようになりました。数値比較は、両方のオペランドが数値であり、少なくとも1つのオペランドが純粋な数値（文字列ではない）である場合にも実行されます。そのため、例えば54と "530"は数字で比較され、"54"と "530"はアルファベットで比較されます。また、変数に格納された文字列は、リテラル文字列と同じように扱われます。</p>
<p>関係演算子<code>&lt;</code>,<code>&lt;=</code>,<code>&gt;</code>,<code>&gt;=</code>を数値以外の文字列で使用すると、例外が発生するようになりました。従来は、入力が数値かアルファベットかによって比較されていましたが、リテラル引用文字列は常に非数値とみなされていました。代わりに<code>StrCompare(a, b, CaseSense)</code>を使用してください。</p>
<p><code>Type(Value)</code>は、以下の文字列のいずれかを返す：String、Integer、Float、またはオブジェクトの特定のクラス。</p>
<p><code>Float(v)</code>,<code>Integer(v)</code>,<code>String(v) は</code>、<code>v</code>をそれぞれの型に変換し、変換できない場合は例外を投げる（例：<code>Integer("1z")</code>）。<code>Number(v)</code>は、IntegerまたはFloatに変換します。<code>String</code>は、<code>v</code>がオブジェクトである場合、<code>v.ToString()</code>を呼び出します。(理想的には、オブジェクトから文字列への暗黙の変換でも行われるのですが、現在の実装ではこれが困難です)。</p>
<h2 id="objects">オブジェクト</h2>
<p>オブジェクトは、より構造化されたクラス-プロトタイプのアプローチを採用し、クラス/静的メンバとインスタンスメンバを分離しています。多くの組み込みメソッドやObj関数が移動、名称変更、変更、削除されています。</p>
<ul>
<li>ユーザー定義クラスや組み込みクラスは、<code>static</code>キーワードで定義されたメソッドやプロパティ（ベースクラスから継承したstaticメンバを含む）とネストしたクラスのみを公開するクラスオブジェクト（<a href="lib/Class.htm">Class</a>のインスタンス）である。</li>
<li>各クラスオブジェクトには、そのクラスのすべてのインスタンスの<code>ベース</code>となる<a href="lib/Class.htm#Prototype">Prototype</a>プロパティがあります。クラス本体内の非静的なメソッドやプロパティ定義は、すべてプロトタイプオブジェクトにアタッチされます。</li>
<li>インスタンス化は、<code>myClass.Call()</code>や<code>myClass()</code>のように、静的な<a href="lib/Class.htm#Call">Call</a>メソッドを呼び出すことで行われる。これにより、クラスの構築動作を完全にオーバーライドすることができます（例えば、クラスファクトリやシングルトンを実装したり、Objectの代わりにネイティブなArrayやMapを構築したりすることができます）。<code>New</code>の戻り値は無視されるようになりました。戻り値をオーバーライドする場合は、Callメソッドから行ってください。</li>
</ul>
<p>混在していたObject型は、<code>Object</code>、<code>Array</code>、<code>Map</code>（連想配列）に分割されました。</p>
<p>Objectは、すべてのユーザー定義<strong>および組み込み</strong>オブジェクトのルートクラスとなりました（VarRefおよびCOMオブジェクトは除きます）。<code>Object.Prototype</code>に追加されたメンバーは、すべてのAutoHotkeyオブジェクトに継承されます。</p>
<p><code>演算子</code>はクラスを期待するので、<code>xはy</code>は、ベースオブジェクトチェーンで<code>y.Prototype</code>をチェックする。<code>y</code>そのものを確認するには、<code>x.HasBase(y)</code>または<code>HasBase(x, y)</code>を呼び出します。</p>
<p>ユーザー定義クラスは、<code>Object</code>、<code>Array</code>、<code>Map</code>などの組み込みクラスを明示的に拡張することも可能です（ただし、拡張することが必ずしも有用とは限りません）。</p>
<p><code>新しい</code>オペレーターは削除されました。代わりに、<code>MyClass()</code>のように演算子を省略するだけです。クラスではない別のオブジェクトを<em>元に</em>オブジェクトを構成するには、<code>{}</code>または<code>Object()</code>で（あるいは他の手段で）作成し、その<code>ベース</code>を設定する。<code>__Init</code>と <code>__New</code>は、必要に応じて明示的に呼び出すことができますが、一般的にはクラスをインスタンス化するときにのみ適切です。</p>
<p>ネストされたクラス定義は、単純な値プロパティではなく、<em>get</em>および<em>call</em>アクセッサ関数を持つ動的プロパティを生成するようになりました。これは、次のような行動をサポートするためです：</p>
<ul>
<li><code>Nested.Class()</code>では、<code>Nested</code>を <code>Nested.Class.Call</code>、ひいては<code>__New</code>に渡さない。これは、メソッドとして呼び出される関数オブジェクトの通常の動作である（ここでは、入れ子のクラスはこのように使用されている）。</li>
<li><code>Nested.Class := 1</code>はデフォルトでエラーとなります（プロパティは読み取り専用です）。</li>
<li>初めて参照または呼び出すと、クラスが初期化されます。</li>
</ul>
<p>GetCapacityとSetCapacityを削除しました。</p>
<ul>
<li><a href="lib/Object.htm#GetCapacity">ObjGetCapacity</a>と <a href="lib/Object.htm#SetCapacity">ObjSetCapacity</a>は、プロパティを含むオブジェクトの容量にのみ影響するようになり、一般的に使用されることはないと予想されます。プロパティ、配列要素、マップ要素の文字列バッファの容量設定には対応していません。バイナリデータの場合は、<a href="lib/Buffer.htm">Buffer</a>オブジェクトを使用してください。</li>
<li>ArrayとMapには、オブジェクトの現在の配列またはマップの割り当てに対応するCapacityプロパティがあります。</li>
</ul>
<p>その他、冗長なObj関数（Objectの組み込みメソッドをミラーリングしたもの）を削除しました。<a href="lib/Object.htm#HasOwnProp">ObjHasOwnProp</a>（旧ObjHasKey）と<a href="lib/Object.htm#OwnProps">ObjOwnProps</a>（旧ObjNewEnum）は、これらのメソッドを再定義したオブジェクト（およびそれらが定義されていないプリミティブプロトタイプ）を安全に検査するために保持されています。ObjCountは<a href="lib/Object.htm#OwnPropCount">ObjOwnPropCount</a>（機能のみ、すべてのObjectに対して）に置き換えられ、Mapは独自の<a href="lib/Map.htm#Count">Count</a>プロパティを持ちます。</p>
<p>ObjRawGetとObjRawSetは、<a href="lib/Object.htm#GetOwnPropDesc">GetOwnPropDesc</a>と <a href="lib/Object.htm#DefineProp">DefineProp</a>に統合された。<code>Map</code>タイプ、メタファンクションの動作方法の変更、DefineProp自体がメタファンクションに取って代わるなど、当初追加した理由は他の変更に取って代わられた。</p>
<p>つまり、クラス名への代入は、ローカル変数がグローバルクラスの影になる場合（関数内で代入する場合はデフォルトで発生）を除き、オプションの警告ではなく、エラーになるようになりました。</p>
<h3 id="primitive-values">Primitive Values</h3>
<p>プリミティブ値は、v1の「デフォルトのベースオブジェクト」の代わりに、メソッドやプロパティの呼び出しをその型に応じたプロトタイプオブジェクトに委ねることで、オブジェクトを模倣します。IntegerとFloatはNumberを拡張しています。StringとNumberはPrimitiveを継承しています。PrimitiveとObjectはAnyを拡張します。これらはすべて、あらかじめ定義されたクラスとして存在します。</p>
<h3 id="properties-and-methods">プロパティとメソッド</h3>
<p>メソッドは、v2.0-a104からv2.0-a127までと異なり、プロパティに分離して定義されています。ただし、v1とは異なり、クラスメソッド定義（または組み込みメソッド）で作成されたプロパティは、デフォルトで読み取り専用となります。メソッドは、一般的にv1のように動作する新しい値プロパティを割り当てることによって、まだ作成することができます。</p>
<p>Objectクラスは、プロパティとメソッドを扱うための新しいメソッドを定義しています：<a href="lib/Object.htm#DefineProp">DefineProp</a>, <a href="lib/Object.htm#DeleteProp">DeleteProp</a>, <a href="lib/Object.htm#GetOwnPropDesc">GetOwnPropDesc</a>, <a href="lib/Object.htm#HasOwnProp">HasOwnProp</a>, <a href="lib/Object.htm#OwnProps">OwnProps</a>. すべての値（ComObjectを除く）に対して、追加のメソッドが定義されています：<a href="lib/Any.htm#GetMethod">GetMethod</a>, <a href="lib/Any.htm#HasProp">HasProp</a>, <a href="lib/Any.htm#HasMethod">HasMethod</a>.</p>
<p>Object、Array、Mapはそれぞれ別の型となり、配列の要素はプロパティとは別になりました。</p>
<p>すべての組み込みメソッドとプロパティ（<code>base</code>を含む）は、ユーザー定義と同じ方法で定義されます。これにより、一貫した動作が保証され、組み込みとユーザー定義の両方のメンバーを検出、検索、再定義することができます。</p>
<p>プロパティがパラメータを受け付けない場合、パラメータは自動的にプロパティが返すオブジェクトに渡されます（または、投げられます）。</p>
<p>存在しないプロパティを取得しようとすると、<code>__get</code>が定義されていない限り、すべてのタイプの値またはオブジェクトに対してエラーとして扱われる。ただし、存在しないプロパティを設定すると、ほとんどの場合、作成されます。</p>
<p>多次元配列のハックを削除しました。<code>x.y[z]:=1</code>で<code>x.y</code>にオブジェクトが生成されなくなり、<code>x</code>.__itemが2つのパラメータを扱わない限り（またはx.__item.__itemが扱うなど）<code>x[y,z]</code>はエラーになる。</p>
<p>プロパティが<code>get</code>を定義し、<code>set</code>を定義していない場合、値を代入すると、プロパティをオーバーライドする代わりにthrowが発生します。</p>
<p><a href="lib/Object.htm#DefineProp">DefineProp</a>は、メタファンクションを定義することなく、特定のプロパティの取得、設定、<em>または呼び出し</em>時の動作を定義するために使用することができます。クラスのプロパティ定義とメソッド定義は同じ仕組みを利用しているため、プロパティのゲッター/セッターとメソッドを同名で定義することが可能です。</p>
<p><code>{}</code> オブジェクトリテラルが、<em>所有プロパティ</em>の値やオブジェクトの <code>base</code> を直接設定するようになりました。つまり、<code>__Set</code>やプロパティセッターはもはや呼び出されない（これは通常、パラメータリスト内で<code>base</code>が設定されている場合にのみ可能である）。</p>
<h3 id="staticclass-variables">Static/Class Variables</h3>
<p>静的/クラス変数のイニシャライザーは、<code>静的な__Init</code>メソッドのコンテキスト内で実行されるようになったので、<code>これ</code>はクラスを参照し、イニシャライザーはローカル変数を作成することができます。これらは、クラスが初めて参照されたときに評価されます（自動実行部が始まる前に評価されるのではなく、厳密には定義順に評価されます）。クラスがすぐに参照されない場合は、実行中にクラス定義に到達した時点で評価されるため、グローバル変数の初期化は、クラスに入れずに最初に行うことができます。</p>
<h3 id="meta-functions">Meta-Functions</h3>
<p>メタファンクションが大幅に簡略化され、通常のメソッドと同じように動作するようになりました：</p>
<ul>
<li>階層構造の中でどこに定義されるかは重要ではありません。</li>
<li>オーバーライドされた場合、ベースバージョンは自動的に呼び出されない。スクリプトは必要に応じて<code>super.__xxx()</code>を呼び出すことができます。</li>
<li>定義されている場合、デフォルトの動作を行わなければならない。例えば、__setが値を保存しない場合、その値は保存されることはない。</li>
<li>メソッドが<code>returnを</code>使うかどうかで動作が変わることはありません（もちろん、__getや__callは依然として値を返す必要がありますが）。</li>
</ul>
<p>メソッドやプロパティのパラメータは、Arrayとして渡されます。これは、連鎖するベース/スーパークラスの呼び出しを最適化し、（MaxParamsの検証との組み合わせで）作者に引数を処理することを奨励します。For __setの場合、代入される値は別途渡される。</p>
<pre><code><div>this.__call(name, args)
this.__get(name, args)
this.__set(name, args, value)
</div></code></pre>
<p>定義されたプロパティやメソッドは、ベースオブジェクトで定義されたかどうかにかかわらず、メタファンクションよりも優先される。</p>
<p>オブジェクトがforループに渡されるときや、SetTimerで関数オブジェクトが呼び出されるときなど、__Enum（旧 _NewEnum）またはCallの内部呼び出しでは__Callは呼び出されません。</p>
<p>静的メソッド __New は、そのクラスで定義されているか、スーパークラスから継承されている場合、各クラスの初期化時に呼び出されます。詳しくは、<a href="#staticclass-variables">静的/クラス変数</a>（上）、および、<a href="Objects.htm#static__New">クラスの初期化</a>をご覧ください。</p>
<h3 id="array">配列</h3>
<p><code>クラス配列のオブジェクト拡張</code></p>
<p>配列オブジェクトは、インデックス1が最初の要素である値のリストまたはシーケンスを含んでいます。</p>
<p>配列の要素を代入・取得する場合、インデックスの絶対値が 1 から配列の<a href="lib/Array.htm#Length">Length</a>の間でなければならず、そうでない場合は例外が発生する。配列のサイズは、適切な方法で要素を挿入または削除するか、<a href="lib/Array.htm#Length">Length</a>を代入することで変更することができます。</p>
<p>現在、要素にアクセスする際には括弧が必要です。例えば、<code>a.1</code>はプロパティを指し、<code>a[1]</code>は要素を指します。</p>
<p>負の値を使用すると、逆方向のインデックスを作成することができます。</p>
<p><a href="lib/Array.htm#Clone">Clone</a>、<a href="lib/Array.htm#Delete">Delete</a>、<a href="lib/Array.htm#InsertAt">InsertAt</a>、<a href="lib/Array.htm#Pop">Pop</a>、<a href="lib/Array.htm#Push">Push</a>、<a href="lib/Array.htm#RemoveAt">RemoveAt</a>の使い方は基本的に変わりません。HasKeyは<a href="lib/Array.htm#Has">Has</a>に名称変更されました。<a href="lib/Array.htm#Length">Length</a>がプロパティになりました。<a href="lib/Array.htm#Capacity">Capacity</a>プロパティを追加しました。</p>
<p>配列は、<code>Array(values*)</code>または<code>[values*]</code>で構築することができます。変数型関数は、パラメータの配列を受け取ります。また、配列はいくつかの組み込み関数でも作成されます。</p>
<p>For-Loop の使用法は、<code>for val in arr</code>または<code>for idx, val in arr</code>で、デフォルトでは<code>idx = A_Index</code>です。つまり、値がない要素も列挙され、変数が1つしか渡されない場合はインデックスが返されない。</p>
<h3 id="map">Map</h3>
<p>Mapオブジェクトは、v1オブジェクトに似た機能を持つ連想配列ですが、より曖昧さがありません。</p>
<ul>
<li><a href="lib/Map.htm#Clone">Clone</a>は従来通り使用します。</li>
<li><a href="lib/Map.htm#Delete">Delete</a>は、一度に1つのキーしか削除できません。</li>
<li>HasKeyは<a href="lib/Map.htm#Has">Has</a>に名称変更されました。</li>
<li><a href="lib/Map.htm#Count">Count</a>がプロパティになりました。</li>
<li>新しいプロパティ：<a href="lib/Map.htm#Capacity">Capacity</a>, <a href="lib/Map.htm#CaseSense">CaseSense</a></li>
<li>新しい手法：<a href="lib/Map.htm#Get">Get</a>, <a href="lib/Map.htm#Set">Set</a>, <a href="lib/Map.htm#Clear">Clear</a></li>
<li>文字列のキーはデフォルトで大文字と小文字が区別され、Integerに変換されることはない。</li>
</ul>
<p>現在、Floatキーは文字列に変換されたままです。</p>
<p><code>a.b</code>はプロパティを、<code>a["b"]</code>は要素を意味します。v1とは異なり、配列の要素を代入することで誤ってプロパティやメソッドを無効化することはできない。</p>
<p>マップに<a href="lib/Map.htm#Default">Default</a>プロパティが定義されていない限り、存在しない要素の値を取得しようとすると例外がスローされる。<code>MapObj.Get(key, default)</code>は、各リクエストに対して明示的にデフォルト値を提供するために使用することができます。</p>
<p>キーと値のペアのリストからマップを作成するには、<code>Map(Key, Value, ...)</code>を使用します。</p>
<h3 id="enumeration">列挙</h3>
<p>列挙者モデルの変更：</p>
<ul>
<li>NewEnum()を__Enum(n)に置き換えました。</li>
<li>必須パラメータnには、for-loopの変数数が含まれており、最初の反復呼び出しまで初期化を延期することなく、列挙に影響を与えることができます。</li>
<li>Next()をCall()に置き換え、ByRefが異なる動作をする以外は同じ使い方をします。例えば、<code>Call(&amp;a)</code>として定義されたメソッドは<code>a := next_value</code>を代入する必要がありますが、<code>Call(a)</code>は<code>VarRef</code>を受け取るので<code>%a% := next_value</code>を代入すべきです。</li>
<li>__Enumが存在しない場合、オブジェクトは列挙者であるとみなされる。これにより、関数オブジェクト（クロージャなど）を直接使用することができます。</li>
</ul>
<p>配列要素とプロパティが分離されたため、プロパティの列挙には<a href="lib/Object.htm#OwnProps">OwnProps</a>を呼び出して明示的に列挙者を作成する必要があります。</p>
<h3 id="bound-functions">バウンド関数</h3>
<p>バウンドファンクションが呼び出されると、呼び出し元から渡されたパラメータが、バウンドファンクションの作成時に省略された位置を埋める。例えば、<code>F.Bind(,b).Call(a,c)</code>は<code>F(,b,a,c)</code>ではなく<code>F(a,b,c)</code>を呼び出します。</p>
<h3 id="com-objects-comobject">COMオブジェクト(ComObject)</h3>
<p>COMラッパーオブジェクトは、バリアントタイプによっていくつかの異なるクラスのインスタンスとして識別されるようになりました（以前のように、どのメソッドとプロパティをサポートするかに影響します）：</p>
<ul>
<li><code>ComValueは</code>、すべてのCOMラッパーオブジェクトの基本クラスです。</li>
<li><code>ComObject</code>は、VT_DISPATCHの非NULLポインタのためのもので、つまり、通常、通常のオブジェクト構文を使用してスクリプトから呼び出すことができる有効なCOMオブジェクトである。</li>
<li><code>ComObjArray</code>は、VT_ARRAY(SafeArrays)用です。</li>
<li><code>ComValueRef</code>は、VT_BYREF用です。</li>
</ul>
<p>これらのクラスは、<code>obj が ComObject</code>などのタイプチェックに使用できます。ComValue型、ComObjArray型、ComValueRef型（ComObjectは除く）のオブジェクトは、それぞれのプロトタイプオブジェクトを変更することにより、プロパティとメソッドを定義することができる。</p>
<p><code>ComObject(CLSID)</code>は、ComObjectを作成します。つまり、これは新しいComObjCreateです。</p>
<p>注：古いコードを更新しているときに、ComObjectにIntegerを渡したためにTypeErrorが発生した場合、代わりにComValueを呼び出す必要がある可能性があります。</p>
<p><code>ComValue(vt, value)</code>は、ラッパーオブジェクトを作成します。上記のいずれかのクラスのインスタンスを返すことができます。これは、<code>ComObjParameter(vt, value)</code>、<code>ComObject(vt, value)</code>、およびパラメータとして<em>バリアント型</em>と <em>値</em>を使用していた他の名前を置き換える。<em>値</em>は、正しいバイナリ値を持つ整数を必要とするのではなく、（COMの規約に従って）適切な型に変換されます。特に、以下のものは整数を渡されたときの挙動が以前と異なる：R4, R8, Cy, Date. ポインタ型は、従来通り純粋な整数アドレスか、オブジェクト/ComValueのいずれかを許可します。</p>
<p><code>ComObjFromPtr(pdsp)</code>は<code>ComObjEnwrap(dsp)</code>と同様の関数ですが、ObjFromPtrのようにポインタに対してAddRefを呼び出すことはしません。v1での同等品は<code>ComObject(9, dsp, 1)</code>です。v1で第3パラメータを省略するとAddRefが発生しました。</p>
<p>ComValueとComObjFromPtrは、AddRefが自動的に呼び出されることはないので、その点ではv1の<code>ComObject(9, value, 1)</code>や<code>ComObject(13, value, 1)</code>と同じ挙動をすることに注意。これは、古いスクリプトを更新する際に、<code>ObjAddRef(value)</code>を追加する必要があるとは限らず、多くのスクリプトが古い関数を間違って使用していたためです。</p>
<p>VT_BYREF、VT_ARRAY、VT_UNKNOWNのバリアントタイプを持つCOMラッパーオブジェクトに、<code>ComObjValue(ComObj)</code>と同等の<code>Ptr</code>プロパティが付くようになりました。これにより、DllCallやComCallに<code>Ptr</code>のarg型で渡すことができるようになります。また、VT_BYREF（呼び出し元の型付き変数にアクセス）、VT_ARRAY（SAFEARRAYフィールドにアクセス）、VT_UNKNOWN（vtableポインタを取得）で使用できるNumPutやNumGetにオブジェクトを直接渡すことができます。</p>
<p>VT_DISPATCHまたはVT_UNKNOWNというバリアントタイプとNULLインターフェイスポインターを持つCOMラッパーオブジェクトが、読み取りまたは割り当て可能な<code>Ptr</code>プロパティを持つようになりました。非NULLポインタが割り当てられると、このプロパティは読み取り専用になります。これはDllCallやComCallでの使用を想定しており、関数が戻った後にポインタを手動でラップする必要がない。</p>
<p>ComObjArrayの列挙がArrayと一致するようになりました。つまり、<code>for value in arr</code>や<code>for index, value in arr</code>ではなく、<code>for value, vartype in arr</code>です。。<code>index</code>の開始値はComObjArrayの下限値（<code>arr.MinIndex()</code>）であり、通常は0である。</p>
<p>整数型I1、I8、UI1、UI2、UI4、UI8は、StringではなくIntegerに変換されるようになりました。これらはCOMコールで稀に発生しますが、VT_BYREFラッパーにも適用されます。VT_ERRORはIntegerに変換されなくなり、代わりにComValueが生成されます。</p>
<p>COMオブジェクトが、プロパティやメソッドの呼び出しに失敗したときに、<a href="Variables.htm#LastError">A_LastError</a>を設定しなくなりました。</p>
<h3 id="default-property">デフォルトのプロパティ</h3>
<p>COMオブジェクトは「デフォルト・プロパティ」を持つことができ、これには2つの用途があります：</p>
<ul>
<li>オブジェクトの<em>値</em>です。例えば、VBScriptでは、<code>MsgBox obj</code>は、そのデフォルトのメンバーを呼び出すことによって、オブジェクトを評価します。</li>
<li>コレクションのインデックス付きプロパティで、通常は<code>Item</code>または<code>item</code>と名付けられる。</li>
</ul>
<p>AutoHotkey v1にはデフォルトプロパティの概念がなかったため、COMオブジェクトラッパーはプロパティ名が省略された場合、デフォルトプロパティを呼び出していました（例：<code>obj[]</code>または<code>obj[,x]</code>.</p>
<p>しかし、AutoHotkey v2では、プロパティを配列/マップ/コレクションの項目から分離しており、そのために<code>obj[x]</code>はオブジェクトのデフォルトのプロパティ（<code>x</code>が存在するかどうか）にマッピングされています。AutoHotkeyオブジェクトの場合、これは<code>__Item</code>です。</p>
<p>配列やコレクションを表すCOMオブジェクトの中には、デフォルトのプロパティを公開していないものがあるため、v2では<code>[]</code>でアイテムにアクセスすることができません。例えば、JavaScriptの配列オブジェクトや、JavaScriptで通常使用される他のいくつかのオブジェクトは、配列要素をプロパティとして公開します。このような場合、<code>arr.%i%</code>は配列の要素-プロパティにアクセスするために使用することができます。</p>
<p>AutoHotkey v2の<code>Array</code>オブジェクトをJavaScriptに渡すと、プロパティにアクセスしようとするため、JavaScriptの<code>arr[i]</code>でその要素を取得することができない。</p>
<h3 id="com-calls">COM呼び出し</h3>
<p>IDispatchインターフェースを介したAutoHotkeyオブジェクトの呼び出しが、<code>VT_BYREF</code>パラメータを透過的にサポートするようになりました。これは、COMイベント（<a href="lib/ComObjConnect.htm">ComObjConnect</a>）で最も一般的に使用されるでしょう。</p>
<p>各<code>VT_BYREF</code>パラメータに対して、無名の一時的なvarが作成され、値が呼び出し元の変数からコピーされ、<code>VarRef</code>がAutoHotkey関数/メソッドに渡されます。リターン時には、一時的な変数から呼び出し元の変数に値がコピーされます。</p>
<p>関数/メソッドは、パラメータをByRef（<code>&amp;</code>付き）で宣言するか、明示的に再参照することで、値を割り当てることができます。</p>
<p>例えば、<code>VT_BYREF|VT_BOOL</code>型のパラメータは、以前はComObjRefオブジェクトを受け取り、<code>pbCancel[] := true</code>または<code>NumPut(-1, ComObjValue(pbCancel), "short")</code>という値が割り当てられたはずです。これで、パラメータを<code>&amp;bCancel</code>と定義して<code>bCancel := true</code>のように代入することも、<code>pbCancel</code>と定義して<code>%pbCancel% := true</code>のように代入することもできるようになりました。</p>
<h2 id="library">ライブラリ</h2>
<p>削除：</p>
<ul>
<li>Asc() (<a href="lib/Ord.htm">Ord</a>使用)</li>
<li>AutoTrim（<a href="lib/Trim.htm">Trim</a>使用）</li>
<li>ComObjMissing()（代わりに2つの連続したカンマを書きます。）</li>
<li>ComObjUnwrap() (代わりに<a href="lib/ComObjValue.htm">ComObjValue</a>を使用し、必要に応じて<a href="lib/ObjAddRef.htm">ObjAddRef</a>を使用)</li>
<li>ComObjEnwrap() (代わりに<a href="lib/ComObjFromPtr.htm">ComObjFromPtr</a>を使用し、必要に応じて<a href="lib/ObjAddRef.htm">ObjAddRef</a>を使用)</li>
<li>ComObjError()</li>
<li>ComObjXXX() ここで、XXXは明示的に定義されたComObj関数以外のものです（代わりに<a href="lib/ComObjActive.htm">ComObjActive</a>、<a href="lib/ComValue.htm">ComValue</a>、<a href="lib/ComObjFromPtr.htm">ComObjFromPtr</a>を使用してください）。</li>
<li>ControlSendRaw （代わりに<code>ControlSend "{Raw}"</code>または<a href="lib/ControlSend.htm">ControlSendTextを</a>使用します。）</li>
<li>EnvDiv</li>
<li>EnvMult</li>
<li>EnvUpdate（有用性は非常に低く、単純な<a href="lib/SendMessage.htm">SendMessage</a>に置き換えることができます。）</li>
<li>Exception (<a href="lib/Error.htm">Error</a>または適切なサブクラスを使用)</li>
<li>FileReadLine（ファイル<a href="lib/LoopFiles.htm">読み込みループ</a>または<a href="lib/FileOpen.htm">FileOpen</a>を使用します。）</li>
<li>Func (<code>MyFunc</code>のように直接参照を使用する)</li>
<li>Gosub</li>
<li>Gui、GuiControl、GuiControlGet（<a href="#gui">Gui</a>の項参照）</li>
<li>IfEqual</li>
<li>IfExist</li>
<li>IfGreater</li>
<li>IfGreaterOrEqual</li>
<li>IfInString</li>
<li>IfLess</li>
<li>IfLessOrEqual</li>
<li>IfMsgBox (<a href="lib/MsgBox.htm">MsgBox</a>はボタン名を返すようになりました)</li>
<li>IfNotEqual</li>
<li>IfNotExist</li>
<li>IfNotInString</li>
<li>IfWinActive</li>
<li>IfWinExist</li>
<li>IfWinNotActive</li>
<li>IfWinNotExist</li>
<li>If between/is/in/contains (ただし、<a href="#isXXX">isXXX</a>を参照)</li>
<li>Input（<a href="lib/InputHook.htm">InputHookを</a>使用）</li>
<li>IsFunc</li>
<li>Menu（<a href="lib/Menu.htm">Menu/MenuBarクラス</a>、<a href="lib/TraySetIcon.htm">TraySetIcon</a>、<a href="Variables.htm#IconTip">A_IconTip</a>、<a href="Variables.htm#IconHidden">A_IconHidden</a>、<a href="Variables.htm#AllowMainWindow">A_AllowMainWindow</a>を使用します）。</li>
<li>MenuGetHandle（<a href="lib/Menu.htm#Handle">Menu.Handleを</a>使用します。）</li>
<li>MenuGetName（メニュー名がないため、<a href="lib/MenuFromHandle.htm">MenuFromHandle</a>が最も近い代替となる）</li>
<li>Progress （<a href="lib/Gui.htm">Guiを</a>使用）</li>
<li>SendRaw （代わりに<code>Send "{Raw}"</code>または<a href="lib/Send.htm#SendText">SendText</a>を使用します。）</li>
<li>SetBatchLines（-1がデフォルトの動作になりました。）</li>
<li>SetEnv</li>
<li>SetFormat (<a href="lib/Format.htm">Formatは</a>文字列の書式設定に使用できます)</li>
<li>SoundGet/SoundSet（<a href="#Sound">サウンド機能</a>参照）</li>
<li>SoundGetWaveVolume/SoundSetWaveVolume（バランスに関してSoundGet/SoundSetと若干異なる動作をするが、どちらもバランスは保たれない）。</li>
<li>SplashImage（<a href="lib/Gui.htm">Guiを</a>使用）</li>
<li>SplashTextOn/Off(<a href="lib/Gui.htm">Gui</a>使用)</li>
<li>StringCaseSense (各種パラメータを使用)</li>
<li>StringGetPos（<a href="lib/InStr.htm">InStrを</a>使用します。）</li>
<li>StringLeft<br>

StringLen<br>

StringMid<br>

StringRight<br>

StringTrimLeft<br>
StringTrimRight -- これらのコマンドの代わりに<a href="lib/SubStr.htm">SubStr</a>を使用します。</li>
<li>StringReplace（代わりに<a href="lib/StrReplace.htm">StrReplaceを</a>使用します。）</li>
<li>StringSplit（代わりに<a href="lib/StrSplit.htm">StrSplitを</a>使用します。）</li>
<li>Transform</li>
<li>VarSetCapacity （バイナリデータ/構造体には<a href="lib/Buffer.htm">Buffer</a>オブジェクトを、UTF-16文字列には<a href="lib/VarSetStrCapacity.htm">VarSetStrCapacity</a>を使用します。）</li>
<li>WinGetActiveStats</li>
<li>WinGetActiveTitle</li>
<li>#CommentFlag</li>
<li>#Delimiter</li>
<li>#DerefChar</li>
<li>#EscapeChar</li>
<li>#HotkeyInterval（<a href="Variables.htm#HotkeyInterval">A_HotkeyInterval</a>を使用）。</li>
<li>#HotkeyModifierTimeout（<a href="lib/A_HotkeyModifierTimeout.htm">A_HotkeyModifierTimeout</a>を使用）。</li>
<li>#IfWinActive、#IfWinExist、#IfWinNotActive、#IfWinNotExist<a href="lib/_HotIf.htm#optimization">（#HotIf Optimization</a>参照）</li>
<li>#InstallKeybdHook (<a href="lib/InstallKeybdHook.htm">InstallKeybdHook</a>関数を使用)</li>
<li>#InstallMouseHook (<a href="lib/InstallMouseHook.htm">InstallMouseHook</a>関数を使用)</li>
<li>#KeyHistory （<code>KeyHistory Nを</code>使用します。）</li>
<li>#LTrim</li>
<li>#MaxHotkeysPerInterval （<a href="lib/A_MaxHotkeysPerInterval.htm">A_MaxHotkeysPerInterval</a>を使用します。）</li>
<li>#MaxMem (各変数の最大容量が無制限になりました)</li>
<li>#MenuMaskKey （<a href="lib/A_MenuMaskKey.htm">A_MenuMaskKey</a>を使用します。）</li>
<li>#NoEnv (現在のデフォルトの動作)</li>
</ul>
<p>Renamed:</p>
<ul>
<li>ComObjCreate() →<a href="lib/ComObject.htm">ComObject</a>であり、今はクラスになっています。</li>
<li>ComObjParameter()→<a href="lib/ComValue.htm">ComValue</a>であり、現在はクラスになっています。</li>
<li>DriveSpaceFree → <a href="lib/DriveGetSpaceFree.htm">DriveGetSpaceFree</a></li>
<li>EnvAdd → <a href="lib/DateAdd.htm">DateAdd</a></li>
<li>EnvSub → <a href="lib/DateDiff.htm">DateDiff</a></li>
<li>FileCopyDir → <a href="lib/DirCopy.htm">DirCopy</a></li>
<li>FileCreateDir → <a href="lib/DirCreate.htm">DirCreate</a></li>
<li>FileMoveDir → <a href="lib/DirMove.htm">DirMove</a></li>
<li>FileRemoveDir → <a href="lib/DirDelete.htm">DirDelete</a></li>
<li>FileSelectFile → <a href="lib/FileSelect.htm">FileSelect</a></li>
<li>FileSelectFolder → <a href="lib/DirSelect.htm">DirSelect</a></li>
<li>#If → <a href="lib/_HotIf.htm">#HotIf</a></li>
<li>#IfTimeout → <a href="lib/_HotIfTimeout.htm">HotIfTimeout</a></li>
<li>StringLower → <a href="lib/StrLower.htm">StrLower</a> and <a href="lib/StrLower.htm">StrTitle</a></li>
<li>StringUpper → <a href="lib/StrLower.htm">StrUpper</a> and <a href="lib/StrLower.htm">StrTitle</a></li>
<li>UrlDownloadToFile → <a href="lib/Download.htm">Download</a></li>
<li>WinMenuSelectItem → <a href="lib/MenuSelect.htm">MenuSelect</a></li>
<li>LV, TV and SB functions → methods of <a href="lib/GuiControl.htm">GuiControl</a></li>
<li>File.__Handle → <a href="lib/File.htm#Handle">File.Handle</a></li>
</ul>
<h3 id="removed-details">Removed Commands (Details)</h3>
<p>全リストは上記をご参照ください。</p>
<p id="EnvUpdate">EnvUpdateは削除されましたが、以下のようにSendMessageの単純な呼び出しに置き換えることができます：</p>
<pre>SendMessage(0x1A, 0, StrPtr("Environment"), 0xFFFF)</pre>
<p id="StringCaseSense">StringCaseSenseが削除されたため、<code>!=</code>は常に大文字小文字を区別せず（ただし<code>!==</code>は大文字小文字を区別しない非等号のために追加）、<code>=</code>も <code>!=</code>もASCII文字に対してのみ大文字を無視します。任意のモードで文字列を比較できる<a href="lib/StrCompare.htm">StrCompare</a>を追加しました。様々な文字列関数に<em>CaseSense</em>パラメータが追加され、大文字小文字の区別やロケールモードを指定することができるようになりました。</p>
<h3 id="modified-commandsfunctions">変更されたコマンド/ファンクション</h3>
<p class="note">セクションタイトルについて：v2にはコマンドはなく、関数だけです。タイトルは両バージョンを指しています。</p>
<p>SendEventメソッドでAltイベントを送信したときに、<a href="lib/BlockInput.htm">BlockInput</a>が一瞬だけ無効になることがなくなりました。これはもともと、Windows XPの一部のバージョンで、BlockInputが人工的なAltイベントをブロックしてしまうというバグを回避するために行われたものです。</p>
<p><code>Chr(0)</code>は、2進数の0を含む、長さ1の文字列を返す。これは、文字列の2進数ゼロのサポートが改善された結果です。</p>
<p><a href="lib/ClipWait.htm">ClipWait</a>は、待ち時間が終了した場合は0を、そうでない場合は1を返すようになりました。ErrorLevelを削除しました。0を指定しても、0.5を指定したのと同じではなく、最短の待ち時間が発生するようになりました。</p>
<p><code>ComObj()</code>:この機能は、ワイルドカードのような名前で、さまざまな接尾辞をつけることができました。<code>ComObjActive(CLSID)</code>,<code>ComObjParameter(vt, value)</code>,<code>ComObjEnwrap(dsp)</code>のように、特定の種類のパラメータでよく使われる名前もありました。その代わり、関数やクラスが別々になり、ワイルドカードの名前もなくなりました。詳細は「<a href="#com-objects-comobject">COMオブジェクト（ComObject）</a>」を参照してください。</p>
<p>Control:<a href="lib/Control.htm">Control関数</a><a href="lib/SendMessage.htm">SendMessageと</a> <a href="lib/PostMessage.htm">PostMessageで</a>使用される<a href="lib/Control.htm#Parameter"><em>Control</em>パラメータに</a>いくつかの変更が加えられました：</p>
<ul>
<li>HWND（純粋な整数でなければならない）または<a href="lib/GuiControl.htm">GuiControl</a>オブジェクトのような<code>Hwnd</code>プロパティを持つオブジェクトを受け取ることができるようになりました。HWNDはコントロールやトップレベルのウィンドウを識別することができますが、後者は通常、一部の機能でしか意味を持ちません（下記参照）。</li>
<li>ただし、トップレベルウィンドウを操作できる関数<a href="lib/ControlSend.htm">（ControlSend[Text]</a>、<a href="lib/ControlClick.htm">ControlClick</a>、<a href="lib/SendMessage.htm">SendMessage</a>、<a href="lib/PostMessage.htm">PostMessage</a>）、または他のオプションパラメータが先行する場合<a href="lib/ListViewGetContent.htm">（ListViewGetContent</a>、<a href="lib/ControlGetPos.htm">ControlGetPos</a>、<a href="lib/ControlMove.htm">ControlMove</a>）は除きます。</li>
<li>省略された場合、代わりにターゲットウィンドウが使用されます。これは、以前の<a href="lib/SendMessage.htm">SendMessage</a><a href="lib/PostMessage.htm">/</a><a href="lib/SendMessage.htm">PostMessage</a>の動作と一致し、<a href="lib/ControlSend.htm">ControlSend</a>で以前使用されていた<code>ahk_parent</code>特殊値を置き換えます。</li>
<li>空白の値は無効です。関数のデフォルトがターゲットウィンドウの最上位コントロールになることはありません。</li>
</ul>
<p><a href="lib/ControlGetFocus.htm">ControlGetFocus</a>は、ClassNNの代わりにコントロールのHWNDを返すようになり、ウィンドウにフォーカスされたコントロールがないことを正常に判断した場合、エラーがあると見なされなくなりました。</p>
<p><a href="lib/ControlMove.htm">ControlMove</a>、<a href="lib/ControlGetPos.htm">ControlGetPos</a>、<a href="lib/ControlClick.htm">ControlClick</a>で、ウィンドウ座標の代わりにクライアント座標（<a href="lib/GuiControl.htm">GuiControl</a>のような）を使用するようになりました。クライアント座標は、ウィンドウのタイトルバーとボーダーを除いたクライアント領域の左上からの相対値です。(コントロールはクライアントエリア内でのみレンダリングされます)。</p>
<p><a href="lib/ControlMove.htm">ControlMove</a>、<a href="lib/ControlSend.htm">ControlSend</a>、<a href="lib/ControlSetText.htm">ControlSetText</a>は、他のControl関数と同様にパラメータの順序を使用するようになりました。つまり、<em><strong>Control</strong>、WinTitle、WinText、ExcludeTitle、ExcludeText</em>は、常に一緒に（パラメータリストの最後に）まとめられ、記憶しやすくなっています。</p>
<p>すべてのモードは何かに対して相対的であるため、<a href="lib/CoordMode.htm">CoordMode</a>はモードとして "Relative"を受け付けなくなりました。"Window"と同義語だったので、代わりにそちらを使ってください。</p>
<p><a href="lib/DllCall.htm">DllCall</a>:後述の<a href="#dllcall">DllCallの</a>項を参照。</p>
<p><a href="lib/Edit.htm">Edit</a>は、シェル動詞 "edit "が登録されていない場合、<code>.ini</code>ファイルタイプに対してフォールバック動作をしていました。スクリプトファイルには<code>.ini</code>という拡張子は期待できないため、これを削除しました。<code>AutoHotkey.ini</code>は、AutoHotkeyの古いバージョンではデフォルトのスクリプト名でした。</p>
<p><a href="lib/Edit.htm">Edit</a>は、スクリプトがstdinから読み込まれた場合、<code>*</code>のためのエディタを開こうとするのではなく、何もしないようになりました。</p>
<p><a href="lib/EnvSet.htm">EnvSet</a>で、valueパラメータが完全に省略された場合、環境変数を削除するようになりました。</p>
<p><a href="lib/Exit.htm">Exit</a>は、これまで、スクリプトが永続的でない場合、Exitを呼び出したスレッドによって中断された他のスレッドがあったとしても、<a href="lib/ExitApp.htm">ExitApp</a>として動作していました。もはや、これ以上ないほどです。その代わり、常に現在のスレッドを適切に終了させ、（非永続的な場合）最後のスレッドが終了した後にのみスクリプトを終了させます。これにより、<code>finally</code>文が実行され、ローカル変数が解放され、ローカル変数に含まれるオブジェクトに対して<code>__delete</code>が呼び出される可能性があります。</p>
<p><a href="lib/FileAppend.htm">FileAppend</a>は、<a href="lib/FileRead.htm">FileRead</a>および<a href="lib/FileOpen.htm">FileOpen</a>と同様に、行末の変換を行わないことをデフォルトとしています。FileAppendとFileReadは、オプションの接頭辞を置き換える別の<em>Options</em>パラメータを持ち、オプションのエンコーディング名（FileReadの<code>*Pnnn</code>オプションに取って代わる）を含めることができます。FileAppend、FileRead、FileOpenは、行末変換を有効にするために<code>"`n"</code>を使用します。FileAppendとFileReadは、コードページ変換（バイナリデータの読み書き）を無効にするオプション<code>"RAW"</code>をサポートしています。これは<code>*c</code>（ドキュメントのClipboardAllを参照）を置き換えるものです。FileAppend は<code>Buffer-like</code>オブジェクトを受け取ることができ、その場合、変換は行われない。</p>
<p><a href="lib/FileCopy.htm">FileCopy</a>と<a href="lib/FileMove.htm">FileMove</a>で、コピー元のパスに<code>*</code>または<code>?</code>がなく、ファイルが見つからなかった場合に例外が発生するようになりました。ただし、ソースパスにワイルドカードが含まれている場合、0個のファイルをコピーまたは移動することは、依然としてエラーとはみなされません。</p>
<p><a href="lib/FileOpen.htm">FileOpen</a>がファイルを開くのに失敗した場合、例外を投げるようになりました。そうでなければ、実際の障害発生箇所ではなく、オブジェクトに最初にアクセスしようとしたときに例外が発生します（スクリプトが障害をチェックしない場合）。</p>
<p><a href="lib/File.htm#RawRead">File.RawRead</a>:変数を直接渡す場合、その変数の内部文字列バッファのアドレスは使用されなくなります。そのため、アドレスを含む変数を直接渡すことができる（v1では<code>var+0</code>のようなものが必要であったが）。</p>
<p>スクリプトによって割り当てられたバッファの場合、変数よりも新しい<code>Buffer</code>オブジェクトが優先されます。任意のオブジェクトを使用できますが、<code>Ptr</code>と <code>Size</code>プロパティを持つ必要があります。</p>
<p><a href="lib/File.htm#RawWrite">File.RawWrite</a>:ただし、文字列（または文字列を含む変数）を受け取ることができ、その場合、<em>Bytes</em>は文字列のサイズ（バイト）をデフォルトとします。文字列には2進数のゼロを含むことができる。</p>
<p><a href="lib/File.htm#ReadLine">File.ReadLine</a>が常に行末として<code>`r</code>、<code>`n</code>、<code>`r`n</code>をサポートするようになり、行末を戻り値に含めないようになりました。EOL変換が有効でない場合、<a href="lib/File.htm#Read">File.Read</a>によって行末がそのままスクリプトに返されます。</p>
<p><a href="lib/FileEncoding.htm">FileEncoding</a>で、コードページを<code>CP</code>プレフィックスなしで番号で指定できるようになりました。そのパラメータはもはやオプションではありませんが、まだ明示的に空白にすることができます。</p>
<p><a href="lib/FileExist.htm">FileExist</a>は、すべてのディレクトリリストに含まれる<code>.</code>と<code>.</code>を無視するようになったので、dirが存在するが空である場合、<code>FileExist("dir*")</code>は真ではなく偽になりました。</p>
<p><a href="lib/FileGetAttrib.htm">FileGetAttrib</a>とA_LoopFileAttribに、リパースポイントやシンボリックリンクを表す「L」の文字が含まれるようになりました。</p>
<p>コンパイルされていないスクリプトの <a href="lib/FileInstall.htm">FileInstall</a> は、コピー元とコピー先が同じパスの場合、ファイルをコピーしようとしなくなりました（相対パスを解決した後、コピー元が <a href="Variables.htm#WorkingDir">A_WorkingDir</a> ではなく <a href="Variables.htm#ScriptDir">A_ScriptDir</a> への相対パスになっていたため）。v1ではErrorLevelが1に設定されていましたが、これはほとんど気づかれませんでした。2つの異なるパスでファイルを自分自身にコピーしようとすると、やはりエラーになります。</p>
<p>FileSelectFile（現在は<a href="lib/FileSelect.htm">FileSelect</a>という名前）には、オプション4とMでアクセスできる2つのマルチセレクトモードがありました。オプション4と対応するモードは削除され、しばらくは文書化されていませんでした。FileSelectでマルチセレクトモードを使用した場合、<code>C:⇄Dir⇄File1⇄File2</code>のような文字列ではなく、パスのArrayを返すようになりました。各配列要素には、ファイルのフルパスが含まれます。ユーザーがキャンセルした場合は、配列は空になります。</p>
<p>FileSelectは、従来のGetOpenFileName/GetSaveFileName APIに代わり、Windows Vista以降に存在するIFileDialog APIを使用するようになりました。これにより、ダイアログがカレントワーキングディレクトリを変更することに関連する（ビルトインの）回避策が不要になります。</p>
<p><em>Filter</em>が省略された場合、FileSelectはデフォルトで "Text Documents (*.txt)"という冗長なフィルターを持たないようになりました。</p>
<p>FileSelectで、<code>スペース*.extを含むパターン</code>のようなフィルターパターンからスペースを取り除かなくなりました。テストでは、パターンの両側にあるスペース（<code>*.cpp; *.h</code>のセミコロンの後など）は、すでにOSによって無視されているので、悪影響はないはずです。</p>
<p><code>D</code>オプション文字による「フォルダ選択」モードでFileSelectを使用できるようになりました。</p>
<p><a href="lib/FileSetAttrib.htm">FileSetAttrib</a>は、+、-、^ のプレフィックスが存在しない場合、何もしないのではなく、属性を上書きするようになりました。例えば、<code>FileSetAttrib(FileGetAttrib(file2), file1)</code>は、file2の属性をfile1にコピーします（file2が持っているものは追加し、持っていないものは削除します）。</p>
<p><a href="lib/FileSetAttrib.htm">FileSetAttrib</a>と <a href="lib/FileSetTime.htm">FileSetTime</a>です：<em>OperateOnFolders?</em>と<em>Recurse?</em>のパラメータは、<a href="lib/LoopFiles.htm">Loop Files</a>と同じ1つの<em>Mode</em>パラメータに置き換えられました。例えば、<code>FileSetAttrib("+a", "*.zip", "RF")</code>(Fileのみに対して再帰的に操作)。</p>
<p>NumpadキーとNumpad以外のキーの両方に対応するVKコードのNumpad以外の名前を<a href="lib/GetKeyName.htm">GetKeyName</a>で返すようにしました。例えば、<code>GetKeyName("vk25")</code>は、NumpadLeftの代わりにLeftを返します。</p>
<p><a href="lib/GetKeyState.htm">GetKeyState</a>が常に 0 または 1 を返すようになりました。</p>
<p><a href="lib/GroupActivate.htm">GroupActivate</a>は、ErrorLevelを設定する代わりに、アクティブ化のために選択されたウィンドウのHWND、または（すでにアクティブなウィンドウを除いて）一致しなかった場合は0を返すようになりました。</p>
<p><a href="lib/GroupAdd.htm">GroupAdd</a>:<em>Label</em>パラメータと関連する機能を削除しました。これは、GroupActivateが一致するウィンドウを見つけられなかった場合に検出するための直感的でない方法でした。GroupActivateの戻り値を代わりに使用する必要があります。</p>
<p><a href="lib/GroupDeactivate.htm">GroupDeactivate</a>は、<kbd>Alt</kbd>+<kbd>Esc</kbd>および<kbd>Alt</kbd>+<kbd>Shift</kbd>+<kbd>Esc</kbd>システム ホットキーとタスク バーに近い方法でウィンドウが選択されるようになりました。具体的には以下です。</p>
<ul>
<li>所有するウィンドウは評価対象外です。オーナーウィンドウが適格（グループと一致しない）である場合、オーナーウィンドウまたはその所有ウィンドウのいずれか、最後にアクティブだった方をアクティブにします。グループメンバーが所有するウィンドウはアクティブにならなくなりますが、所有するウィンドウ自体をグループに追加しても効果はありません。(以前の動作は、所有するすべてのウィンドウを循環させ、所有者を起動させることはありませんでした)。</li>
<li>無効化されたウィンドウは、その所有するウィンドウがそれよりも最近アクティブであった場合を除き、スキップされる。</li>
<li>WS_EX_NOACTIVATE スタイルを持つウィンドウは、おそらくアクティベートされることを想定していないため、スキップされます。また、<kbd>Alt</kbd>+<kbd>Esc</kbd>と<kbd>Alt</kbd>+<kbd>Shift</kbd>+<kbd>Esc</kbd>のシステムホットキーでもスキップされる。</li>
<li>WS_EX_TOOLWINDOW を持ち、WS_EX_APPWINDOW を持たないウィンドウは、タスクバーと Alt-Tab から省略され、スキップされます。</li>
</ul>
<p><a href="lib/Hotkey.htm">ホットキー</a>のデフォルトが、スクリプトの一番下の<a href="lib/_HotIf.htm">#HotIf</a>（旧#If）にならないようになりました。Hotkey/HotstringおよびHotIfスレッドのデフォルトは、ホットキーと同じ基準なので、<code>Hotkey A_ThisHotkey,"Off"</code>は、現在のホットキーがコンテキスト依存であってもオフにします。他のすべてのスレッドは、自動実行セクションで使用される最後の設定がデフォルトで、それ自体は基準なしがデフォルトです（グローバルホットキー）。</p>
<p><a href="lib/Hotkey.htm">Hotkey</a>の<em>Callback</em>パラメータに、関数オブジェクトまたはホットキー名を指定するようになりました。ラベルや関数名はサポートされなくなりました。ホットキー名が指定されている場合は、そのホットキーの本来の機能が使用されます。また、以前とは異なり、<a href="lib/_HotIf.htm">#HotIf</a>（旧#If）とも連動します。</p>
<ul>
<li>これにより、以下の特殊文字列の曖昧さが解消されるなどの利点があります：<code>On</code>, <code>Off</code>, <code>Toggle</code>, <code>AltTab</code>, <code>ShiftAltTab</code>, <code>AltTabAndMenu</code>, <code>AltTabMenuDismiss</code>. 以前の動作は、ラベル/関数が存在する場合、その名前を使用するものでしたが、<em>Label</em>パラメータに変数参照や式が含まれていない場合に限り、その名前を使用します。</li>
</ul>
<p><a href="lib/Hotkey.htm">Hotkey</a>と <a href="lib/Hotstring.htm">Hotstring</a>で、<a href="lib/_SuspendExempt.htm">Suspend</a>を免除するSオプション（新しい<a href="lib/_SuspendExempt.htm">#SuspendExempt</a>指令と同等）と、免除を無効にするS0オプションが追加されました。</p>
<p>"Hotkey If"をはじめとするIfサブコマンドを個別機能に置き換えた：<a href="lib/HotIf.htm">HotIf, HotIfWinActive, HotIfWinExist, HotIfWinNotActive, HotIfWinNotExist</a>.</p>
<p><a href="lib/HotIf.htm">HotIf</a>（旧Hotkey If）は、<code>and</code>または<code>or</code>演算子を使用した式を認識するようになりました。v1では、これらの演算子はロード時に<code>&amp;&amp;</code>や <code>||</code>に置き換えられるため、これは機能しませんでした。</p>
<p><a href="lib/Hotkey.htm">Hotkey</a>に <code>UseErrorLevel</code>オプションがなくなり、ErrorLevelを設定しないようになりました。失敗した場合は例外が発生します。エラーメッセージは、<code>Exception.Extra</code>にキーまたはホットキーの名前を、例外のクラスで失敗の理由を示す、一定の（より短い）メッセージに変更されました。</p>
<p><a href="lib/_HotIf.htm">#HotIf</a>（旧#If）は、1つのパラメータ（ThisHotkey）を持つ関数を暗黙のうちに作成するようになりました。すべての関数のデフォルトとして、この関数はassume-localです。式はローカル変数の作成とグローバル変数の読み込みが可能ですが、式に宣言を含めることができないため、グローバル変数に直接代入することはできません。</p>
<p><a href="lib/_HotIf.htm">#HotIf</a>は、<a href="lib/WinActive.htm">WinActive</a>や <a href="lib/WinExist.htm">WinExist</a>への単純な呼び出しをフックスレッドで直接評価できるように最適化されています（v1では#IfWinが、<a href="lib/HotIf.htm">HotIfWin</a>は現在もそうです）。これにより、パフォーマンスが向上し、スクリプトがビジー／無反応の場合に問題が発生するリスクを低減することができます。この最適化は、<a href="lib/WinActive.htm">WinActive</a>または<a href="lib/WinExist.htm">WinExist</a>への単一の呼び出しと最大2つのパラメータを含む式に適用され、各パラメータは単純な引用文字列で、結果はオプションで<code>!<code>または<code>not<code>で反転される。例えば、<code>#HotIf WinActive("Chrome")</code>や<code>#HotIf !WinExist("Popup") </code>のようなものです。これらの場合、任意の基準の組み合わせを持つ最初の表現は、表現またはウィンドウ基準のいずれかによって特定することができる。例えば、<code>HotIf '!WinExist("Popup")'</code>と<code>HotIfWinNotExist "Popup"</code>は同じホットキー変種を参照しています。</p>
<p><code>KeyHistory N</code>は、キーヒストリーを表示するのではなく、キーヒストリーバッファーのサイズを変更します。これは"#KeyHistory N"に置き換わるものです。</p>
<p><a href="lib/ImageSearch.htm">ImageSearch</a>は、画像が見つかった場合は true、見つからなかった場合は false を返し、検索ができなかった場合は例外を投げる。ErrorLevelが設定されていない。</p>
<p><a href="lib/IniDelete.htm">IniDelete</a>、<a href="lib/IniRead.htm">IniRead</a>、<a href="lib/IniWrite.htm">IniWrite</a>は、<a href="Variables.htm#LastError">A_LastError</a>をオペレーティングシステムのGetLastError()関数の結果に設定します。</p>
<p>要求されたキー、セクション、ファイルが見つからず、<em>Default</em>パラメータが省略された場合、<a href="lib/IniRead.htm">IniRead</a>は例外を投げる。<em>Default</em>に値が与えられた場合、<code>""</code>でも例外は発生しない。</p>
<p><a href="lib/InputHook.htm">InputHook</a>が <kbd>Shift+</kbd><kbd>Backspace</kbd>を <kbd>Backspace</kbd>と同じように扱うようになり、代わりに<code>`b'</code>に転写されるようになりました。</p>
<p><a href="lib/InputBox.htm">InputBox</a> has been given a syntax overhaul to make it easier to use (with fewer parameters). See <a href="#inputbox">InputBox</a> for usage.</p>
<p><a href="lib/InStr.htm">InStr</a>'s <em>CaseSensitive</em> parameter has been replaced with <em>CaseSense</em>, which can be 0, 1 or "Locale".</p>
<p>InStr now searches right-to-left when <em>Occurrence</em> is negative (which previously caused a result of 0), and no longer searches right-to-left if a negative <em>StartingPos</em> is used with a positive <em>Occurrence</em>. (However, it still searches right-to-left if <em>StartingPos</em> is negative and <em>Occurrence</em> is omitted.) This facilitates right-to-left searches in a loop, and allows a negative <em>StartingPos</em> to be used while still searching left-to-right.</p>
<ul>
<li>For example, <code>InStr(a, b,, -1, 2)</code> now searches left-to-right. To instead search right-to-left, use <code>InStr(a, b,, -1, -2)</code>.</li>
<li>Note that a <em>StartingPos</em> of -1 means the last character in v2, but the second last character in v1. If the example above came from v1 (rather than v2.0-a033 - v2.0-a136), the new code should be <code>InStr(a, b, -2, -2)</code>.</li>
</ul>
<p><a href="lib/KeyWait.htm">KeyWait</a> now returns 0 if the wait period expires, otherwise 1. ErrorLevelを削除しました。</p>
<p><a href="lib/MouseClick.htm">MouseClick</a> and <a href="lib/MouseClickDrag.htm">MouseClickDrag</a> are no longer affected by the system setting for swapped mouse buttons; "Left" is the always the primary button and "Right" is the secondary.</p>
<p><a href="lib/MsgBox.htm">MsgBox</a> has had its syntax changed to prioritise its most commonly used parameters and improve ease of use. See <a href="#msgbox">MsgBox</a> further below for a summary of usage.</p>
<p><a href="lib/NumPut.htm">NumPut</a>/<a href="lib/NumGet.htm">NumGet</a>:変数を直接渡す場合、その変数の内部文字列バッファのアドレスは使用されなくなります。Therefore, a variable containing an address may be passed directly (whereas in v1, something like <code>var+0</code> was necessary). For buffers allocated by the script, the new <code>Buffer</code> object is preferred over a variable; any object can be used, but must have <code>Ptr</code> and <code>Size</code> properties.</p>
<p>NumPut's parameters were reordered to allow a sequence of values, with the (now mandatory) type string preceding each number. 事例：<code>NumPut("ptr", a, "int", b, "int", c, addrOrBuffer, offset)</code>. Type is now mandatory for NumGet as well. (In comparison to DllCall, NumPut's input parameters correspond to the dll function's parameters, while NumGet's return type parameter corresponds to the dll function's return type string.)</p>
<p>The use of <code>Object(obj)</code> and <code>Object(ptr)</code> to convert between a reference and a pointer was shifted to separate functions, <code>ObjPtrAddRef(obj)</code> and <code>ObjFromPtrAddRef(ptr)</code>. There are also versions of these functions that do not increment the reference count: <code>ObjPtr(obj)</code> and <code>ObjFromPtr(ptr)</code>.</p>
<p>The OnClipboardChange label is no longer called automatically if it exists. Use the <a href="lib/OnClipboardChange.htm">OnClipboardChange</a> function which was added in v1.1.20 instead. It now requires a function object, not a name.</p>
<p><a href="lib/OnError.htm">OnError</a> now requires a function object, not a name. See also <a href="#error-handling">Error Handling</a> further below.</p>
<p>The OnExit command has been removed; use the <a href="lib/OnExit.htm">OnExit</a> function which was added in v1.1.20 instead. It now requires a function object, not a name.  A_ExitReason has also been removed; its value is available as a parameter of the OnExit callback function.</p>
<p><a href="lib/OnMessage.htm">OnMessage</a> no longer has the single-function-per-message mode that was used when a function name (string) was passed; it now only accepts a function by reference. Use <code>OnMessage(x, MyFunc)</code> where <em>MyFunc</em> is literally the name of a function, but note that the v1 equivalent would be <code>OnMessage(x, Func("MyFunc"))</code>, which allows other functions to continue monitoring message x, unlike <code>OnMessage(x, "MyFunc")</code>. To stop monitoring the message, use <code>OnMessage(x, MyFunc, 0)</code> as <code>OnMessage(x, "")</code> and <code>OnMessage(x)</code> are now errors. On failure, OnMessage throws an exception.</p>
<p><a href="lib/Pause.htm">Pause</a> is no longer exempt from <a href="lib/_MaxThreadsPerHotkey.htm">#MaxThreadsPerHotkey</a> when used on the first line of a hotkey, so <code>#p::Pause</code> is no longer suitable for toggling pause. Therefore, <code>Pause()</code> now only pauses the current thread (for combinations like ListVars/Pause), while <code>Pause(v)</code> now always operates on the underlying thread. <code>v</code> must be 0, 1 or -1. The second parameter was removed.</p>
<p><a href="lib/PixelSearch.htm">PixelSearch</a> and <a href="lib/PixelGetColor.htm">PixelGetColor</a> use RGB values instead of BGR, for consistency with other functions. Both functions throw an exception if a problem occurs, and no longer set ErrorLevel. PixelSearch returns true if the color was found. PixelSearch's slow mode was removed, as it is unusable on most modern systems due to an incompatibility with desktop composition.</p>
<p><a href="lib/PostMessage.htm">PostMessage</a>: See <a href="#SendMessage">SendMessage</a> further below.</p>
<p><a href="lib/Random.htm">Random</a> has been reworked to utilize the operating system's random number generator, lift several restrictions, and make it more convenient to use.</p>
<ul>
<li>The full 64-bit range of signed integer values is now supported (increased from 32-bit).</li>
<li>Floating-point numbers are generated from a 53-bit random integer, instead of a 32-bit random integer, and should be greater than or equal to Min and lesser than Max (but floating-point rounding errors can theoretically produce equal to Max).</li>
<li>The parameters could already be specified in any order, but now specifying only the first parameter defaults the other bound to 0 instead of 2147483647. For example, <code>Random(9)</code> returns a number between 0 and 9.</li>
<li>If both parameters are omitted, the return value is a floating-point number between 0.0 (inclusive) and 1.0 (generally exclusive), instead of an integer between 0 and 2147483647 (inclusive).</li>
<li>The system automatically seeds the random number generator, and does not provide a way to manually seed it, so there is no replacement for the <em>NewSeed</em> parameter.</li>
</ul>
<p><a href="lib/RegExMatch.htm">RegExMatch</a> options O and P were removed; O (object) mode is now mandatory. The RegExMatch object now supports enumeration (for-loop). The match object's syntax has changed:</p>
<ul>
<li>__Get is used to implement the shorthand <code>match.subpat</code> where <em>subpat</em> is the name of a subpattern/capturing group. As __Get is no longer called if a property is <em>inherited</em>, the following subpattern names can no longer be used with the shorthand syntax: Pos, Len, Name, Count, Mark. (For example, <code>match.Len</code> always returns the length of the overall match, not a captured string.)</li>
<li>Originally the match object had methods instead of properties so that properties could be reserved for subpattern names. As new language behaviour implies that <code>match.name</code> would return a function by default, the methods have been replaced or supplemented with properties:

<ul>
<li>Pos, Len and Name are now properties and methods.</li>
<li>Name now requires 1 parameter to avoid confusion (<code>match.Name</code> throws an error).</li>
<li>Count and Mark are now only properties.</li>
<li>Value has been removed; use <code>match.0</code> or <code>match[]</code> instead of <code>match.Value()</code>, and <code>match[N]</code> instead of <code>match.Value(N)</code>.</li>
</ul>
</li>
</ul>
<p>RegisterCallback was renamed to <a href="lib/CallbackCreate.htm">CallbackCreate</a> and changed to better utilize closures:</p>
<ul>
<li>It now supports <a href="misc/Functor.htm">function objects</a> (and no longer supports function names).</li>
<li>Removed EventInfo parameter (use a closure or bound function instead).</li>
<li>Removed the special behaviour of variadic callback functions and added the <code>&amp;</code> option (pass the address of the parameter list).</li>
<li>Added <code>CallbackFree(Address)</code>, to free the callback memory and release the associated function object.</li>
</ul>
<p>Registry functions (<a href="lib/RegRead.htm">RegRead</a>, <a href="lib/RegWrite.htm">RegWrite</a>, <a href="lib/RegDelete.htm">RegDelete</a>): the new syntax added in v1.1.21+ is now the only syntax. Root key and subkey are combined. Instead of <code>RootKey, Key</code>, write <code>RootKey\Key</code>. To connect to a remote registry, use <code>\\ComputerName\RootKey\Key</code> instead of <code>\\ComputerName:RootKey, Key</code>.</p>
<p>RegWrite's parameters were reordered to put <em>Value</em> first, like IniWrite (but this doesn't affect the single-parameter mode, where <em>Value</em> was the only parameter).</p>
<p>When <em>KeyName</em> is omitted and the current loop reg item is a subkey, RegDelete, RegRead and RegWrite now operate on values within that subkey; i.e. <em>KeyName</em> defaults to <code>A_LoopRegKey "\" A_LoopRegName</code> in that case (note that A_LoopRegKey was merged with A_LoopRegSubKey). Previously they behaved as follows:</p>
<ul>
<li>RegRead read a value with the same name as the subkey, if one existed in the parent key.</li>
<li>RegWrite returned an error.</li>
<li>RegDelete deleted the subkey.</li>
</ul>
<p>RegDelete, RegRead and RegWrite now allow <em>ValueName</em> to be specified when <em>KeyName</em> is omitted:</p>
<ul>
<li>If the current loop reg item is a subkey, <em>ValueName</em> defaults to empty (the subkey's default value) and <em>ValueType</em> must be specified.</li>
<li>If the current loop reg item is a value, <em>ValueName</em> and <em>ValueType</em> default to that value's name and type, but one or both can be overridden.</li>
</ul>
<p>Otherwise, RegDelete with a blank or omitted <em>ValueName</em> now deletes the key's default value (not the key itself), for consistency with RegWrite, RegRead and A_LoopRegName. The phrase "AHK_DEFAULT" no longer has any special meaning. To delete a key, use <a href="lib/RegDeleteKey.htm">RegDeleteKey</a> (new).</p>
<p><a href="lib/RegRead.htm">RegRead</a> now has a <em>Default</em> parameter, like IniRead.</p>
<p>RegRead had an undocumented 5-parameter mode, where the value type was specified after the output variable. This has been removed.</p>
<p><a href="lib/Reload.htm">Reload</a> now does nothing if the script was read from stdin.</p>
<p><a href="lib/Run.htm">Run</a> and <a href="lib/Run.htm">RunWait</a> no longer recognize the <code>UseErrorLevel</code> option as ErrorLevel was removed. Use try/catch instead. <a href="Variables.htm#LastError">A_LastError</a> is set unconditionally, and can be inspected after an exception is caught/suppressed. RunWait returns the exit code.</p>
<p><a href="lib/Send.htm">Send</a> (and its variants) now interpret <code>{LButton}</code> and <code>{RButton}</code> in a way consistent with hotkeys and <a href="lib/Click.htm">Click</a>. That is, LButton is the primary button and RButton is the secondary button, even if the user has swapped the buttons via system settings.</p>
<p id="SendMessage"><a href="lib/SendMessage.htm">SendMessage</a> and <a href="lib/PostMessage.htm">PostMessage</a> now require wParam and lParam to be integers or objects with a Ptr property; an exception is thrown if they are given a non-numeric string or float. Previously a string was passed by address if the expression began with <code>"</code>, but other strings were coerced to integers. Passing the address of a variable (formerly <code>&amp;var</code>, now <code>StrPtr(var)</code>) no longer updates the variable's length (use <code>VarSetStrCapacity(&amp;var, -1)</code>).</p>
<p>SendMessage and PostMessage now throw an exception on failure (or timeout) and do not set ErrorLevel. SendMessage returns the message reply.</p>
<p><a href="lib/SetTimer.htm">SetTimer</a> no longer supports label or function names, but as it now accepts an expression and functions can be referenced directly by name, usage looks very similar: <code>SetTimer MyFunc</code>. As with all other functions which accept an object, SetTimer now allows expressions which return an object (previously it required a variable reference).</p>
<p><a href="lib/Sort.htm">Sort</a> has received the following changes:</p>
<ul>
<li>The <em>VarName</em> parameter has been split into separate input/output parameters, for flexibility. Usage is now <code>Output := Sort(Input [, Options, Function])</code>.</li>
<li>When any two items compare equal, the original order of the items is now automatically used as a tie-breaker to ensure more stable results.</li>
<li>The <code>C</code> option now also accepts a suffix equivalent to the <em>CaseSense</em> parameter of other functions (in addition to <code>CL</code>): <code>CLocale CLogical COn C1 COff C0</code>. In particular, support for the "logical" comparison mode is new.</li>
</ul>
<p id="Sound"><a href="lib/Sound.htm">Sound functions</a>: SoundGet and SoundSet have been revised to better match the capabilities of the Vista+ sound APIs, dropping support for XP.</p>
<ul>
<li>Removed unsupported control types.</li>
<li>Removed legacy mixer component types.</li>
<li>Let components be referenced by name and/or index.</li>
<li>Let devices be referenced by name-prefix and/or index.</li>
<li>Split into separate Volume and Mute functions.</li>
<li>Added <a href="lib/SoundGetName.htm">SoundGetName</a> for retrieving device or component names.</li>
<li>Added <a href="lib/SoundGetInterface.htm">SoundGetInterface</a> for retrieving COM interfaces.</li>
</ul>
<p><a href="lib/StrGet.htm">StrGet</a>: If <em>Length</em> is negative, its absolute value indicates the exact number of characters to convert, including any binary zeros that the string might contain -- in other words, the result is always a string of exactly that length. If <em>Length</em> is positive, the converted string ends at the first binary zero as in v1.</p>
<p><a href="lib/StrGet.htm">StrGet</a>/<a href="lib/StrPut.htm">StrPut</a>: The <em>Address</em> parameter can be an object with the <code>Ptr</code> and <code>Size</code> properties, such as the new <code>Buffer</code> object. The read/write is automatically limited by <code>Size</code> (which is in bytes). If <em>Length</em> is also specified, it must not exceed <em>Size</em> (multiplied by 2 for UTF-16).</p>
<p>StrPut's return value is now in bytes, so it can be passed directly to Buffer().</p>
<p><a href="lib/StrReplace.htm">StrReplace</a> now has a <em>CaseSense</em> parameter in place of <em>OutputVarCount</em>, which is moved one parameter to the right, with <em>Limit</em> following it.</p>
<p><a href="lib/Suspend.htm">Suspend</a>: Making a hotkey or hotstring's first line a call to Suspend no longer automatically makes it exempt from suspension. Instead, use <code>#SuspendExempt</code> or the <code>S</code> option. The "Permit" parameter value is no longer valid.</p>
<p><a href="lib/Switch.htm">Switch</a> now performs case-sensitive comparison for strings by default, and has a <em>CaseSense</em> parameter which overrides the mode of case sensitivity and forces string (rather than numeric) comparison. Previously it was case-sensitive only if StringCaseSense was changed to On.</p>
<p><a href="lib/SysGet.htm">SysGet</a> now only has numeric sub-commands; its other sub-commands have been split into functions.  See <a href="#sub-commands">Sub-Commands</a> further below for details.</p>
<p>TrayTip's usage has changed to <code>TrayTip [Text, Title, Options]</code>. <em>Options</em> is a string of zero or more case-insensitive options delimited by a space or tab. The options are <code>Iconx</code>, <code>Icon!</code>, <code>Iconi</code>, <code>Mute</code> and/or any numeric value as before. TrayTip now shows even if <em>Text</em> is omitted (which is now harder to do by accident than in v1). The <em>Seconds</em> parameter no long exists (it had no effect on Windows Vista or later). Scripts may now use the NIIF_USER (0x4) and NIIF_LARGE_ICON (0x20) flags in combination (0x24) to include the large version of the tray icon in the notification. NIIF_USER (0x4) can also be used on its own for the small icon, but may not have consistent results across all OSes.</p>
<p>#Warn UseUnsetLocal and UseUnsetGlobal have been removed, as reading an unset variable now raises an error. <a href="lib/IsSet.htm">IsSet</a> can be used to avoid the error and <a href="lib/Try.htm">try</a>/<a href="lib/Catch.htm">catch</a> or <a href="lib/OnError.htm">OnError</a> can be used to handle it.</p>
<p><a href="lib/_Warn.htm#VarUnset">#Warn VarUnset</a> was added; it defaults to MsgBox. If not disabled, a warning is given for the first non-dynamic reference to each variable which is never used as the target of a direct, non-dynamic assignment or the reference operator (&amp;), or passed directly to IsSet.</p>
<p><a href="lib/_Warn.htm#Unreachable">#Warn Unreachable</a> no longer considers lines following an <code>Exit</code> call to be unreachable, as Exit is now an ordinary function.</p>
<p>#Warn ClassOverwrite has been removed, as top-level classes can no longer be overwritten by assignment. (However, they can now be implicitly shadowed by a local variable; that can be detected by #Warn LocalSameAsGlobal.)</p>
<p><a href="lib/WinActivate.htm">WinActivate</a> now sends <code>{Alt up}</code> after its first failed attempt at activating a window. Testing has shown this reduces the occurrence of flashing taskbar buttons. See the documentation for more details.</p>
<p><a href="lib/WinSetTitle.htm">WinSetTitle</a> and <a href="lib/WinMove.htm">WinMove</a> now use parameter order consistent with other Win functions; i.e. <em>WinTitle, WinText, ExcludeTitle, ExcludeText</em> are always grouped together (at the end of the parameter list), to aide memorisation.</p>
<p>The <em>WinTitle</em> parameter of various functions can now accept a HWND (must be a pure integer) or an object with a <code>Hwnd</code> property, such as a Gui object. <code>DetectHiddenWindows</code> is ignored in such cases.</p>
<p><a href="lib/WinMove.htm">WinMove</a> no longer has special handling for the literal word <code class="no-highlight">DEFAULT</code>. Omit the parameter or specify an empty string instead (this works in both v1 and v2).</p>
<p><a href="lib/WinWait.htm">WinWait</a>, <a href="lib/WinWaitClose.htm">WinWaitClose</a>, <a href="lib/WinWaitActive.htm">WinWaitActive</a> and <a href="lib/WinWaitActive.htm">WinWaitNotActive</a> return non-zero if the wait finished (timeout did not expire). ErrorLevelを削除しました。WinWait and WinWaitActive return the HWND of the found window. WinWaitClose now sets the Last Found Window, so if WinWaitClose times out, it returns false and <code>WinExist()</code> returns the last window it found. For the timeout, specifying 0 is no longer the same as specifying 0.5; instead, it produces the shortest wait possible.</p>
<p><strong>Unsorted:</strong></p>
<p>A negative <em>StartingPos</em> for <a href="lib/InStr.htm">InStr</a>, <a href="lib/SubStr.htm">SubStr</a>, <a href="lib/RegExMatch.htm">RegExMatch</a> and <a href="lib/RegExReplace.htm">RegExReplace</a> is interpreted as a position from the end. Position -1 is the last character and position 0 is invalid (whereas in v1, position 0 was the last character).</p>
<p>Functions which previously accepted On/Off or On/Off/Toggle (but not other strings) now require 1/0/-1 instead.  On and Off would typically be replaced with <code>True</code> and <code>False</code>.  Variables which returned On/Off now return 1/0, which are more useful in expressions.</p>
<ul>
<li><a href="lib/_UseHook.htm">#UseHook</a> and <a href="lib/_MaxThreadsBuffer.htm">#MaxThreadsBuffer</a> allow <code>1</code>, <code>0</code>, <code>True</code> and <code>False</code>.
(Unlike the others, they do not actually support expressions.)</li>
<li><a href="lib/ListLines.htm">ListLines</a> allows blank or boolean.</li>
<li><a href="lib/ControlSetChecked.htm">ControlSetChecked</a>, <a href="lib/ControlSetEnabled.htm">ControlSetEnabled</a>, <a href="lib/Pause.htm">Pause</a>, <a href="lib/Suspend.htm">Suspend</a>, <a href="lib/WinSetAlwaysOnTop.htm">WinSetAlwaysOnTop</a>, and <a href="lib/WinSetEnabled.htm">WinSetEnabled</a> allow <code>1</code>, <code>0</code> and <code>-1</code>.</li>
<li><a href="Variables.htm#DetectHiddenWindows">A_DetectHiddenWindows</a>, <a href="Variables.htm#DetectHiddenText">A_DetectHiddenText</a>, and <a href="Variables.htm#StoreCapsLockMode">A_StoreCapsLockMode</a> use boolean (as do the corresponding functions).</li>
</ul>
<p>The following functions return a pure integer instead of a hexadecimal string:</p>
<ul>
<li><a href="lib/ControlGetStyle.htm">ControlGetExStyle</a></li>
<li><a href="lib/ControlGetHwnd.htm">ControlGetHwnd</a></li>
<li><a href="lib/ControlGetStyle.htm">ControlGetStyle</a></li>
<li><a href="lib/MouseGetPos.htm">MouseGetPos</a></li>
<li><a href="lib/WinActive.htm">WinActive</a></li>
<li><a href="lib/WinExist.htm">WinExist</a></li>
<li><a href="lib/WinGetID.htm">WinGetID</a></li>
<li><a href="lib/WinGetIDLast.htm">WinGetIDLast</a></li>
<li><a href="lib/WinGetList.htm">WinGetList</a> (within the Array)</li>
<li><a href="lib/WinGetStyle.htm">WinGetStyle</a></li>
<li><a href="lib/WinGetStyle.htm">WinGetStyleEx</a></li>
<li><a href="lib/WinGetControlsHwnd.htm">WinGetControlsHwnd</a> (within the Array)</li>
</ul>
<p><a href="Variables.htm#ScriptHwnd">A_ScriptHwnd</a> also returns a pure integer.</p>
<h4 id="dllcall">DllCall</h4>
<p>If a type parameter is a variable, that variable's content is always used, never its name. In other words, unquoted type names are no longer supported - type names must be enclosed in quote marks.</p>
<p>When DllCall updates the length of a variable passed as Str or WStr, it now detects if the string was not properly null-terminated (likely indicating that buffer overrun has occurred), and terminates the program with an error message if so, as safe execution cannot be guaranteed.</p>
<p><code>AStr</code> (without any suffix) is now input-only. Since the buffer is only ever as large as the input string, it was usually not useful for output parameters. This would apply to WStr instead of AStr if AutoHotkey is compiled for ANSI, but official v2 releases are only ever compiled for Unicode.</p>
<p>If a function writes a new address to a <code>Str*</code>, <code>AStr*</code> or <code>WStr*</code> parameter, DllCall now assigns the new string to the corresponding variable if one was supplied, instead of merely updating the length of the original string (which probably hasn't changed). Parameters of this type are usually not used to modify the input string, but rather to pass back a string at a new address.</p>
<p>DllCall now accepts an object for any <code>Ptr</code> parameter and the <em>Function</em> parameter; the object must have a <code>Ptr</code> property. For buffers allocated by the script, the new <code>Buffer</code> object is preferred over a variable. For <code>Ptr*</code>, the parameter's new value is assigned back to the object's <code>Ptr</code> property. This allows constructs such as <code>DllCall(..., "Ptr*", unk := IUnknown.new())</code>, which reduces repetition compared to <code>DllCall(..., "Ptr*", punk), unk := IUnknown.new(punk)</code>, and can be used to ensure any output from the function is properly freed (even if an exception is thrown due to the <code>HRESULT</code> return type, although typically the function would not output a non-null pointer in that case).</p>
<p>DllCall now requires the values of numeric-type parameters to be numeric, and will throw an exception if given a non-numeric or empty string. In particular, if the * or P suffix is used for output parameters, the output variable is required to be initialized.</p>
<p>The output value (if any) of numeric parameters with the * or P suffix is ignored if the script passes a plain variable containing a number. To receive the output value, pass a <code>VarRef</code> such as <code>&amp;myVar</code> or an object with a <code>Ptr</code> property.</p>
<p>The new <code>HRESULT</code> return type throws an exception if the function failed (<code>int &lt; 0</code> or <code>uint &amp; 0x80000000</code>). This should be used only with functions that actually return a <code>HRESULT</code>.</p>
<h4 id="loop-sub-commands">Loop Sub-commands</h4>
<p>The sub-command keyword must be written literally; it must not be enclosed in quote marks and cannot be a variable or expression. All other parameters are expressions. All loop sub-commands now support OTB.</p>
<p>削除：</p>
<pre class="no-highlight">Loop, FilePattern [, IncludeFolders?, Recurse?]
Loop, RootKey [, Key, IncludeSubkeys?, Recurse?]
</pre>
<p>Use the following (added in v1.1.21) instead:</p>
<pre>Loop Files, FilePattern [, Mode]
Loop Reg, RootKey\Key [, Mode]
</pre>
<p>The comma after the second word is now optional.</p>
<p><a href="lib/LoopReg.htm#vars">A_LoopRegKey</a> now contains the root key and subkey, and A_LoopRegSubKey was removed.</p>
<h4 id="inputbox">InputBox</h4>
<pre>Obj := InputBox([Text, Title, Options, Default])
</pre>
<p>The <em>Options</em> parameter accepts a string of zero or more case-insensitive options delimited by a space or tab, similar to Gui control options. For example, this includes all supported options: <code>x0 y0 w100 h100 T10.0 Password*</code>. <code>T</code> is timeout and <code>Password</code> has the same usage as the equivalent Edit control option.</p>
<p>The width and height options now set the size of the client area (the area excluding the title bar and window frame), so are less theme-dependent.</p>
<p>The title will be blank if the <em>Title</em> parameter is an empty string. It defaults to <a href="Variables.htm#ScriptName">A_ScriptName</a> only when completely omitted, consistent with optional parameters of user-defined functions.</p>
<p><em>Obj</em> is an object with the properties <code>result</code> (containing "OK", "Cancel" or "Timeout") and <code>value</code>.</p>
<h4 id="msgbox">MsgBox</h4>
<pre>Result := MsgBox([Text, Title, Options])
</pre>
<p>The <em>Options</em> parameter accepts a string of zero or more case-insensitive options delimited by a space or tab, similar to Gui control options.</p>
<ul>
<li><code>Iconx</code>, <code>Icon?</code>, <code>Icon!</code> and <code>Iconi</code> set the icon.</li>
<li><code class="no-highlight">Default</code> followed immediately by an integer sets the <em>n</em>th button as default.</li>
<li><code>T</code> followed immediately by an integer or floating-point number sets the timeout, in seconds.</li>
<li><code>Owner</code> followed immediately by a HWND sets the owner, overriding the Gui <code>+OwnDialogs</code> option.</li>
<li>One of the following mutually-exclusive strings sets the button choices: <code>OK</code>, <code>OKCancel</code>, <code>AbortRetryIgnore</code>, <code>YesNoCancel</code>, <code>YesNo</code>, <code>RetryCancel</code>, <code>CancelTryAgainContinue</code>, or just the initials separated by slashes (<code>o/c</code>, <code>y/n</code>, etc.), or just the initials without slashes.</li>
<li>Any numeric value, the same as in v1. Numeric values can be combined with string options, or <em>Options</em> can be a pure integer.</li>
</ul>
<p>The return value is the name of the button, without spaces. These are the same strings that were used with IfMsgBox in v1.</p>
<p>The title will be blank if the <em>Title</em> parameter is an empty string. It defaults to <a href="Variables.htm#ScriptName">A_ScriptName</a> only when completely omitted, consistent with optional parameters of user-defined functions.</p>
<h4 id="sub-commands">Sub-Commands</h4>
<p>Sub-commands of Control, ControlGet, Drive, DriveGet, WinGet, WinSet and Process have been replaced with individual functions, and the main commands have been removed. Names and usage have been changed for several of the functions. The new usage is shown below:</p>
<pre><em>; Where ... means optional Control, WinTitle, etc.</em>

Bool  := ControlGetChecked(...)
Bool  := ControlGetEnabled(...)
Bool  := ControlGetVisible(...)
Int   := ControlGetIndex(...)  ; For Tab, LB, CB, DDL
Str   := ControlGetChoice(...)
Arr   := ControlGetItems(...)
Int   := ControlGetStyle(...)
Int   := ControlGetExStyle(...)
Int   := ControlGetHwnd(...)

ControlSetChecked(TrueFalseToggle, ...)
         ControlSetEnabled(TrueFalseToggle, ...)
         ControlShow(...)
         ControlHide(...)
         ControlSetStyle(Value, ...)
         ControlSetExStyle(Value, ...)
         ControlShowDropDown(...)
         ControlHideDropDown(...)
         ControlChooseIndex(Index, ...)  ; Also covers Tab
Index := ControlChooseString(Str, ...)

Index := ControlFindItem(Str, ...)
Index := ControlAddItem(Str, ...)
         ControlDeleteItem(Index, ...)

Int   := EditGetLineCount(...)
Int   := EditGetCurrentLine(...)
Int   := EditGetCurrentCol(...)
Str   := EditGetLine(N [, ...])
Str   := EditGetSelectedText(...)
         EditPaste(Str, ...)

Str   := ListViewGetContent([Options, ...])

DriveEject([Drive])
         DriveRetract([Drive])
         DriveLock(Drive)
         DriveUnlock(Drive)
         DriveSetLabel(Drive [, Label])

Str   := DriveGetList([Type])
Str   := DriveGetFilesystem(Drive)
Str   := DriveGetLabel(Drive)
Str   := DriveGetSerial(Drive)
Str   := DriveGetType(Path)
Str   := DriveGetStatus(Path)
Str   := DriveGetStatusCD(Drive)
Int   := DriveGetCapacity(Path)
Int   := DriveGetSpaceFree(Path)

<em>; Where ... means optional WinTitle, etc.</em>

Int   := WinGetID(...)
Int   := WinGetIDLast(...)
Int   := WinGetPID(...)
Str   := WinGetProcessName(...)
Str   := WinGetProcessPath(...)
Int   := WinGetCount(...)
Arr   := WinGetList(...)
Int   := WinGetMinMax(...)
Arr   := WinGetControls(...)
Arr   := WinGetControlsHwnd(...)
Int   := WinGetTransparent(...)
Str   := WinGetTransColor(...)
Int   := WinGetStyle(...)
Int   := WinGetExStyle(...)

WinSetTransparent(N [, ...])
         WinSetTransColor("Color [N]" [, ...]),
         WinSetAlwaysOnTop([TrueFalseToggle := -1, ...])
         WinSetStyle(Value [, ...])
         WinSetExStyle(Value [, ...])
         WinSetEnabled(Value [, ...])
         WinSetRegion(Value [, ...])

WinRedraw(...)
         WinMoveBottom(...)
         WinMoveTop(...)

PID   := ProcessExist([PID_or_Name])
PID   := ProcessClose(PID_or_Name)
PID   := ProcessWait(PID_or_Name [, Timeout])
PID   := ProcessWaitClose(PID_or_Name [, Timeout])

ProcessSetPriority(Priority [, PID_or_Name])
</pre>
<p><a href="lib/ProcessExist.htm">ProcessExist</a>, <a href="lib/ProcessClose.htm">ProcessClose</a>, <a href="lib/ProcessWait.htm">ProcessWait</a> and <a href="lib/ProcessWaitClose.htm">ProcessWaitClose</a> no longer set ErrorLevel; instead, they return the PID.</p>
<p>None of the other functions set ErrorLevel. Instead, they throw an exception on failure. In most cases failure is because the target window or control was not found.</p>
<p>HWNDs and styles are always returned as pure integers, not hexadecimal strings.</p>
<p><a href="lib/ControlChooseIndex.htm">ControlChooseIndex</a> allows 0 to deselect the current item/all items. It replaces "Control Choose", but also supports Tab controls.</p>
<p>"ControlGet Tab" was merged into <a href="lib/ControlGetIndex.htm">ControlGetIndex</a>, which also works with ListBox, ComboBox and DDL. For Tab controls, it returns 0 if no tab is selected (rare but valid). <a href="lib/ControlChooseIndex.htm">ControlChooseIndex</a> does not permit 0 for Tab controls since applications tend not to handle it.</p>
<p><a href="lib/ControlGetItems.htm">ControlGetItems</a> replaces "ControlGet List" for ListBox and ComboBox. It returns an Array.</p>
<p><a href="lib/DriveEject.htm">DriveEject</a> and <a href="lib/DriveEject.htm">DriveRetract</a> now use DeviceIoControl instead of mciSendString. DriveEject is therefore able to eject non-CD/DVD drives which have an "Eject" option in Explorer (i.e. removable drives but not external hard drives which show as fixed disks).</p>
<p><a href="lib/ListViewGetContent.htm">ListViewGetContent</a> replaces "ControlGet List" for ListView, and currently has the same usage as before.</p>
<p><a href="lib/WinGetList.htm">WinGetList</a>, <a href="lib/WinGetControls.htm">WinGetControls</a> and <a href="lib/WinGetControlsHwnd.htm">WinGetControlsHwnd</a> return arrays, not newline-delimited lists.</p>
<p><a href="lib/WinSetTransparent.htm">WinSetTransparent</a> treats <code>""</code> as <code>"Off"</code> rather than <code>0</code> (which would make the window invisible and unclickable).</p>
<p>Abbreviated aliases such as Topmost, Trans, FS and Cap were removed.</p>
<p>The following functions were formerly sub-commands of <a href="lib/SysGet.htm">SysGet</a>:</p>
<pre>Exists  := MonitorGet(N, Left, Top, Right, Bottom)
Exists  := MonitorGetWorkArea(N, Left, Top, Right, Bottom)
Count   := MonitorGetCount()
Primary := MonitorGetPrimary()
Name    := MonitorGetName(N)
</pre>
<h3 id="new-functions">New Functions</h3>
<p><code>Buffer(Size, FillByte)</code> (calling the Buffer class) creates and returns a <code>Buffer</code> object encapsulating a block of <em>Size</em> bytes of memory, initialized only if <em>FillByte</em> is specified. <code>BufferObj.Ptr</code> returns the address and <code>BufferObj.Size</code> returns or sets the size in bytes (reallocating the block of memory). Any object with Ptr and Size properties can be passed to <a href="lib/NumPut.htm">NumPut</a>, <a href="lib/NumGet.htm">NumGet</a>, <a href="lib/StrPut.htm">StrPut</a>, <a href="lib/StrGet.htm">StrGet</a>, <a href="lib/File.htm#RawRead">File.RawRead</a>, <a href="lib/File.htm#RawWrite">File.RawWrite</a> and <a href="lib/FileAppend.htm">FileAppend</a>. Any object with a <code>Ptr</code> property can be passed to <a href="lib/DllCall.htm">DllCall</a> parameters with <code>Ptr</code> type, <a href="lib/SendMessage.htm">SendMessage</a> and <a href="lib/PostMessage.htm">PostMessage</a>.</p>
<p><code>CaretGetPos([&amp;X, &amp;Y])</code> retrieves the current coordinates of the caret (text insertion point). This ensures the X and Y coordinates always match up, and there is no caching to cause unexpected behaviour (such as A_CaretX/Y returning a value that's not in the current CoordMode).</p>
<p><code>ClipboardAll([Data, Size])</code> creates an object containing everything on the clipboard (optionally accepting data previously retrieved from the clipboard instead of using the clipboard's current contents). The methods of reading and writing clipboard file data are different. The data format is the same, except that the data size is always 32-bit, so that the data is portable between 32-bit and 64-bit builds. See the v2 documentation for details.</p>
<p><code>ComCall(offset, comobj, ...)</code> is equivalent to <code>DllCall(NumGet(NumGet(comobj.ptr) + offset * A_Index), "ptr", comobj.ptr, ...)</code>, but with the return type defaulting to "hresult" rather than "int".</p>
<p><a href="lib/ComObject.htm">ComObject</a> (formerly ComObjCreate) and <a href="lib/ComObjQuery.htm">ComObjQuery</a> now return a wrapper object even if an IID is specified. ComObjQuery permits the first parameter to be any object with a <code>Ptr</code> property.</p>
<p><a href="lib/ControlGetClassNN.htm">ControlGetClassNN</a> returns the ClassNN of the specified control.</p>
<p><a href="lib/ControlSend.htm">ControlSendText</a>, equivalent to ControlSendRaw but using {Text} mode instead of {Raw} mode.</p>
<p><code>DirExist(Path)</code>, with usage similar to FileExist. Note that <code>InStr(FileExist(Pattern), "D")</code> only tells you whether the <em>first</em> matching file is a folder, not whether a folder exists.</p>
<p><code>Float(v)</code>: See <a href="#types">Types</a> further above.</p>
<p><code>InstallKeybdHook(Install := true, Force := false)</code> and <code>InstallMouseHook(Install := true, Force := false)</code> replace the corresponding directives, for increased flexibility.</p>
<p><code>Integer(v)</code>: See <a href="#types">Types</a> further above.</p>
<p id="isXXX"><a href="lib/Is.htm">isXXX</a>: The legacy command "if var is type" has been replaced with a series of functions: isAlnum, isAlpha, isDigit, isFloat, isInteger, isLower, isNumber, isSpace, isUpper, isXDigit. With the exception of isFloat, isInteger and isNumber, an exception is thrown if the parameter is not a string, as implicit conversion to string may cause counter-intuitive results.</p>
<p><code>IsSet(var)</code>, <code>IsSetRef(&amp;var)</code>: Returns true if the variable has been assigned a value (even if that value is an empty string), otherwise false. If false, attempting to read the variable within an expression would throw an error.</p>
<p><code>Menu()</code>/<code>MenuBar()</code> returns a new Menu/MenuBar object, which has the following members corresponding to v1 Menu sub-commands. Methods: <a href="lib/Menu.htm#Add">Add</a>, <a href="lib/Menu.htm#AddStandard"><strong>Add</strong>Standard</a>, <a href="lib/Menu.htm#Check">Check</a>, <a href="lib/Menu.htm#Delete">Delete</a>, <a href="lib/Menu.htm#Disable">Disable</a>, <a href="lib/Menu.htm#Enable">Enable</a>, <a href="lib/Menu.htm#Insert">Insert</a>, <a href="lib/Menu.htm#Rename">Rename</a>, <a href="lib/Menu.htm#SetColor"><strong>Set</strong>Color</a>, <a href="lib/Menu.htm#SetIcon"><strong>Set</strong>Icon</a>, <a href="lib/Menu.htm#Show">Show</a>, <a href="lib/Menu.htm#ToggleCheck">ToggleCheck</a>, <a href="lib/Menu.htm#ToggleEnable">ToggleEnable</a>, <a href="lib/Menu.htm#Uncheck">Uncheck</a>. Properties: <a href="lib/Menu.htm#ClickCount">Click<strong>Count</strong></a>, <a href="lib/Menu.htm#Default">Default</a>, <a href="lib/Menu.htm#Handle">Handle</a> (replaces MenuGetHandle). <a href="Variables.htm#TrayMenu">A_TrayMenu</a> also returns a Menu object. There is no UseErrorLevel mode, no global menu names, and no explicitly deleting the menu itself (that happens when all references are released; the <a href="lib/Menu.htm#Delete">Delete</a> method is equivalent to v1 DeleteAll). Labels are not supported, only function objects. The <a href="lib/Menu.htm#AddStandard">AddStandard</a> method adds the standard menu items and allows them to be individually modified as with custom items. Unlike v1, the Win32 menu is destroyed only when the object is deleted.</p>
<p><code>MenuFromHandle(Handle)</code> returns the Menu object corresponding to a Win32 menu handle, if it was created by AutoHotkey.</p>
<p><code>Number(v)</code>: See <a href="#types">Types</a> further above.</p>
<p><code>Persistent(Persist := true)</code> replaces the corresponding directive, increasing flexibility.</p>
<p><code>RegDeleteKey("RootKey\SubKey")</code> deletes a registry key. (RegDelete now only deletes values, except when omitting all parameters in a registry loop.)</p>
<p><a href="lib/Send.htm#SendText">SendText</a>, equivalent to SendRaw but using {Text} mode instead of {Raw} mode.</p>
<p><code>StrCompare(str1, str2 [, CaseSense := false])</code> returns -1 (str1 is less than str2), 0 (equal) or 1 (greater than). <em>CaseSense</em> can be "Locale".</p>
<p><code>String(v)</code>: See <a href="#types">Types</a> further above.</p>
<p><code>StrPtr(str)</code> returns the address of a string. Unlike address-of in v1, it can be used with literal strings and temporary strings.</p>
<p><code>SysGetIPAddresses()</code> returns an array of IP addresses, equivalent to the A_IPAddress variables which have been removed. Each reference to <code>A_IPAddress%N%</code> retrieved all addresses but returned only one, so retrieving multiple addresses took exponentially longer than necessary. The returned array can have zero or more elements.</p>
<p><code>TraySetIcon([FileName, IconNumber, Freeze])</code> replaces "Menu Tray, Icon".</p>
<p><code>VarSetStrCapacity(&amp;Var [, NewCapacity])</code> replaces the v1 VarSetCapacity, but is intended for use only with UTF-16 strings (such as to optimize repeated concatenation); therefore <em>NewCapacity</em> and the return value are in characters, not bytes.</p>
<p><code>VerCompare(A, B)</code> compares two version strings using the same algorithm as <a href="lib/_Requires.htm">#Requires</a>.</p>
<p><code>WinGetClientPos([&amp;X, &amp;Y, &amp;W, &amp;H, WinTitle, ...])</code> retrieves the position and size of the window's client area, in screen coordinates.</p>
<h3 id="new-directives">New Directives</h3>
<p><code>#DllLoad [FileOrDirName]</code>: Loads a DLL or EXE file before the script starts executing.</p>
<h3 id="built-in-variables">組み込みの変数</h3>
<p><a href="Variables.htm#AhkPath">A_AhkPath</a> always returns the path of the current executable/interpreter, even when the script is compiled. Previously it returned the path of the compiled script if a BIN file was used as the base file, but v2.0 releases no longer include BIN files.</p>
<p><a href="Variables.htm#IsCompiled">A_IsCompiled</a> returns 0 instead of "" if the script has not been compiled.</p>
<p><a href="Variables.htm#OSVersion">A_OSVersion</a> always returns a string in the format <code>major.minor.build</code>, such as <code>6.1.7601</code> for Windows 7 SP1. A_OSType has been removed as only NT-based systems are supported.</p>
<p><a href="Variables.htm#TimeSincePriorHotkey">A_TimeSincePriorHotkey</a> returns "" instead of -1 whenever <a href="Variables.htm#PriorHotkey">A_PriorHotkey</a> is "", and likewise for <a href="Variables.htm#TimeSinceThisHotkey">A_TimeSinceThisHotkey</a> when <a href="Variables.htm#ThisHotkey">A_ThisHotkey</a> is blank.</p>
<p>All built-in "virtual" variables now have the <code>A_</code> prefix (specifics below). Any predefined variables which lack this prefix (such as <code>Object</code>) are just global variables. The distinction may be important since it is currently impossible to take a reference to a virtual variable (except when passed directly to a built-in function); however, <a href="Variables.htm#Args">A_Args</a> is not a virtual variable.</p>
<p>Built-in variables which return numbers now return them as an <a href="Concepts.htm#numbers">integer</a> rather than a <a href="Concepts.htm#strings">string</a>.</p>
<p>Renamed:</p>
<ul>
<li>A_LoopFileFullPath → <a href="lib/LoopFiles.htm#LoopFilePath">A_LoopFilePath</a> (returns a relative path if the Loop's parameter was relative, so "full path" was misleading)</li>
<li>A_LoopFileLongPath → <a href="lib/LoopFiles.htm#LoopFileFullPath">A_LoopFileFullPath</a></li>
<li>Clipboard → <a href="lib/A_Clipboard.htm">A_Clipboard</a></li>
</ul>
<p>削除：</p>
<ul>
<li>ClipboardAll (replaced with the <a href="lib/ClipboardAll.htm">ClipboardAll</a> function)</li>
<li>ComSpec (use <a href="Variables.htm#ComSpec">A_ComSpec</a>)</li>
<li>ProgramFiles (use <a href="Variables.htm#ProgramFiles">A_ProgramFiles</a>)</li>
<li>A_AutoTrim</li>
<li>A_BatchLines</li>
<li>A_CaretX, A_CaretY (use <a href="lib/CaretGetPos.htm">CaretGetPos</a>)</li>
<li>A_DefaultGui, A_DefaultListView, A_DefaultTreeView</li>
<li>A_ExitReason</li>
<li>A_FormatFloat</li>
<li>A_FormatInteger</li>
<li>A_Gui, A_GuiControl, A_GuiControlEvent, A_GuiEvent, A_GuiX, A_GuiY, A_GuiWidth, A_GuiHeight (all replaced with parameters of <a href="lib/GuiOnEvent.htm">event handlers</a>)</li>
<li>A_IPAddress1, A_IPAddress2, A_IPAddress3, A_IPAddress4 (use <a href="lib/SysGetIPAddresses.htm">SysGetIPAddresses</a>)</li>
<li>A_IsUnicode (v2 is always Unicode; it can be replaced with <code>StrLen(Chr(0xFFFF))</code> or redefined with <code>global A_IsUnicode := 1</code>)</li>
<li>A_StringCaseSense</li>
<li>A_ThisLabel</li>
<li>A_ThisMenu, A_ThisMenuItem, A_ThisMenuItemPos (use the <a href="lib/Menu.htm#Add">menu item callback's parameters</a>)</li>
<li>A_LoopRegSubKey (<a href="lib/LoopReg.htm#vars">A_LoopRegKey</a> now contains the root key and subkey)</li>
<li>True and False (still exist, but are now only keywords, not variables)</li>
</ul>
<p>Added:</p>
<ul>
<li><a href="Variables.htm#AllowMainWindow">A_AllowMainWindow</a> (read/write; replaces "Menu Tray, MainWindow/NoMainWindow")</li>
<li><a href="Variables.htm#HotkeyInterval">A_HotkeyInterval</a> (replaces #HotkeyInterval)</li>
<li><a href="Variables.htm#HotkeyModifierTimeout">A_HotkeyModifierTimeout</a> (replaces #HotkeyModifierTimeout)</li>
<li><a href="Variables.htm#InitialWorkingDir">A_InitialWorkingDir</a> (see <a href="#default-settings">Default Settings</a> further below)</li>
<li><a href="Variables.htm#MaxHotkeysPerInterval">A_MaxHotkeysPerInterval</a> (replaces #MaxHotkeysPerInterval)</li>
<li><a href="Variables.htm#MenuMaskKey">A_MenuMaskKey</a> (replaces #MenuMaskKey)</li>
</ul>
<p>The following built-in variables can be assigned values:</p>
<ul>
<li><a href="Variables.htm#ControlDelay">A_ControlDelay</a></li>
<li><a href="Variables.htm#CoordMode">A_CoordMode..</a></li>
<li><a href="Variables.htm#DefaultMouseSpeed">A_DefaultMouseSpeed</a></li>
<li><a href="Variables.htm#DetectHiddenText">A_DetectHiddenText</a> (also, it now returns 1 or 0 instead of "On" or "Off")</li>
<li><a href="Variables.htm#DetectHiddenWindows">A_DetectHiddenWindows</a> (also, it now returns 1 or 0 instead of "On" or "Off")</li>
<li><a href="Variables.htm#EventInfo">A_EventInfo</a></li>
<li><a href="Variables.htm#FileEncoding">A_FileEncoding</a> (also, it now returns "CP0" in place of "", and allows the "CP" prefix to be omitted when assigning)</li>
<li><a href="Variables.htm#IconHidden">A_IconHidden</a></li>
<li><a href="Variables.htm#IconTip">A_IconTip</a> (also, it now always reflects the tooltip, even if it is default or empty)</li>
<li><a href="Variables.htm#Index">A_Index</a>: For counted loops, modifying this affects how many iterations are performed. (The global nature of built-in variables means that an Enumerator function could set the index to be seen by a For loop.)</li>
<li><a href="Variables.htm#KeyDelay">A_KeyDelay</a></li>
<li><a href="Variables.htm#KeyDelayPlay">A_KeyDelayPlay</a></li>
<li><a href="Variables.htm#KeyDelay">A_KeyDuration</a></li>
<li><a href="Variables.htm#KeyDelayPlay">A_KeyDurationPlay</a></li>
<li><a href="Variables.htm#LastError">A_LastError</a>: Calls the Win32 SetLastError() function. Also, it now returns an unsigned value.</li>
<li><a href="Variables.htm#ListLines">A_ListLines</a></li>
<li><a href="Variables.htm#MouseDelay">A_MouseDelay</a></li>
<li><a href="Variables.htm#MouseDelay">A_MouseDelayPlay</a></li>
<li><a href="Variables.htm#RegView">A_RegView</a></li>
<li><a href="Variables.htm#ScriptName">A_ScriptName</a>: Changes the default dialog title.</li>
<li><a href="Variables.htm#SendLevel">A_SendLevel</a></li>
<li><a href="Variables.htm#SendMode">A_SendMode</a></li>
<li><a href="Variables.htm#StoreCapsLockMode">A_StoreCapsLockMode</a> (also, it now returns 1 or 0 instead of "On" or "Off")</li>
<li><a href="Variables.htm#TitleMatchMode">A_TitleMatchMode</a></li>
<li><a href="Variables.htm#TitleMatchModeSpeed">A_TitleMatchModeSpeed</a></li>
<li><a href="Variables.htm#WinDelay">A_WinDelay</a></li>
<li><a href="Variables.htm#WorkingDir">A_WorkingDir</a>: Same as calling <a href="lib/SetWorkingDir.htm">SetWorkingDir</a>.</li>
</ul>
<h3 id="built-in-objects">Built-in Objects</h3>
<p>File objects now strictly require property syntax when invoking properties and method syntax when invoking methods. For example, <code>File.Pos(n)</code> is not valid. An exception is thrown if there are too few or too many parameters, or if a read-only property is assigned a value.</p>
<p><code>File.Tell()</code> was removed.</p>
<p><code>Func.IsByRef()</code> now works with built-in functions.</p>
<h2 id="gui">Gui</h2>
<p>Gui, GuiControl and GuiControlGet were replaced with <a href="lib/Gui.htm#Call">Gui()</a> and <a href="lib/Gui.htm">Gui</a>/<a href="lib/GuiControl.htm">GuiControl</a> objects, which are generally more flexible, more consistent, and easier to use.</p>
<p>A GUI is typically not referenced by name/number (although it can still be named with <code>GuiObj.Name</code>). Instead, a GUI object (and window) is created explicitly by instantiating the <code>Gui</code> class, as in <code>GuiObj := Gui()</code>. This object has methods and properties which replace the Gui sub-commands. <code>GuiObj.Add()</code> returns a GuiControl object, which has methods and properties which replace the GuiControl and GuiControlGet commands. One can store this object in a variable, or use <code>GuiObj["Name"]</code> or <code>GuiCtrlFromHwnd(hwnd)</code> to retrieve the object. It is also passed as a parameter whenever an event handler (the replacement of a g-label) is called.</p>
<p>The usage of these methods and properties is not 1:1. Many parts have been revised to be more consistent and flexible, and to fix bugs or limitations.</p>
<p>There are no "default" GUIs, as the target Gui or control object is always specified. LV/TV/SB functions were replaced with methods (of the control object), making it much easier to use multiple ListViews/TreeViews.</p>
<p>There are no built-in variables containing information about events. The information is passed as parameters to the function/method which handles the event, including the source Gui or control.</p>
<p>Controls can still be named and be referenced by name, but it's just a name (used with <code>GuiObj["Name"]</code> and <code>GuiObj.Submit()</code>), not an associated variable, so there is no need to declare or create a global or static variable. The value is never stored in a variable automatically, but is accessible via <code>GuiCtrl.Value</code>. <code>GuiObj.Submit()</code> returns a new associative array using the control names as keys.</p>
<p>The v<em>Name</em> option now just sets the control's name to <em>Name</em>.</p>
<p>The +Hwnd<em>VarName</em> option has been removed in favour of <code>GuiCtrl.Hwnd</code>.</p>
<p>There are no more "g-labels" or labels/functions which automatically handle GUI events. The script must register for each event of interest by calling the <a href="lib/GuiOnEvent.htm">OnEvent</a> method of the Gui or GuiControl. For example, rather than checking <code>if (A_GuiEvent = "I" &amp;&amp; InStr(ErrorLevel, "F", true))</code> in a g-label, the script would register a handler for the <code>ItemFocus</code> event: <code>MyLV.OnEvent("ItemFocus", MyFunction)</code>. <em>MyFunction</em> would be called only for the ItemFocus event. It is not necessary to apply <code>AltSubmit</code> to enable additional events.</p>
<p>Arrays are used wherever a pipe-delimited list was previously used, such as to specify the items for a ListBox when creating it, when adding items, or when retrieving the selected items.</p>
<p>Scripts can define a class which extends <code>Gui</code> and handles its own events, keeping all of the GUI logic self-contained.</p>
<h3 id="gui-sub-commands">Gui sub-commands</h3>
<p><strong>Gui New</strong> → <a href="lib/Gui.htm#Call">Gui()</a>. Passing an empty title (not omitting it) now results in an empty title, not the default title.</p>
<p><strong>Gui Add</strong> → <a href="lib/Gui.htm#Add">GuiObj.Add() or GuiObj.Add<em>ControlType</em>()</a>; e.g. <code>GuiObj.Add("Edit")</code> or <code>GuiObj.AddEdit()</code>.</p>
<p><strong>Gui Show</strong> → <a href="lib/Gui.htm#Show">GuiObj.Show()</a>, but it has no <em>Title</em> parameter. The title can be specified as a parameter of Gui() or via the GuiObj.Title property. The initial focus is still set to the first input-capable control with the WS_TABSTOP style (as per default message processing by the system), unless that's a Button control, in which case focus is now shifted to the Default button.</p>
<p><strong>Gui Submit</strong> → <a href="lib/Gui.htm#Submit">GuiObj.Submit()</a>. It works like before, except that Submit() creates and returns a new object which contains all of the "associated variables".</p>
<p><strong>Gui Destroy</strong> → <a href="lib/Gui.htm#Destroy">GuiObj.Destroy()</a>. The object still exists (until the script releases it) but cannot be used. A new GUI must be created (if needed). The window is also destroyed when the object is deleted, but the object is "kept alive" while the window is visible.</p>
<p><strong>Gui Font</strong> → <a href="lib/Gui.htm#SetFont">GuiObj.SetFont()</a>. It is also possible to set a control's font directly, with GuiCtrl.SetFont().</p>
<p><strong>Gui Color</strong> → <a href="lib/Gui.htm#BackColor">GuiObj.BackColor</a> sets/returns the background color. <em>ControlColor</em> (the second parameter) is not supported, but all controls which previously supported it can have a background set by the <code>+Background</code> option instead. Unlike "Gui Color", GuiObj.BackColor does not affect Progress controls or disabled/read-only Edit, DDL, ComboBox or TreeView (with -Theme) controls.</p>
<p><strong>Gui Margin</strong> → <a href="lib/Gui.htm#MarginX">GuiObj.MarginX</a> and <a href="lib/Gui.htm#MarginY">GuiObj.MarginY</a> properties.</p>
<p><strong>Gui Menu</strong> → <a href="lib/Gui.htm#MenuBar">GuiObj.MenuBar</a> sets/returns a MenuBar object created with <code>MenuBar()</code>.</p>
<p><strong>Gui Cancel/Hide/Minimize/Maximize/Restore</strong> → Gui methods of the same name.</p>
<p><strong>Gui Flash</strong> → <a href="lib/Gui.htm#Flash">GuiObj.Flash()</a>, but use <code>false</code> instead of <code>Off</code>.</p>
<p><strong>Gui Tab</strong> → <a href="lib/GuiControl.htm#UseTab">TabControl.UseTab()</a>. Defaults to matching a prefix of the tab name as before. Pass true for the second parameter to match the whole tab name, but unlike the v1 "Exact" mode, it is case-insensitive.</p>
<h3 id="events">Events</h3>
<p>See <a href="lib/GuiOnEvent.htm#Events">Events (OnEvent)</a> for details of all explicitly supported GUI and GUI control events.</p>
<p>The Size event passes 0, -1 or 1 (consistent with <a href="lib/WinGetMinMax.htm">WinGetMinMax</a>) instead of 0, 1 or 2.</p>
<p>The ContextMenu event can be registered for each control, or for the whole GUI.</p>
<p>The DropFiles event swaps the <em>FileArray</em> and <em>Ctrl</em> parameters, to be consistent with ContextMenu.</p>
<p>The ContextMenu and DropFiles events use client coordinates instead of window coordinates (Client is also the default <a href="lib/CoordMode.htm">CoordMode</a> in v2).</p>
<p>The following control events were removed, but detecting them is a simple case of passing the appropriate numeric notification code (defined in the Windows SDK) to <a href="lib/GuiOnNotify.htm">GuiCtrl.OnNotify()</a>: K, D, d, A, S, s, M, C, E and MonthCal's 1 and 2.</p>
<p>Control events do not pass the event name as a parameter (GUI events never did).</p>
<p>Custom's N and Normal events were replaced with <a href="lib/GuiOnNotify.htm">GuiCtrl.OnNotify()</a> and <a href="lib/GuiOnCommand.htm">GuiCtrl.OnCommand()</a>, which can be used with any control.</p>
<p>Link's Click event passes "Ctrl, ID or Index, HREF" instead of "Ctrl, Index, HREF or ID", and does not automatically execute HREF if a Click callback is registered.</p>
<p>ListView's Click, DoubleClick and ContextMenu (when triggered by a right-click) events now report the item which was clicked (or 0 if none) instead of the focused item.</p>
<p>ListView's I event was split into multiple named events, except for the f (de-focus) event, which was excluded because it is implied by F (ItemFocus).</p>
<p>ListView's e (ItemEdit) event is ignored if the user cancels.</p>
<p>Slider's Change event is raised more consistently than the v1 g-label; i.e. it no longer ignores changes made by the mouse wheel by default. See <a href="lib/GuiControls.htm#slider-change">Detecting Changes (Slider)</a> for details.</p>
<p>The BS_NOTIFY style is now added automatically as needed for Button, CheckBox and Radio controls. It is no longer applied by default to Radio controls.</p>
<p>Focus (formerly F) and LoseFocus (formerly f) are supported by more (but not all) control types.</p>
<p>Setting an Edit control's text with Edit.Value or Edit.Text does not trigger the control's Change event, whereas GuiControl would trigger the control's g-label.</p>
<p>LV/TV.Add/Modify now suppress item-change events, so such events should only be raised by user action or SendMessage.</p>
<h3 id="removed">Removed</h3>
<p>+Delimiter<br>

+Hwnd<em>OutputVar</em> (use <a href="lib/Gui.htm#Hwnd">GuiObj.Hwnd</a> or <a href="lib/GuiControl.htm#Hwnd">GuiCtrl.Hwnd</a> instead)<br>

+Label<br>

+LastFoundExist<br>

Gui GuiName: Default</p>
<h3 id="control-options">Control Options</h3>
<p>+/-Background is interpreted and supported more consistently. All controls which supported "Gui Color" now support <code>+Background<i>Color</i></code> and <code>+BackgroundDefault</code> (synonymous with <code>-Background</code>), not just ListView/TreeView/StatusBar/Progress.</p>
<p><a href="lib/Gui.htm#Add">GuiObj.Add</a> defaults to <code>y+m</code>/<code>x+m</code> instead of <code>yp</code>/<code>xp</code> when <code>xp</code>/<code>yp</code> or <code>xp+0</code>/<code>yp+0</code> is used. In other words, the control is placed below/to the right of the previous control instead of at exactly the same position. If a non-zero offset is used, the behaviour is the same as in v1. To use exactly the same position, specify <code>xp yp</code> together.</p>
<p><code>x+m</code> and <code>y+m</code> can be followed by an additional offset, such as <code>x+m+10</code> (<code>x+m10</code> is also valid, but less readable).</p>
<p><code>Choose</code> no longer serves as a redundant (undocumented) way to specify the value for a MonthCal. Just use the <em>Text</em> parameter, as before.</p>
<h3 id="guicontrolget">GuiControlGet</h3>
<h4 id="empty-sub-command">Empty sub-command</h4>
<p>GuiControlGet's empty sub-command had two modes: the default mode, and text mode, where the fourth parameter was the word <code>Text</code>. If a control type had no single "value", GuiControlGet defaulted to returning the result of <a href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowtexta">GetWindowText</a> (which isn't always visible text). Some controls had no visible text, or did not support retrieving it, so completely ignored the fourth parameter. By contrast, <a href="lib/GuiControl.htm#Text">GuiCtrl.Text</a> returns display text, hidden text (the same text returned by ControlGetText) or nothing at all.</p>
<p>The table below shows the closest equivalent property or function for each mode of GuiControlGet and control type.</p>
<table class="info">
<tr><th>Control</th><th>Default</th><th>Text</th><th>Notes</th></tr>
<tr><td>ActiveX</td><td>.Value</td><td>.Text</td><td>Text is hidden. See below.</td></tr>
<tr><td>Button</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>CheckBox</td><td>.Value</td><td>.Text</td><td></td></tr>
<tr><td>ComboBox</td><td>.Text</td><td>ControlGetText()</td><td>Use Value instead of Text if AltSubmit was used (but Value returns 0 if Text does not match a list item). Text performs case-correction, whereas ControlGetText returns the Edit field's content.</td></tr>
<tr><td>Custom</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>DateTime</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>DDL</td><td colspan="2">.Text</td><td>Use Value instead of Text if AltSubmit was used.</td></tr>
<tr><td>Edit</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>GroupBox</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>Hotkey</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Link</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>ListBox</td><td>.Text</td><td>ControlGetText()</td><td>Use Value instead of Text if AltSubmit was used. Text returns the selected item's text, whereas ControlGetText returns hidden text. See below.</td></tr>
<tr><td>ListView</td><td colspan="2">.Text</td><td>Text is hidden.</td></tr>
<tr><td>MonthCal</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Picture</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Progress</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Radio</td><td>.Value</td><td>.Text</td><td></td></tr>
<tr><td>Slider</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>StatusBar</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>タブ</td><td>.Text</td><td>ControlGetText()</td><td>Use Value instead of Text if AltSubmit was used. Text returns the selected tab's text, whereas ControlGetText returns hidden text.</td></tr>
<tr><td>Text</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>TreeView</td><td colspan="2">.Text</td><td>Text is hidden.</td></tr>
<tr><td>UpDown</td><td colspan="2">.Value</td><td></td></tr>
</table>
<p>ListBox: For multi-select ListBox, Text and Value return an array instead of a pipe-delimited list.</p>
<p>ActiveX: <a href="lib/GuiControl.htm#Value">GuiCtrl.Value</a> returns the same object each time, whereas GuiControlGet created a new wrapper object each time. Consequently, it is no longer necessary to retain a reference to an ActiveX object for the purpose of keeping a <a href="lib/ComObjConnect.htm">ComObjConnect</a> connection alive.</p>
<h4 id="other-sub-commands">Other sub-commands</h4>
<p><strong>Pos</strong> → <a href="lib/GuiControl.htm#GetPos">GuiCtrl.GetPos()</a></p>
<p><strong>Focus</strong> → <a href="lib/Gui.htm#FocusedCtrl">GuiObj.FocusedCtrl</a>; returns a GuiControl object instead of the ClassNN.</p>
<p><strong>FocusV</strong> → <code>GuiObj.FocusedCtrl.Name</code></p>
<p><strong>Hwnd</strong> → <a href="lib/GuiControl.htm#Hwnd">GuiCtrl.Hwnd</a>; returns a pure integer, not a hexadecimal string.</p>
<p><strong>Enabled/Visible/Name</strong> → GuiCtrl properties of the same name.</p>
<h3 id="guicontrol">GuiControl</h3>
<h4 id="blank-and-text-sub-commands">(Blank) and Text sub-commands</h4>
<p>The table below shows the closest equivalent property or function for each mode of GuiControl and control type.</p>
<table class="info">
<tr><th>Control</th><th>(Blank)</th><th>Text</th><th>Notes</th></tr>
<tr><td>ActiveX</td><td colspan="2">N/A</td><td>Command had no effect.</td></tr>
<tr><td>Button</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>CheckBox</td><td>.Value</td><td>.Text</td><td></td></tr>
<tr><td>ComboBox</td><td>.Delete/Add/Choose</td><td>.Text</td><td></td></tr>
<tr><td>Custom</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>DateTime</td><td>.Value</td><td>.SetFormat()</td><td></td></tr>
<tr><td>DDL</td><td colspan="2">.Delete/Add/Choose</td><td></td></tr>
<tr><td>Edit</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>GroupBox</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>Hotkey</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Link</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>ListBox</td><td colspan="2">.Delete/Add/Choose</td><td></td></tr>
<tr><td>ListView</td><td colspan="2">N/A</td><td>Command had no effect.</td></tr>
<tr><td>MonthCal</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Picture</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Progress</td><td colspan="2">.Value</td><td>Use the <code>+=</code> operator instead of the <code>+</code> prefix.</td></tr>
<tr><td>Radio</td><td>.Value</td><td>.Text</td><td></td></tr>
<tr><td>Slider</td><td colspan="2">.Value</td><td>Use the <code>+=</code> operator instead of the <code>+</code> prefix.</td></tr>
<tr><td>StatusBar</td><td colspan="2">.Text or SB.SetText()</td><td></td></tr>
<tr><td>タブ</td><td colspan="2">.Delete/Add/Choose</td><td></td></tr>
<tr><td>Text</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>TreeView</td><td colspan="2">N/A</td><td>Command had no effect.</td></tr>
<tr><td>UpDown</td><td colspan="2">.Value</td><td>Use the <code>+=</code> operator instead of the <code>+</code> prefix.</td></tr>
</table>
<h4 id="other-sub-commands-1">Other sub-commands</h4>
<p><strong>Move</strong> → <a href="lib/GuiControl.htm#Move">GuiCtrl.Move(x, y, w, h)</a></p>
<p><strong>MoveDraw</strong> → GuiCtrl.Move(x, y, w, h), <a href="lib/GuiControl.htm#Redraw">GuiCtrl.Redraw()</a></p>
<p><strong>Focus</strong> → <a href="lib/GuiControl.htm">GuiCtrl.Focus()</a>, which now uses WM_NEXTDLGCTL instead of SetFocus, so that focusing a Button temporarily sets it as the default, consistent with tabbing to the control.</p>
<p><strong>Enable/Disable</strong> → set <a href="lib/GuiControl.htm#Enabled">GuiCtrl.Enabled</a></p>
<p><strong>Hide/Show</strong> → set <a href="lib/GuiControl.htm#Visible">GuiCtrl.Visible</a></p>
<p><strong>Choose</strong> → <a href="lib/GuiControl.htm#Choose">GuiCtrl.Choose(n)</a>, where in is a pure integer. The <code>|n</code> or <code>||n</code> mode is not supported (use ControlChoose instead, if needed).</p>
<p><strong>ChooseString</strong> → <a href="lib/GuiControl.htm#Choose">GuiCtrl.Choose(s)</a>, where s is not a pure integer. The <code>|n</code> or <code>||n</code> mode is not supported. If the string matches multiple items in a multi-select ListBox, Choose() selects them all, not just the first.</p>
<p><strong>Font</strong> → <a href="lib/GuiControl.htm#SetFont">GuiCtrl.SetFont()</a></p>
<p><strong>+/-Option</strong> → <a href="lib/GuiControl.htm#Opt">GuiCtrl.Opt("+/-Option")</a></p>
<h3 id="other-changes">Other Changes</h3>
<p>Progress Gui controls no longer have the PBS_SMOOTH style by default, so they are now styled according to the system visual style.</p>
<p>The default margins and control sizes (particularly for Button controls) may differ slightly from v1 when DPI is greater than 100%.</p>
<p>Picture controls no longer delete their current image when they fail to set a new image via <code>GuiCtrl.Value := "new image.png"</code>. However, removing the current image with <code>GuiCtrl.Value := ""</code> is permitted.</p>
<h2 id="error-handling">エラー処理</h2>
<p><a href="lib/OnError.htm">OnError</a> is now called for critical errors prior to exiting the script. Although the script might not be in a state safe for execution, the attempt is made, consistent with OnExit.</p>
<p>Runtime errors no longer set <code>Exception.What</code> to the currently running user-defined function or sub (but this is still done when calling <code>Error()</code> without the second parameter). This gives <code>What</code> a clearer purpose: a function name indicates a failure of that function (not a failure to call the function or evaluate its parameters). <code>What</code> is blank for expression evaluation and control flow errors (some others may also be blank).</p>
<p>Exception objects thrown by runtime errors can now be identified as instances of the new Error class or a more specific subclass. Error objects have a <code>Stack</code> property containing a stack trace. If the <em>What</em> parameter specifies the name of a running function, <em>File</em> and <em>Line</em> are now set based on which line called that function.</p>
<p>Try-catch syntax has changed to allow the script to catch specific error classes, while leaving others uncaught. See <a href="#catch">Catch</a> below for details.</p>
<h3 id="continuable-errors">Continuable Errors</h3>
<p>In most cases, error dialogs now provide the option to continue the current thread (vs. exiting the thread).  COM errors now exit the thread when choosing not to continue (vs. exiting the entire script).</p>
<p>Scripts should not rely on this: If the error was raised by a built-in function, continuing causes it to return "". If the error was raised by the expression evaluator (such as for an invalid dynamic reference or divide by zero), the expression is aborted and yields "" (if used as a control flow statement's parameter).</p>
<p>In some cases the code does not support continuation, and the option to continue should not be shown. The option is also not shown for critical errors, which are designed to terminate the script.</p>
<p><a href="lib/OnError.htm">OnError</a> callbacks now take a second parameter, containing one of the following values:</p>
<ul>
<li>"Return": Returning -1 will continue the thread, while 0 and 1 act as before.</li>
<li>"Exit": Continuation not supported. Returning non-zero stops further processing but still exits the thread.</li>
<li>"ExitApp": This is a critical error. Returning non-zero stops further processing but the script is still terminated.</li>
</ul>
<h3 id="errorlevel">ErrorLevel</h3>
<p>ErrorLevel has been removed. Scripts are often (perhaps usually) written without error-checking, so the policy of setting ErrorLevel for errors often let them go undetected. An immediate error message may seem a bit confrontational, but is generally more helpful.</p>
<p>Where ErrorLevel was previously set to indicate an error condition, an exception is thrown instead, with a (usually) more helpful error message.</p>
<p>Commands such as "Process Exist" which used it to return a value now simply return that value (e.g. <code>pid := ProcessExist()</code>) or something more useful (e.g. <code>hwnd := GroupActivate(group)</code>).</p>
<p>In some cases ErrorLevel was used for a secondary return value.</p>
<ul>
<li><a href="lib/Sort.htm">Sort</a> with the U option no longer returns the number of duplicates removed.</li>
<li><code>Input</code> was removed. It was superseded by InputHook. A few lines of code can make a simple replacement which returns an InputHook object containing the results instead of using ErrorLevel and an OutputVar.</li>
<li><a href="lib/InputBox.htm">InputBox</a> returns an object with <code>result</code> (OK, Cancel or Timeout) and <code>value</code> properties.</li>
</ul>
<p>File functions which previously stored the number of failures in ErrorLevel now throw it in the <code>Extra</code> property of the thrown exception object.</p>
<p><a href="lib/SendMessage.htm">SendMessage</a> timeout is usually an anomolous condition, so causes a <code>TimeoutError</code> to be thrown. <code>TargetError</code> and <code>OSError</code> may be thrown under other conditions.</p>
<p>The <code>UseErrorLevel</code> modes of the <a href="lib/Run.htm">Run</a> and <a href="lib/Hotkey.htm">Hotkey</a> functions were removed.  This mode predates the addition of <code>Try</code>/<code>Catch</code> to the language.  Menu and Gui had this mode as well but were replaced with objects (which do not use ErrorLevel).</p>
<h3 id="expressions-1">式</h3>
<p>A load-time error is raised for more syntax errors than in v1, such as:</p>
<ul>
<li>Empty parentheses (except adjoining a function name); e.g. <code>x ()</code></li>
<li>Prefix operator used on the wrong side or lacking an operand; e.g. <code>x!</code></li>
<li>Binary operator with less than two operands.</li>
<li>Ternary operator with less than three operands.</li>
<li>Target of assignment not a writable variable or property.</li>
</ul>
<p>An exception is thrown when any of the following failures occur (instead of ignoring the failure or producing an empty string):</p>
<ul>
<li>Attempting math on a non-numeric value. (Numeric strings are okay.)</li>
<li>Divide by zero or other invalid/unsupported input, such as <code>(-1)**1.5</code>. Note that some cases are newly detected as invalid, such as <code>0**0</code> and <code>a&lt;&lt;b</code> or <code>a&gt;&gt;b</code> where <code>b</code> is not in the range 0..63.</li>
<li>Failure to allocate memory for a built-in function's return value, concatenation or the expression's result.</li>
<li>Stack underflow (typically caused by a syntax error).</li>
<li>Attempted assignment to something which isn't a variable (or array element).</li>
<li>Attempted assignment to a read-only variable.</li>
<li>Attempted double-deref with an empty name, such as <code>fn(%empty%)</code>.</li>
<li>Failure to execute a dynamic function call or method call.</li>
<li>A method/property invocation fails because the value does not implement that method/property.  (For associative arrays in v1, only a method call can cause this.)</li>
<li>An object-assignment fails due to memory allocation failure.</li>
</ul>
<p>Some of the conditions above are detected in v1, but not mid-expression; for instance, <code>A_AhkPath := x</code> is detected in v1 but <code>y := x, A_AhkPath := x</code> is only detected in v2.</p>
<p>Standalone use of the operators <code>+=</code>, <code>-=</code>, <code>--</code> and <code>++</code> no longer treats an empty variable as 0. This differs from v1, where they treated an empty variable as 0 when used standalone, but not mid-expression or with multi-statement comma.</p>
<h3 id="functions-1">機能紹介</h3>
<p>Functions generally throw an exception on failure. 特に：</p>
<ul>
<li>
<p>Errors due to incorrect use of <a href="lib/DllCall.htm">DllCall</a>, <a href="lib/RegExMatch.htm">RegExMatch</a> and <a href="lib/RegExReplace.htm">RegExReplace</a> were fairly common due to their complexity, and (like many errors) are easier to detect and debug if an error message is shown immediately.</p>
</li>
<li>
<p><a href="lib/Math.htm">Math functions</a> throw an exception if any of their inputs are non-numeric, or if the operation is invalid (such as division by zero).</p>
</li>
<li>
<p>Functions with a <em>WinTitle</em> parameter (with exceptions, such as <a href="lib/WinClose.htm">WinClose</a>'s ahk_group mode) throw if the target window or control is not found.</p>
</li>
</ul>
<p>Exceptions are thrown for some errors that weren't previously detected, and some conditions that were incorrectly marked as errors (previously by setting ErrorLevel) were fixed.</p>
<p>Some error messages have been changed.</p>
<h3 id="catch">Catch</h3>
<p>The syntax for <a href="lib/Catch.htm">Catch</a> has been changed to provide a way to catch specific error classes, while leaving others uncaught (to transfer control to another Catch further up the call stack, or report the error and exit the thread). Previously this required catching thrown values of all types, then checking type and re-throwing. 事例：</p>
<pre><em>; Old (uses obsolete v2.0-a rules for demonstration since v1 had no `is` or Error classes)</em>
try
    SendMessage msg,,, "Control1", "The Window"
catch err
    if err is TimeoutError
        MsgBox "The Window is unresponsive"
    else
        throw err

<em>; New</em>
try
    SendMessage msg,,, "Control1", "The Window"
catch TimeoutError
    MsgBox "The Window is unresponsive"
</pre>
<p>Variations:</p>
<ul>
<li><code>catch</code> catches an Error instance.</li>
<li><code>catch as err</code> catches an Error instance, which is assigned to err.</li>
<li><code>catch ValueError as err</code> catches a ValueError instance, which is assigned to err.</li>
<li><code>catch ValueError, TypeError</code> catches either type.</li>
<li><code>catch ValueError, TypeError as err</code> catches either type and assigns the instance to err.</li>
<li><code>catch Any</code> catches anything.</li>
<li><code>catch (MyError as err)</code> permits parentheses, like most other control flow statements.</li>
</ul>
<p>If <code>try</code> is used without <code>finally</code> or <code>catch</code>, it acts as though it has a <code>catch</code> with an empty block. Although that sounds like v1, now <code>catch</code> on its own only catches instances of <code>Error</code>. In most cases, <code>try</code> on its own is meant to suppress an Error, so no change needs to be made. However, the direct equivalent of v1 <code>try something()</code> in v2 is:</p>
<pre>try something()
catch Any
{}
</pre>
<p>Prioritising the error type over the output variable name might encourage better code; handling the expected error as intended without suppressing or mishandling unexpected errors that should have been reported.</p>
<p>As values of all types can be thrown, any class is valid for the filter (e.g. <code>String</code> or <code>Map</code>). However, the class prototypes are resolved at load time, and must be specified as a full class name and not an arbitrary expression (similar to <code>y</code> in <code>class x extends y</code>).</p>
<p>While a <code>catch</code> statement is executing, <code>throw</code> can be used without parameters to re-throw the exception (avoiding the need to specify an output variable just for that purpose). This is supported even within a nested <code>try</code>...<code>finally</code>, but not within a nested <code>try</code>...<code>catch</code>. The <code>throw</code> does not need to be physically contained by the <code>catch</code> statement's body; it can be used by a called function.</p>
<p>An <code>else</code> can be present after the last <code>catch</code>; this is executed if no exception is thrown within <code>try</code>.</p>
<h2 id="keyboard-mouse-hotkeys-and-hotstrings">Keyboard, Mouse, Hotkeys and Hotstrings</h2>
<p>Fewer VK to SC and SC to VK mappings are hard-coded, in theory improving compatibility with non-conventional custom keyboard layouts.</p>
<p>The key names "Return" and "Break" were removed. Use "Enter" and "Pause" instead.</p>
<p>The presence of <kbd>AltGr</kbd> on each keyboard layout is now always detected by reading the KLLF_ALTGR flag from the keyboard layout DLL. (v1.1.28+ Unicode builds already use this method.) The fallback methods of detecting <kbd>AltGr</kbd> via the keyboard hook have been removed.</p>
<p>Mouse wheel hotkeys set <a href="Variables.htm#EventInfo">A_EventInfo</a> to the wheel delta as reported by the mouse driver instead of dividing by 120. Generally it is a multiple of 120, but some mouse hardware/drivers may report wheel movement at a higher resolution.</p>
<p>Hotstrings now treat <kbd>Shift</kbd>+<kbd>Backspace</kbd> the same as <kbd>Backspace</kbd>, instead of transcribing it to <code>`b</code> within the hotstring buffer.</p>
<p>Hotstrings use the first pair of colons (<code class="no-highlight">::</code>) as a delimiter rather than the last when multiple pairs of colons are present. In other words, colons (when adjacent to another colon) must be escaped in the trigger text in v2, whereas in v1 they must be escaped in the replacement. Note that with an odd number of consecutive colons, the previous    behaviour did not consider the final colon as part of a pair. For example, there is no change in behaviour for <code class="no-highlight">::1:::2</code> (<code class="no-highlight">1</code> → <code class="no-highlight">:2</code>), but <code class="no-highlight">::3::::4</code> is now <code class="no-highlight">3</code> → <code class="no-highlight">::4</code> rather than <code class="no-highlight">3::</code> → <code class="no-highlight">4</code>.</p>
<p>Hotstrings no longer escape colons in pairs, which means it is now possible to escape a single colon at the end of the hotstring trigger. For example, <code class="no-highlight">::5`:::6</code> is now <code class="no-highlight">5:</code> → <code class="no-highlight">6</code> rather than an error, and <code class="no-highlight">::7`::::8</code> is now <code class="no-highlight">7:</code> → <code class="no-highlight">:8</code> rather than <code class="no-highlight">7::</code> → <code class="no-highlight">8</code>. It is best to escape every literal colon in these cases to avoid confusion (but a single isolated colon need not be escaped).</p>
<p>Hotstrings with continuation sections now default to Text mode instead of Raw mode.</p>
<p>Hotkeys now mask the Win/Alt key on release only if it is logically down and the hotkey requires the Win/Alt key (with <code>#</code>/<code>!</code> or a custom prefix). That is, hotkeys which do not require the Win/Alt key no longer mask Win/Alt-up when the Win/Alt key is physically down. This allows hotkeys which send <code>{Blind}{LWin up}</code> to activate the Start menu (which was already possible if using a remapped key such as <code>AppsKey::RWin</code>).</p>
<h2 id="other">Other</h2>
<p>Windows 2000 and Windows XP support has been dropped.</p>
<p>AutoHotkey no longer overrides the system <code>ForegroundLockTimeout</code> setting at startup.</p>
<ul>
<li>This was done by calling <code>SystemParametersInfo</code> with the <code>SPI_SETFOREGROUNDLOCKTIMEOUT</code> action, which affects all applications for the current user session. It does not persist after logout, but was still undesirable to some users.</li>
<li>User bug reports (and simple logic) indicate that if it works, it allows the focus to be stolen by programs which aren't specifically designed to do so.</li>
<li>Some testing on Windows 10 indicated that it had no effect on anything; calls to <code>SetForegroundWindow</code> always failed, and other workarounds employed by WinActivate were needed and effective regardless of timeout. <code>SPI_GETFOREGROUNDLOCKTIMEOUT</code> was used from a separate process to verify that the change took effect (it sometimes doesn't).</li>
<li>It can be replicated in script easily:

<pre>DllCall("SystemParametersInfo", "int", 0x2001, "int", 0, "ptr", 0, "int", 2)</pre>
</li>
</ul>
<p>RegEx newline matching defaults to (*ANYCRLF) and (*BSR_ANYCRLF); `r and `n are recognized in addition to `r`n. The `a option implicitly enables (*BSR_UNICODE).</p>
<p>RegEx callout functions can now be variadic. Callouts specified via a <code>pcre_callout</code> variable can be any callable object, or <code>pcre_callout</code> itself can be directly defined as a function (perhaps a nested function). As the function and variable <a href="#scope">namespaces were merged</a>, a callout pattern such as <code>(?C:fn)</code> can also refer to a local or global variable containing a function object, not just a user-defined function.</p>
<p>Scripts read from stdin (e.g. with <code>AutoHotkey.exe *</code>) no longer include the initial working directory in <a href="Variables.htm#ScriptFullPath">A_ScriptFullPath</a> or the main window's title, but it is used as <a href="Variables.htm#ScriptDir">A_ScriptDir</a> and to locate the local Lib folder.</p>
<p>Settings changed by the auto-execute thread now become the default settings immediately (for threads launched after that point), rather than after 100ms and then again when the auto-execute thread finishes.</p>
<p>The following limits have been removed by utilizing dynamic allocations:</p>
<ul>
<li>Maximum line or continuation section length of 16,383 characters.</li>
<li>Maximum 512 tokens per expression (MAX_TOKENS).<br>

Arrays internal to the expression evaluator which were sized based on MAX_TOKENS are now based on precalculated estimates of the required sizes, so performance should be similar but stack usage is somewhat lower in most cases. This might increase the maximum recursion depth of user-defined functions.</li>
<li>Maximum 512 var or function references per arg (but MAX_TOKENS was more limiting for expressions anyway).</li>
<li>Maximum 255 specified parameter values per function call (but MAX_TOKENS was more limiting anyway).</li>
</ul>
<p><a href="lib/ListVars.htm">ListVars</a> now shows static variables separately to local variables. Global variables declared within the function are also listed as static variables (this is a side-effect of new implementation details, but is kept as it might be useful in scripts with many global variables).</p>
<p>The (undocumented?) "lazy var" optimization was removed to reduce code size and maintenance costs. This optimization improved performance of scripts with more than 100,000 variables.</p>
<p><a href="Program.htm#tray-icon">Tray menu</a>: The word "This" was removed from "Reload This Script" and "Edit This Script", for consistency with "Pause Script" and the main window's menu options.</p>
<p>YYYYMMDDHH24MISS timestamp values are now considered invalid if their length is not an even number between 4 and 14 (inclusive).</p>
<h3 id="persistence">Persistence</h3>
<p>Scripts are "<a href="lib/Persistent.htm">persistent</a>" while at least one of the following conditions is satisfied:</p>
<ul>
<li>At least one hotkey or hotstring has been defined by the script.</li>
<li>At least one <a href="lib/Gui.htm">Gui</a> (or the script's <a href="Program.htm#main-window">main window</a>) is visible.</li>
<li>At least one script <a href="lib/SetTimer.htm">timer</a> is currently enabled.</li>
<li>At least one <a href="lib/OnClipboardChange.htm">OnClipboardChange</a> callback function has been set.</li>
<li>At least one <a href="lib/InputHook.htm">InputHook</a> is active.</li>
<li><code>Persistent()</code> or <code>Persistent(true)</code> was called and not reversed by calling <code>Persistent(false)</code>.</li>
</ul>
<p>If one of the following occurs and none of the above conditions are satisfied, the script terminates.</p>
<ul>
<li>The last script thread finishes.</li>
<li>A <a href="lib/Gui.htm">Gui</a> is closed or destroyed.</li>
<li>The script's <a href="Program.htm#main-window">main window</a> is closed (but destroying it causes the script to exit regardless of persistence, as before).</li>
<li>An <a href="lib/InputHook.htm">InputHook</a> with no <a href="lib/InputHook.htm#OnEnd">OnEnd</a> callback ends.</li>
</ul>
<p>For flexibility, <a href="lib/OnMessage.htm">OnMessage</a> does not make the script automatically persistent.</p>
<p>By contrast, v1 scripts are "persistent" when at least one of the following is true:</p>
<ul>
<li>At least one hotkey or hotstring has been defined by the script.</li>
<li>Gui or OnMessage() appears anywhere in the script.</li>
<li>The keyboard hook or mouse hook is installed.</li>
<li>Input has been called.</li>
<li>#Persistent was used.</li>
</ul>
<h3 id="threads">Threads</h3>
<p><a href="misc/Threads.htm">Threads</a> start out with an uninterruptible timeout of 17ms instead of 15ms. 15 was too low since the system tick count updates in steps of 15 or 16 minimum; i.e. if the tick count updated at exactly the wrong moment, the thread could become interruptible even though virtually no time had passed.</p>
<p>Threads which start out uninterruptible now remain so until at least one line has executed, even if the uninterruptible timeout expires first (such as if the system suspends the process immediately after the thread starts in order to give CPU time to another process).</p>
<p><a href="lib/_MaxThreads.htm">#MaxThreads</a> and <a href="lib/_MaxThreadsPerHotkey.htm">#MaxThreadsPerHotkey</a> no longer make exceptions for any subroutine whose first line is one of the following functions: <a href="lib/ExitApp.htm">ExitApp</a>, <a href="lib/Pause.htm">Pause</a>, <a href="lib/Edit.htm">Edit</a>, <a href="lib/Reload.htm">Reload</a>, <a href="lib/KeyHistory.htm">KeyHistory</a>, <a href="lib/ListLines.htm">ListLines</a>, <a href="lib/ListVars.htm">ListVars</a>, or <a href="lib/ListHotkeys.htm">ListHotkeys</a>.</p>
<h3 id="default-settings">Default Settings</h3>
<ul>
<li id="NoEnv">#NoEnv is the default behaviour, so the directive itself has been removed. Use <a href="lib/EnvGet.htm">EnvGet</a> instead if an equivalent built-in variable is not available.</li>
<li><a href="lib/SendMode.htm">SendMode</a> defaults to Input instead of Event.</li>
<li><a href="lib/SetTitleMatchMode.htm">Title matching mode</a> defaults to 2 instead of 1.</li>
<li id="SetBatchLines">SetBatchLines has been removed, so all scripts run at full speed (equivalent to SetBatchLines -1 in v1).</li>
<li>The working directory defaults to <a href="Variables.htm#ScriptDir">A_ScriptDir</a>. <a href="Variables.htm#InitialWorkingDir">A_InitialWorkingDir</a> contains the working directory which was set by the process which launched AutoHotkey.</li>
<li><a href="lib/_SingleInstance.htm">#SingleInstance</a> prompt behaviour is default for all scripts; #SingleInstance on its own activates Force mode. <code>#SingleInstance Prompt</code> can also be used explicitly, for clarity or to override a previous directive.</li>
<li><a href="lib/CoordMode.htm">CoordMode</a> defaults to Client (added in v1.1.05) instead of Window.</li>
<li>The default codepage for script files (but not files read <em>by</em> the script) is now UTF-8 instead of ANSI (CP0). This can be overridden with the /CP command line switch, as before.</li>
<li id="MaxMem">#MaxMem was removed, and no artificial limit is placed on variable capacity.</li>
</ul>
<h3 id="command-line">Command Line</h3>
<p>Command-line args are no longer stored in a pseudo-array of numbered global vars; the global variable <a href="Variables.htm#Args">A_Args</a> (added in v1.1.27) should be used instead.</p>
<p>The /R and /F switches were removed. Use /restart and /force instead.</p>
<p>/validate should be used in place of /iLib when AutoHotkey.exe is being used to check a script for syntax errors, as the function library auto-include mechanism was removed.</p>
<p>/ErrorStdOut is now treated as one of the script's parameters, not built-in, in either of the following cases:</p>
<ul>
<li>When the script is compiled, unless /script is used.</li>
<li>When it has a suffix not beginning with <code>=</code> (where previously the suffix was ignored).</li>
</ul>

</body>
</html>
