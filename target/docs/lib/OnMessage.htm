<!DOCTYPE HTML>
<html lang="ja">
<head>
<title>OnMessage - 構文と使用法｜AutoHotkey v2</title>
<meta name="description" content="OnMessage関数は、スクリプトが指定されたメッセージを受信するたびに、指定された関数が自動的に呼び出されるようにします。" />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>OnMessage</h1>

<p>スクリプトが指定されたメッセージを受信するたびに、指定された関数が自動的に呼び出されるようにします。</p>

<pre class="Syntax"><span class="func">OnMessage</span> MsgNumber, Function <span class="optional">, MaxThreads</span></pre>
<h2 id="Parameters">パラメータ</h2>
<dl>

  <dt>MsgNumber</dt>
  <dd>
    <p>型：<a href="../Concepts.htm#numbers">整数</a></p>
    <p>監視または問い合わせるメッセージの番号で、0から4294967295（0xFFFFFFF）の間でなければなりません。<a href="../misc/SendMessageList.htm">システムメッセージ</a>（つまり0x0400以下のもの）を監視したくない場合は、選択の余地がある範囲で4096（0x1000）より大きい数字を選ぶとよいでしょう。これにより、AutoHotkeyの現在および将来のバージョンで内部的に使用されるメッセージに干渉する可能性を低減することができます。</p>
  </dd>

  <dt>機能</dt>
  <dd>
    <p>型：<a href="../misc/Functor.htm">機能オブジェクト</a></p>
    <p>メッセージを受信したときに呼び出す関数オブジェクトです。この関数のパラメータと戻り値について、<a href="#The_Functions_Parameters">以下</a>に説明します。</p>
  </dd>

  <dt id="MaxThreads">MaxThreads</dt>
  <dd>
    <p>型：<a href="../Concepts.htm#numbers">整数</a></p>
    <p>この整数は通常省略され、その場合、モニター機能は一度に1<a href="../misc/Threads.htm">スレッド</a>に制限されます。そうしないと、モニタ関数が割り込むたびに、スクリプトがメッセージを時系列に並べずに処理してしまうため、通常はこれが最適です。そのため、<em>MaxThreads</em>の代替として、<a href="#Critical">以下</a>のように<em>Critical</em>を使用することを検討します。</p>
    <p>モニタ関数が直接または間接的に、その関数の実行中にメッセージを再送信させる場合、（必要であれば）新しいメッセージに対してモニタ関数が呼び出されるように、1より大きいか-1より小さい<em>MaxThreads</em>値を指定することが必要です。スクリプトの自プロセスが自分自身に送信する（投稿しない）メッセージは、遅延やバッファリングができません。</p>
    <p>0を指定すると、<em>Function</em>で指定された登録済みの機能を解除することができます。</p>
    <p>デフォルトでは、1つの<em>MsgNumber</em>に対して複数の関数が登録されている場合、登録された順番に呼び出されます。先に登録された関数よりも先に呼び出されるように関数を登録する場合は、<em>MaxThreads</em>に負の値を指定します。例えば、<code>OnMessage Msg, Fn, -2</code>は、<em>Msg</em>にあらかじめ登録されている他の関数の前に<code>Fn</code>を呼び出すように登録し、<em>Fn</em>には最大2スレッドを許可します。ただし、すでに機能が登録されている場合は、一度登録を解除し、再度登録しない限り、順番は変わりません。</p>
  </dd>

</dl>

<h2 id="Usage">使用方法</h2>

<p>任意の数の関数または<a href="../misc/Functor.htm">関数オブジェクト</a>が、与えられた<em>MsgNumber</em>を監視することができます。</p>
<p>この2行のどちらかで、先に登録された関数の<strong>後</strong>に呼び出される関数オブジェクトを登録することができます：</p>
<pre>OnMessage MsgNumber, Function     <em>; Option 1 - omit MaxThreads</em>
OnMessage MsgNumber, Function, 1  <em>; Option 2 - specify MaxThreads 1</em></pre>
<p>先に登録されている関数の<strong>前</strong>に呼び出される関数オブジェクトを登録します：</p>
<pre>OnMessage MsgNumber, Function, -1</pre>
<p>関数オブジェクトの登録を解除するには、<em>MaxThreads</em>に0を指定します：</p>
<pre>OnMessage MsgNumber, Function, 0</pre>

<h2 id="The_Functions_Parameters">関数のパラメータ</h2>
<p>1つまたは複数のメッセージを監視するために割り当てられた<a href="../Functions.htm">関数</a>は、4つのパラメータを受け入れる必要があります：</p>
<pre class="Syntax"><i>FunctionName</i>(wParam, lParam, msg, hwnd)</pre>
<p>パラメータに付ける名前は問いませんが、以下の情報が順次割り当てられます：</p>
<ul>
  <li>Parameter #1:メッセージのWPARAMの値です。</li>
  <li>Parameter #2:メッセージのLPARAM値です。</li>
  <li>Parameter #3:メッセージ番号。ある機能が複数のメッセージを監視している場合に便利です。</li>
  <li>Parameter #4:メッセージの送信先のウィンドウまたはコントロールのHWND（ユニークID）です。HWNDは、<a href="../misc/WinTitle.htm#ahk_id">WinTitleパラメータ</a>で直接使用することができます。</li>
</ul>
<p>WPARAMとLPARAMは、スクリプトを実行するexeが32ビットか64ビットかに応じて、符号なし32ビット整数（0から2<sup>32</sup>-1）または符号付き64ビット整数<sup>（-2</sup>63から2<sup>63</sup>-1）です。32ビットスクリプトの場合、入力されるパラメータが符号付き整数であることを意図している場合、この例に従って負の数を明らかにすることができます：</p>
<pre>if (A_PtrSize = 4 &amp;&amp; wParam &gt; 0x7FFFFFFF)  <em>; Checking <a href="../Variables.htm#PtrSize">A_PtrSize</a> ensures the script is 32-bit.</em>
    wParam := -(~wParam) - 1</pre>
<p>対応する情報が不要な場合、リストの最後から1つ以上のパラメータを省略することができますが、この場合、最後のパラメータとしてアスタリスクを指定する必要があります。例えば、<code>MyMsgMonitor(wParam, lParam, *)</code>と定義された関数は最初の2つのパラメータのみを受け取り、<code>MyMsgMonitor(*)</code>と定義された関数は何も受け取らないことになります。</p>

<h2 id="Additional_Information_Available_to_the_Function">機能で利用できる追加情報</h2>
<p>上記で受け取ったパラメータに加えて、この関数は組み込み変数<a href="../Variables.htm#EventInfo">A_EventInfo</a>を参照することができ、SendMessageでメッセージが送信された場合は0が格納されます。PostMessageで送信された場合、メッセージが投稿された<a href="../Variables.htm#TickCount">tick-count の時間</a>が含まれます。</p>
<p>モニター機能で<a href="../misc/WinTitle.htm#LastFoundWindow">最後に見つかったウィンドウ</a>は、メッセージが送信された親ウィンドウとして始まります（コントロールに送信された場合も同様です）。ウィンドウが隠れていてもGUIウィンドウ（スクリプトのメインウィンドウなど）でない場合は、<a href="DetectHiddenWindows.htm">DetectHiddenWindows</a>をオンにしてから使用します。例えば：</p>
<pre>DetectHiddenWindows True
MsgParentWindow := WinExist()  <em>; This stores the unique ID of the window to which the message was sent.</em></pre>

<h2 id="What_the_Function_Should_Return">関数が<em>返すべき</em>もの</h2>
<p>モニター関数がパラメータなしで<a href="Return.htm">Return</a>を使用するか、""などの空白の値を指定する（または Return を全く使用しない）場合、受信したメッセージは関数が終了したときに通常通り処理されます。関数が<a href="Exit.htm">Exit</a>したり、存在しないファイルを<a href="Run.htm">実行</a>するなどのランタイムエラーが発生した場合も同様です。これに対して、整数を返すと、返信としてすぐに送信されます。つまり、プログラムはそれ以上メッセージを処理しません。例えば、WM_LBUTTONDOWN (0x0201) を監視する関数は、マウスクリックが発生したことをターゲットウィンドウに通知しないように、整数を返すことができる。多くの場合（<a href="PostMessage.htm">PostMessage</a>で届いたメッセージなど）、どの整数を返すかは問題ではありませんが、疑わしい場合は通常0が最も安全です。</p>
<p>有効な戻り値の範囲は、スクリプトを実行するexeが32ビットか64ビットかによって異なります。空でない戻り値は、32ビットスクリプトでは -2<sup>31</sup> から 2<sup>32</sup>-1 (<code><a href="../Variables.htm#PtrSize">A_PtrSize</a> = 4</code>) 、64ビットスクリプトでは -2<sup>63</sup> から 2<sup>63</sup>-1 (<code><a href="../Variables.htm#PtrSize">A_PtrSize</a> = 8</code>) でなければなりません。</p>
<p>与えられたメッセージ番号を監視する関数が複数ある場合は、1つが空でない値を返すまで、1つずつ呼び出されます。</p>

<h2 id="Remarks">総論</h2>
<p>通常の関数呼び出しとは異なり、監視メッセージの到着は、新しい<a href="../misc/Threads.htm">スレッド</a>として関数を呼び出します。このため、<a href="SendMode.htm">SendMode</a>や <a href="DetectHiddenWindows.htm">DetectHiddenWindows</a>などの設定値はデフォルトのまま、関数は新たにスタートします。これらのデフォルトは、<a href="../Scripts.htm#auto">スクリプト起動</a>時に変更することができます。</p>
<p>コントロールに送信されたメッセージは（投稿されるのではなく）、システムが裏でコントロールに直接ルーティングするため、監視されることはありません。システムで生成されたメッセージは、そのほとんどが投稿されるため、これが問題になることはほとんどありません。</p>
<p>スクリプトがアイドル状態で実行され続け、メッセージの着信を監視することを意図している場合、スクリプトの終了を防ぐために<a href="Persistent.htm">Persistent</a>関数を呼び出す必要がある場合があります。OnMessage は、スクリプトを自動的に永続化するわけではありません。例えば、OnMessageを使用してGUIウィンドウへの入力を監視する場合（<a href="#ExLButtonDown">WM_LBUTTONDOWNの例</a>など）、最後のGUIウィンドウが閉じられたときにスクリプトが自動的に終了するようにする方が適切な場合があります。</p>
<p id="Critical">以前に同じメッセージが到着したために、その関数がまだ実行されている間にメッセージが到着した場合、デフォルトでは、その関数は再び呼び出されず、代わりに、メッセージは監視されていないものとして扱われます。もしこれが望ましくないのであれば、それを回避する方法は複数あります：</p>
<ul>
  <li>メッセージが送信ではなく投稿であり、0x0311より大きい番号を持つ場合、関数の最初の行に<a href="Critical.htm">Critical</a>を指定することで、その関数が完了するまでバッファリングすることができます。また、<a href="Thread.htm">スレッドインタラプト</a>は、関数が終了するまでの時間が長ければ、同じ効果を得ることができます。</li>
  <li><a href="Critical.htm">Critical</a>を使用して<a href="Critical.htm#Interval">メッセージチェックの間隔を</a>長くすると、メッセージが送信される前に機能が完了する時間が長くなります。信頼性のために16以上の間隔が必要な場合があります。システムタイマーの粒度（通常は15.6ミリ秒）により、非クリティカルスレッドのデフォルト間隔（5ミリ秒）は、関数が開始した瞬間に経過しているように見えるかもしれません。</li>
  <li>モニター関数が素早く戻るようにすることで、<em>MaxThreads</em>のためにメッセージが見逃されるリスクを減らすことができます。One way to do this is to have it queue up a future thread by <a href="PostMessage.htm">posting</a> to its own script a monitored message number greater than 0x0311. That message's function should use <a href="Critical.htm">Critical</a> as its first line to ensure that its messages are buffered. Alternatively, a <a href="SetTimer.htm">timer</a> can be used to queue up a future thread.</li>
  <li>Specifying a higher value for the <a href="#MaxThreads">MaxThreads</a> parameter allows the function to be interrupted to process the newly-received message.</li>
</ul>
<p id="buffering">If a monitored message that is numerically greater than 0x0311 is posted while the script is <a href="../misc/Threads.htm#Interrupt">uninterruptible</a>, the message is buffered; that is, its function is not called until the script becomes interruptible. However, messages which are sent rather than posted cannot be buffered as they must provide a return value. Posted messages also might not be buffered when a modal message loop is running, such as for a system dialog, ListView drag-drop operation or menu.</p>
<p>If a monitored message arrives and is not buffered, its function is called immediately even if the thread is <a href="../misc/Threads.htm#Interrupt">uninterruptible</a> when the message is received.</p>
<p>The <a href="../misc/Threads.htm">priority</a> of OnMessage threads is always 0. Consequently, no messages are monitored or buffered when the current thread's priority is higher than 0.</p>
<p>Caution should be used when monitoring system messages (those below 0x0400). For example, if a monitor function does not finish quickly, the response to the message might take longer than the system expects, which might cause side-effects. Unwanted behavior may also occur if a monitor function returns an integer to suppress further processing of a message, but the system expected different processing or a different response.</p>
<p>When the script is displaying a system dialog such as <a href="MsgBox.htm">MsgBox</a>, any message posted to a control is not monitored. For example, if the script is displaying a message box and the user clicks a button in a GUI window, the WM_LBUTTONDOWN message is sent directly to the button without calling the monitor function.</p>
<p>Although an external program may post messages directly to a script's thread via PostThreadMessage() or other API call, this is not recommended because the messages would be lost if the script is displaying a system window such as a <a href="MsgBox.htm">message box</a>. Instead, it is usually best to post or send the messages to the script's main window or one of its GUI windows.</p>
<h2 id="Related">関連</h2>
<p><a href="CallbackCreate.htm">CallbackCreate</a>, <a href="OnExit.htm">OnExit</a>, <a href="OnClipboardChange.htm">OnClipboardChange</a>, <a href="PostMessage.htm">PostMessage</a>, <a href="SendMessage.htm">SendMessage</a>, <a href="../Functions.htm">Functions</a>, <a href="../misc/SendMessageList.htm">List of Windows Messages</a>, <a href="../misc/Threads.htm">Threads</a>, <a href="Critical.htm">Critical</a>, <a href="DllCall.htm">DllCall</a></p>
<h2 id="Examples">例</h2>
<div class="ex" id="ExLButtonDown">
<p><a class="ex_number" href="#ExLButtonDown"></a> Monitors mouse clicks in a GUI window. 関連トピック<a href="GuiOnEvent.htm#ContextMenu">ContextMenu</a> event</p>
<pre>MyGui := Gui(, "Example Window")
MyGui.Add("Text",, "Click anywhere in this window.")
MyGui.Add("Edit", "w200")
MyGui.Show
OnMessage 0x0201, WM_LBUTTONDOWN

WM_LBUTTONDOWN(wParam, lParam, msg, hwnd)
{
    X := lParam &amp; 0xFFFF
    Y := lParam &gt;&gt; 16
    Control := ""
    thisGui := GuiFromHwnd(hwnd)
    thisGuiControl := GuiCtrlFromHwnd(hwnd)
    if thisGuiControl
    {
        thisGui := thisGuiControl.Gui
        Control := "`n(in control " . thisGuiControl.ClassNN . ")"
    }
    ToolTip "You left-clicked in Gui window '" thisGui.Title "' at client coordinates " X "x" Y "." Control
}</pre>
</div>

<div class="ex" id="ExShutdown">
<p><a class="ex_number" href="#ExShutdown"></a> Detects system shutdown/logoff and allows the user to abort it. On Windows Vista and later, the system displays a user interface showing which program is blocking shutdown/logoff and allowing the user to force shutdown/logoff. On older OSes, the script displays a confirmation prompt. 関連トピック<a href="OnExit.htm">OnExit</a></p>
<pre><em>; The following DllCall is optional: it tells the OS to shut down this script first (prior to all other applications).</em>
DllCall("kernel32.dll\SetProcessShutdownParameters", "UInt", 0x4FF, "UInt", 0)
OnMessage(0x0011, On_WM_QUERYENDSESSION)
Persistent

On_WM_QUERYENDSESSION(wParam, lParam, *)
{
    ENDSESSION_LOGOFF := 0x80000000
    if (lParam &amp; ENDSESSION_LOGOFF)  <em>; User is logging off.</em>
        EventType := "Logoff"
    else  <em>; System is either shutting down or restarting.</em>
        EventType := "Shutdown"
    try
    {
        <em>; Set a prompt for the OS shutdown UI to display.  We do not display
        ; our own confirmation prompt because we have only 5 seconds before
        ; the OS displays the shutdown UI anyway.  Also, a program without
        ; a visible window cannot block shutdown without providing a reason.</em>
        BlockShutdown("Example script attempting to prevent " EventType ".")
        return false
    }
    catch
    {
        <em>; ShutdownBlockReasonCreate is not available, so this is probably
        ; Windows XP, 2003 or 2000, where we can actually prevent shutdown.</em>
        Result := MsgBox(EventType " in progress. Allow it?",, "YN")
        if (Result = "Yes")
            return true  <em>; Tell the OS to allow the shutdown/logoff to continue.</em>
        else
            return false  <em>; Tell the OS to abort the shutdown/logoff.</em>
    }
}

BlockShutdown(Reason)
{
    <em>; If your script has a visible GUI, use it instead of A_ScriptHwnd.</em>
    DllCall("ShutdownBlockReasonCreate", "ptr", A_ScriptHwnd, "wstr", Reason)
    OnExit StopBlockingShutdown
}

StopBlockingShutdown(*)
{
    OnExit StopBlockingShutdown, 0
    DllCall("ShutdownBlockReasonDestroy", "ptr", A_ScriptHwnd)
}</pre>
</div>

<div class="ex" id="ExCustom">
<p><a class="ex_number" href="#ExCustom"></a> Receives a custom message and up to two numbers from some other script or program (to send strings rather than numbers, see the example after this one).</p>
<pre>OnMessage 0x5555, MsgMonitor
Persistent

MsgMonitor(wParam, lParam, msg, *)
{
    <em>; Since returning quickly is often important, it is better to use ToolTip than</em>
    <em>; something like MsgBox that would prevent the function from finishing:</em>
    ToolTip "Message " msg " arrived:`nWPARAM:" wParam "`nLPARAM:" lParam
}

<em>; The following could be used inside some other script to run the function inside the above script:</em>
SetTitleMatchMode 2
DetectHiddenWindows True
if WinExist("Name of Receiving Script.ahk ahk_class AutoHotkey")
    PostMessage 0x5555, 11, 22  <em>; The message is sent  to the "<a href="../misc/WinTitle.htm#LastFoundWindow">last found window</a>" due to WinExist above.</em>
DetectHiddenWindows False  <em>; Must not be turned off until after PostMessage.</em></pre>
</div>

<div class="ex" id="ExSendString">
<p><a class="ex_number" href="#ExSendString"></a> Sends a string of any length from one script to another. To use this, save and run both of the following scripts then press <kbd>Win</kbd>+<kbd>Space</kbd> to show an input box that will prompt you to type in a string. Both scripts must use the same <a href="../Concepts.htm#native-encoding">native encoding</a>.</p>
<p>Save the following script as <strong>Receiver.ahk</strong> then launch it.</p>
<pre filename="Receiver.ahk">#SingleInstance
OnMessage 0x004A, Receive_WM_COPYDATA  <em>; 0x004A is WM_COPYDATA</em>
Persistent

Receive_WM_COPYDATA(wParam, lParam, msg, hwnd)
{
    StringAddress := NumGet(lParam, 2*A_PtrSize, "Ptr")  <em>; Retrieves the CopyDataStruct's lpData member.</em>
    CopyOfData := StrGet(StringAddress)  <em>; Copy the string out of the structure.</em>
    <em>; Show it with ToolTip vs. MsgBox so we can return in a timely fashion:</em>
    ToolTip A_ScriptName "`nReceived the following string:`n" CopyOfData
    return true  <em>; Returning 1 (true) is the traditional way to acknowledge this message.</em>
}</pre>
<p>Save the following script as <strong>Sender.ahk</strong> then launch it. After that, press the <kbd>Win</kbd>+<kbd>Space</kbd> hotkey.</p>
<pre filename="Sender.ahk">TargetScriptTitle := "Receiver.ahk ahk_class AutoHotkey"

#space::  <em>; Win+Space hotkey. Press it to show an input box for entry of a message string.</em>
{
    ib := InputBox("Enter some text to Send:", "Send text via WM_COPYDATA")
    if ib.Result = "Cancel"  <em>; User pressed the Cancel button.</em>
        return
    result := Send_WM_COPYDATA(ib.Value, TargetScriptTitle)
    if result = ""
        MsgBox "SendMessage failed or timed out. Does the following WinTitle exist?:`n" TargetScriptTitle
    else if (result = 0)
        MsgBox "Message sent but the target window responded with 0, which may mean it ignored it."
}

Send_WM_COPYDATA(StringToSend, TargetScriptTitle)
<em>; This function sends the specified string to the specified window and returns the reply.
; The reply is 1 if the target window processed the message, or 0 if it ignored it.</em>
{
    CopyDataStruct := Buffer(3*A_PtrSize)  <em>; Set up the structure's memory area.</em>
    <em>; First set the structure's cbData member to the size of the string, including its zero terminator:</em>
    SizeInBytes := (StrLen(StringToSend) + 1) * 2
    NumPut( "Ptr", SizeInBytes  <em>; OS requires that this be done.</em>
          , "Ptr", StrPtr(StringToSend)  <em>; Set lpData to point to the string itself.</em>
          , CopyDataStruct, A_PtrSize)
    Prev_DetectHiddenWindows := A_DetectHiddenWindows
    Prev_TitleMatchMode := A_TitleMatchMode
    DetectHiddenWindows True
    SetTitleMatchMode 2
    TimeOutTime := 4000  <em>; Optional. Milliseconds to wait for response from receiver.ahk. Default is 5000
    ; Must use SendMessage not PostMessage.</em>
    RetValue := SendMessage(0x004A, 0, CopyDataStruct,, TargetScriptTitle,,,, TimeOutTime) <em>; 0x004A is WM_COPYDATA.</em>
    DetectHiddenWindows Prev_DetectHiddenWindows  <em>; Restore original setting for the caller.</em>
    SetTitleMatchMode Prev_TitleMatchMode         <em>; Same.</em>
    return RetValue  <em>; Return SendMessage's reply back to our caller.</em>
}</pre>
</div>

<p>See the <a href="../scripts/index.htm#WinLIRC">WinLIRC client script</a> for a demonstration of how to use OnMessage to receive a notification when data has arrived on a network connection.</p>

</body>
</html>
