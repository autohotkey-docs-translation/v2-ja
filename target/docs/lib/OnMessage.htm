<!DOCTYPE HTML>
<html lang="ja">
<head>
<title>OnMessage - 構文と使用法｜AutoHotkey v2</title>
<meta name="description" content="OnMessage関数は、スクリプトが指定されたメッセージを受信するたびに、指定された関数が自動的に呼び出されるようにします。" />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>OnMessage</h1>

<p>スクリプトが指定されたメッセージを受信するたびに、指定された関数が自動的に呼び出されるようにします。</p>

<pre class="Syntax"><span class="func">OnMessage</span> MsgNumber, Function <span class="optional">, MaxThreads</span></pre>
<h2 id="Parameters">パラメータ</h2>
<dl>

  <dt>MsgNumber</dt>
  <dd>
    <p>型：<a href="../Concepts.htm#numbers">整数</a></p>
    <p>監視または問い合わせるメッセージの番号で、0から4294967295（0xFFFFFFF）の間でなければなりません。<a href="../misc/SendMessageList.htm">システムメッセージ</a>（つまり0x0400以下のもの）を監視したくない場合は、選択の余地がある範囲で4096（0x1000）より大きい数字を選ぶとよいでしょう。これにより、AutoHotkeyの現在および将来のバージョンで内部的に使用されるメッセージに干渉する可能性を低減することができます。</p>
  </dd>

  <dt>機能</dt>
  <dd>
    <p>型：<a href="../misc/Functor.htm">機能オブジェクト</a></p>
    <p>メッセージを受信したときに呼び出す関数オブジェクトです。この関数のパラメータと戻り値について、<a href="#The_Functions_Parameters">以下</a>に説明します。</p>
  </dd>

  <dt id="MaxThreads">MaxThreads</dt>
  <dd>
    <p>型：<a href="../Concepts.htm#numbers">整数</a></p>
    <p>この整数は通常省略され、その場合、モニター機能は一度に1<a href="../misc/Threads.htm">スレッド</a>に制限されます。そうしないと、モニタ関数が割り込むたびに、スクリプトがメッセージを時系列に並べずに処理してしまうため、通常はこれが最適です。そのため、<em>MaxThreads</em>の代替として、<a href="#Critical">以下</a>のように<em>Critical</em>を使用することを検討します。</p>
    <p>モニタ関数が直接または間接的に、その関数の実行中にメッセージを再送信させる場合、（必要であれば）新しいメッセージに対してモニタ関数が呼び出されるように、1より大きいか-1より小さい<em>MaxThreads</em>値を指定することが必要です。スクリプトの自プロセスが自分自身に送信する（投稿しない）メッセージは、遅延やバッファリングができません。</p>
    <p>0を指定すると、<em>Function</em>で指定された登録済みの機能を解除することができます。</p>
    <p>デフォルトでは、1つの<em>MsgNumber</em>に対して複数の関数が登録されている場合、登録された順番に呼び出されます。先に登録された関数よりも先に呼び出されるように関数を登録する場合は、<em>MaxThreads</em>に負の値を指定します。例えば、<code>OnMessage Msg, Fn, -2</code>は、<em>Msg</em>にあらかじめ登録されている他の関数の前に<code>Fn</code>を呼び出すように登録し、<em>Fn</em>には最大2スレッドを許可します。ただし、すでに機能が登録されている場合は、一度登録を解除し、再度登録しない限り、順番は変わりません。</p>
  </dd>

</dl>

<h2 id="Usage">使用方法</h2>

<p>任意の数の関数または<a href="../misc/Functor.htm">関数オブジェクト</a>が、与えられた<em>MsgNumber</em>を監視することができます。</p>
<p>この2行のどちらかで、先に登録された関数の<strong>後</strong>に呼び出される関数オブジェクトを登録することができます：</p>
<pre>OnMessage MsgNumber, Function     <em>; Option 1 - omit MaxThreads</em>
OnMessage MsgNumber, Function, 1  <em>; Option 2 - specify MaxThreads 1</em></pre>
<p>先に登録されている関数の<strong>前</strong>に呼び出される関数オブジェクトを登録します：</p>
<pre>OnMessage MsgNumber, Function, -1</pre>
<p>関数オブジェクトの登録を解除するには、<em>MaxThreads</em>に0を指定します：</p>
<pre>OnMessage MsgNumber, Function, 0</pre>

<h2 id="The_Functions_Parameters">関数のパラメータ</h2>
<p>1つまたは複数のメッセージを監視するために割り当てられた<a href="../Functions.htm">関数</a>は、4つのパラメータを受け入れる必要があります：</p>
<pre class="Syntax"><i>FunctionName</i>(wParam, lParam, msg, hwnd)</pre>
<p>パラメータに付ける名前は問いませんが、以下の情報が順次割り当てられます：</p>
<ul>
  <li>Parameter #1:メッセージのWPARAMの値です。</li>
  <li>Parameter #2:メッセージのLPARAM値です。</li>
  <li>Parameter #3:メッセージ番号。ある機能が複数のメッセージを監視している場合に便利です。</li>
  <li>Parameter #4:メッセージの送信先のウィンドウまたはコントロールのHWND（ユニークID）です。HWNDは、<a href="../misc/WinTitle.htm#ahk_id">WinTitleパラメータ</a>で直接使用することができます。</li>
</ul>
<p>WPARAMとLPARAMは、スクリプトを実行するexeが32ビットか64ビットかに応じて、符号なし32ビット整数（0から2<sup>32</sup>-1）または符号付き64ビット整数<sup>（-2</sup>63から2<sup>63</sup>-1）です。32ビットスクリプトの場合、入力されるパラメータが符号付き整数であることを意図している場合、この例に従って負の数を明らかにすることができます：</p>
<pre>if (A_PtrSize = 4 &amp;&amp; wParam &gt; 0x7FFFFFFF)  <em>; Checking <a href="../Variables.htm#PtrSize">A_PtrSize</a> ensures the script is 32-bit.</em>
    wParam := -(~wParam) - 1</pre>
<p>対応する情報が不要な場合、リストの最後から1つ以上のパラメータを省略することができますが、この場合、最後のパラメータとしてアスタリスクを指定する必要があります。例えば、<code>MyMsgMonitor(wParam, lParam, *)</code>と定義された関数は最初の2つのパラメータのみを受け取り、<code>MyMsgMonitor(*)</code>と定義された関数は何も受け取らないことになります。</p>

<h2 id="Additional_Information_Available_to_the_Function">機能で利用できる追加情報</h2>
<p>上記で受け取ったパラメータに加えて、この関数は組み込み変数<a href="../Variables.htm#EventInfo">A_EventInfo</a>を参照することができ、SendMessageでメッセージが送信された場合は0が格納されます。PostMessageで送信された場合、メッセージが投稿された<a href="../Variables.htm#TickCount">tick-count の時間</a>が含まれます。</p>
<p>モニター機能で<a href="../misc/WinTitle.htm#LastFoundWindow">最後に見つかったウィンドウ</a>は、メッセージが送信された親ウィンドウとして始まります（コントロールに送信された場合も同様です）。ウィンドウが隠れていてもGUIウィンドウ（スクリプトのメインウィンドウなど）でない場合は、<a href="DetectHiddenWindows.htm">DetectHiddenWindows</a>をオンにしてから使用します。事例：</p>
<pre>DetectHiddenWindows True
MsgParentWindow := WinExist()  <em>; This stores the unique ID of the window to which the message was sent.</em></pre>

<h2 id="What_the_Function_Should_Return">関数が<em>返すべき</em>もの</h2>
<p>モニター関数がパラメータなしで<a href="Return.htm">Return</a>を使用するか、""などの空白の値を指定する（または Return を全く使用しない）場合、受信したメッセージは関数が終了したときに通常通り処理されます。関数が<a href="Exit.htm">Exit</a>したり、存在しないファイルを<a href="Run.htm">実行</a>するなどのランタイムエラーが発生した場合も同様です。これに対して、整数を返すと、返信としてすぐに送信されます。つまり、プログラムはそれ以上メッセージを処理しません。例えば、WM_LBUTTONDOWN (0x0201) を監視する関数は、マウスクリックが発生したことをターゲットウィンドウに通知しないように、整数を返すことができる。多くの場合（<a href="PostMessage.htm">PostMessage</a>で届いたメッセージなど）、どの整数を返すかは問題ではありませんが、疑わしい場合は通常0が最も安全です。</p>
<p>有効な戻り値の範囲は、スクリプトを実行するexeが32ビットか64ビットかによって異なります。空でない戻り値は、32ビットスクリプトでは -2<sup>31</sup> から 2<sup>32</sup>-1 (<code><a href="../Variables.htm#PtrSize">A_PtrSize</a> = 4</code>) 、64ビットスクリプトでは -2<sup>63</sup> から 2<sup>63</sup>-1 (<code><a href="../Variables.htm#PtrSize">A_PtrSize</a> = 8</code>) でなければなりません。</p>
<p>与えられたメッセージ番号を監視する関数が複数ある場合は、1つが空でない値を返すまで、1つずつ呼び出されます。</p>

<h2 id="Remarks">総論</h2>
<p>通常の関数呼び出しとは異なり、監視メッセージの到着は、新しい<a href="../misc/Threads.htm">スレッド</a>として関数を呼び出します。このため、<a href="SendMode.htm">SendMode</a>や <a href="DetectHiddenWindows.htm">DetectHiddenWindows</a>などの設定値はデフォルトのまま、関数は新たにスタートします。これらのデフォルトは、<a href="../Scripts.htm#auto">スクリプト起動</a>時に変更することができます。</p>
<p>コントロールに送信されたメッセージは（投稿されるのではなく）、システムが裏でコントロールに直接ルーティングするため、監視されることはありません。システムで生成されたメッセージは、そのほとんどが投稿されるため、これが問題になることはほとんどありません。</p>
<p>スクリプトがアイドル状態で実行され続け、メッセージの着信を監視することを意図している場合、スクリプトの終了を防ぐために<a href="Persistent.htm">Persistent</a>関数を呼び出す必要がある場合があります。OnMessage は、スクリプトを自動的に永続化するわけではありません。例えば、OnMessageを使用してGUIウィンドウへの入力を監視する場合（<a href="#ExLButtonDown">WM_LBUTTONDOWNの例</a>など）、最後のGUIウィンドウが閉じられたときにスクリプトが自動的に終了するようにする方が適切な場合があります。</p>
<p id="Critical">以前に同じメッセージが到着したために、その関数がまだ実行されている間にメッセージが到着した場合、デフォルトでは、その関数は再び呼び出されず、代わりに、メッセージは監視されていないものとして扱われます。もしこれが望ましくないのであれば、それを回避する方法は複数あります：</p>
<ul>
  <li>メッセージが送信ではなく投稿であり、0x0311より大きい番号を持つ場合、関数の最初の行に<a href="Critical.htm">Critical</a>を指定することで、その関数が完了するまでバッファリングすることができます。また、<a href="Thread.htm">スレッドインタラプト</a>は、関数が終了するまでの時間が長ければ、同じ効果を得ることができます。</li>
  <li><a href="Critical.htm">Critical</a>を使用して<a href="Critical.htm#Interval">メッセージチェックの間隔を</a>長くすると、メッセージが送信される前に機能が完了する時間が長くなります。信頼性のために16以上の間隔が必要な場合があります。システムタイマーの粒度（通常は15.6ミリ秒）により、非クリティカルスレッドのデフォルト間隔（5ミリ秒）は、関数が開始した瞬間に経過しているように見えるかもしれません。</li>
  <li>モニター関数が素早く戻るようにすることで、<em>MaxThreads</em>のためにメッセージが見逃されるリスクを減らすことができます。一つの方法として、0x0311より大きい監視メッセージ番号を自身のスクリプトに<a href="PostMessage.htm">投稿</a>することで、未来のスレッドをキューに入れることができます。そのメッセージの関数は、メッセージがバッファリングされることを保証するために、その最初の行として<a href="Critical.htm">Critical</a>を使用する必要があります。また、<a href="SetTimer.htm">タイマー</a>を使って未来のスレッドをキューに入れることも可能です。</li>
  <li><a href="#MaxThreads">MaxThreads</a>パラメータに高い値を指定すると、新しく受信したメッセージを処理するために関数を中断させることができます。</li>
</ul>
<p id="buffering">スクリプトが<a href="../misc/Threads.htm#Interrupt">中断不可能な</a>状態で0x0311より大きい数値の監視メッセージが投稿された場合、そのメッセージはバッファリングされます；つまり、スクリプトが中断可能になるまでその関数は呼ばれません。しかし、投稿ではなく送信されるメッセージは、戻り値を提供する必要があるため、バッファリングすることはできません。システムダイアログ、リストビューのドラッグ＆ドロップ操作、メニューなどのモーダルメッセージループが実行されている場合、投稿されたメッセージがバッファされない場合があります。</p>
<p>監視対象メッセージが到着し、バッファリングされていない場合、メッセージ受信時にスレッドが<a href="../misc/Threads.htm#Interrupt">中断不可能</a>であったとしても、その関数は直ちに呼び出されます。</p>
<p>OnMessageスレッドの<a href="../misc/Threads.htm">優先順位</a>は常に0です。その結果、現在のスレッドの優先順位が0より高い場合、メッセージの監視やバッファリングは行われない。</p>
<p>システムメッセージ（0x0400以下のメッセージ）を監視する場合は、注意が必要です。例えば、モニター関数が早く終わらない場合、メッセージに対する応答がシステムの想定よりも長くなり、副作用が発生する可能性があります。また、モニター関数が整数値を返してメッセージのさらなる処理を抑制しているにもかかわらず、システムが別の処理または別の応答を期待していた場合にも、望ましくない動作が発生することがあります。</p>
<p>スクリプトが<a href="MsgBox.htm">MsgBox</a>などのシステムダイアログを表示している場合、コントロールに投稿されたメッセージは監視されません。例えば、スクリプトがメッセージボックスを表示しているときに、ユーザーがGUIウィンドウのボタンをクリックした場合、WM_LBUTTONDOWNメッセージはモニター関数を呼び出すことなく、直接ボタンに送信されます。</p>
<p>外部プログラムがPostThreadMessage()などのAPIコールでスクリプトのスレッドに直接メッセージを投稿することもできますが、スクリプトが<a href="MsgBox.htm">メッセージボックス</a>などのシステムウィンドウを表示している場合、メッセージが失われるためお勧めしません。その代わりに、スクリプトのメインウィンドウまたはGUIウィンドウの1つにメッセージを投稿または送信するのが通常最適です。</p>
<h2 id="Related">関連</h2>
<p><a href="CallbackCreate.htm">CallbackCreate</a>, <a href="OnExit.htm">OnExit</a>, <a href="OnClipboardChange.htm">OnClipboardChange</a>, <a href="PostMessage.htm">PostMessage</a>, <a href="SendMessage.htm">SendMessage</a>, <a href="../Functions.htm">Functions</a>, <a href="../misc/SendMessageList.htm">List of Windows Messages</a>, <a href="../misc/Threads.htm">Threads</a>, <a href="Critical.htm">Critical</a>, <a href="DllCall.htm">DllCall</a></p>
<h2 id="Examples">例</h2>
<div class="ex" id="ExLButtonDown">
<p><a class="ex_number" href="#ExLButtonDown"></a> GUIウィンドウのマウスクリックを監視する。関連トピック<a href="GuiOnEvent.htm#ContextMenu">ContextMenu</a>イベント</p>
<pre>MyGui := Gui(, "Example Window")
MyGui.Add("Text",, "Click anywhere in this window.")
MyGui.Add("Edit", "w200")
MyGui.Show
OnMessage 0x0201, WM_LBUTTONDOWN

WM_LBUTTONDOWN(wParam, lParam, msg, hwnd)
{
    X := lParam &amp; 0xFFFF
    Y := lParam &gt;&gt; 16
    Control := ""
    thisGui := GuiFromHwnd(hwnd)
    thisGuiControl := GuiCtrlFromHwnd(hwnd)
    if thisGuiControl
    {
        thisGui := thisGuiControl.Gui
        Control := "`n(in control " . thisGuiControl.ClassNN . ")"
    }
    ToolTip "You left-clicked in Gui window '" thisGui.Title "' at client coordinates " X "x" Y "." Control
}</pre>
</div>

<div class="ex" id="ExShutdown">
<p><a class="ex_number" href="#ExShutdown"></a> システムのシャットダウン/ログオフを検出し、ユーザーがそれを中止できるようにします。Windows Vista以降では、シャットダウン/ログオフをブロックしているプログラムを示すユーザーインターフェイスを表示し、ユーザーが強制的にシャットダウン/ログオフできるようにします。古いOSの場合、スクリプトは確認プロンプトを表示します。関連トピック<a href="OnExit.htm">OnExit</a></p>
<pre><em>; The following DllCall is optional: it tells the OS to shut down this script first (prior to all other applications).</em>
DllCall("kernel32.dll\SetProcessShutdownParameters", "UInt", 0x4FF, "UInt", 0)
OnMessage(0x0011, On_WM_QUERYENDSESSION)
Persistent

On_WM_QUERYENDSESSION(wParam, lParam, *)
{
    ENDSESSION_LOGOFF := 0x80000000
    if (lParam &amp; ENDSESSION_LOGOFF)  <em>; User is logging off.</em>
        EventType := "Logoff"
    else  <em>; System is either shutting down or restarting.</em>
        EventType := "Shutdown"
    try
    {
        <em>; Set a prompt for the OS shutdown UI to display.  We do not display
        ; our own confirmation prompt because we have only 5 seconds before
        ; the OS displays the shutdown UI anyway.  Also, a program without
        ; a visible window cannot block shutdown without providing a reason.</em>
        BlockShutdown("Example script attempting to prevent " EventType ".")
        return false
    }
    catch
    {
        <em>; ShutdownBlockReasonCreate is not available, so this is probably
        ; Windows XP, 2003 or 2000, where we can actually prevent shutdown.</em>
        Result := MsgBox(EventType " in progress. Allow it?",, "YN")
        if (Result = "Yes")
            return true  <em>; Tell the OS to allow the shutdown/logoff to continue.</em>
        else
            return false  <em>; Tell the OS to abort the shutdown/logoff.</em>
    }
}

BlockShutdown(Reason)
{
    <em>; If your script has a visible GUI, use it instead of A_ScriptHwnd.</em>
    DllCall("ShutdownBlockReasonCreate", "ptr", A_ScriptHwnd, "wstr", Reason)
    OnExit StopBlockingShutdown
}

StopBlockingShutdown(*)
{
    OnExit StopBlockingShutdown, 0
    DllCall("ShutdownBlockReasonDestroy", "ptr", A_ScriptHwnd)
}</pre>
</div>

<div class="ex" id="ExCustom">
<p><a class="ex_number" href="#ExCustom"></a> 他のスクリプトやプログラムから、カスタムメッセージと最大2つの数字を受信する（数字ではなく文字列を送信する場合は、この後の例を参照してください）。</p>
<pre>OnMessage 0x5555, MsgMonitor
Persistent

MsgMonitor(wParam, lParam, msg, *)
{
    <em>; Since returning quickly is often important, it is better to use ToolTip than</em>
    <em>; something like MsgBox that would prevent the function from finishing:</em>
    ToolTip "Message " msg " arrived:`nWPARAM:" wParam "`nLPARAM:" lParam
}

<em>; The following could be used inside some other script to run the function inside the above script:</em>
SetTitleMatchMode 2
DetectHiddenWindows True
if WinExist("Name of Receiving Script.ahk ahk_class AutoHotkey")
    PostMessage 0x5555, 11, 22  <em>; The message is sent  to the "<a href="../misc/WinTitle.htm#LastFoundWindow">last found window</a>" due to WinExist above.</em>
DetectHiddenWindows False  <em>; Must not be turned off until after PostMessage.</em></pre>
</div>

<div class="ex" id="ExSendString">
<p><a class="ex_number" href="#ExSendString"></a> あるスクリプトから別のスクリプトへ、任意の長さの文字列を送信します。これを使うには、次の2つのスクリプトを保存して実行し、<kbd>Win</kbd>+<kbd>Space</kbd>を押して入力ボックスを表示し、文字列を入力するよう促します。両方のスクリプトは同じ<a href="../Concepts.htm#native-encoding">ネイティブエンコーディング</a>を使用する必要があります。</p>
<p>以下のスクリプトを<strong>Receiver.ahk</strong>として保存し、起動してください。</p>
<pre filename="Receiver.ahk">#SingleInstance
OnMessage 0x004A, Receive_WM_COPYDATA  <em>; 0x004A is WM_COPYDATA</em>
Persistent

Receive_WM_COPYDATA(wParam, lParam, msg, hwnd)
{
    StringAddress := NumGet(lParam, 2*A_PtrSize, "Ptr")  <em>; Retrieves the CopyDataStruct's lpData member.</em>
    CopyOfData := StrGet(StringAddress)  <em>; Copy the string out of the structure.</em>
    <em>; Show it with ToolTip vs. MsgBox so we can return in a timely fashion:</em>
    ToolTip A_ScriptName "`nReceived the following string:`n" CopyOfData
    return true  <em>; Returning 1 (true) is the traditional way to acknowledge this message.</em>
}</pre>
<p>以下のスクリプトを<strong>Sender.ahk</strong>として保存し、起動してください。その後、<kbd>Win</kbd>+<kbd>Space</kbd>のホットキーを押してください。</p>
<pre filename="Sender.ahk">TargetScriptTitle := "Receiver.ahk ahk_class AutoHotkey"

#space::  <em>; Win+Space hotkey. Press it to show an input box for entry of a message string.</em>
{
    ib := InputBox("Enter some text to Send:", "Send text via WM_COPYDATA")
    if ib.Result = "Cancel"  <em>; User pressed the Cancel button.</em>
        return
    result := Send_WM_COPYDATA(ib.Value, TargetScriptTitle)
    if result = ""
        MsgBox "SendMessage failed or timed out. 次のWinTitleは存在しますか？:`n" TargetScriptTitle
    else if (result = 0)
        MsgBox "Message sent but the target window responded with 0, which may mean it ignored it."
}

Send_WM_COPYDATA(StringToSend, TargetScriptTitle)
<em>; This function sends the specified string to the specified window and returns the reply.
; The reply is 1 if the target window processed the message, or 0 if it ignored it.</em>
{
    CopyDataStruct := Buffer(3*A_PtrSize)  <em>; Set up the structure's memory area.</em>
    <em>; First set the structure's cbData member to the size of the string, including its zero terminator:</em>
    SizeInBytes := (StrLen(StringToSend) + 1) * 2
    NumPut( "Ptr", SizeInBytes  <em>; OS requires that this be done.</em>
          , "Ptr", StrPtr(StringToSend)  <em>; Set lpData to point to the string itself.</em>
          , CopyDataStruct, A_PtrSize)
    Prev_DetectHiddenWindows := A_DetectHiddenWindows
    Prev_TitleMatchMode := A_TitleMatchMode
    DetectHiddenWindows True
    SetTitleMatchMode 2
    TimeOutTime := 4000  <em>; Optional. Milliseconds to wait for response from receiver.ahk. Default is 5000
    ; Must use SendMessage not PostMessage.</em>
    RetValue := SendMessage(0x004A, 0, CopyDataStruct,, TargetScriptTitle,,,, TimeOutTime) <em>; 0x004A is WM_COPYDATA.</em>
    DetectHiddenWindows Prev_DetectHiddenWindows  <em>; Restore original setting for the caller.</em>
    SetTitleMatchMode Prev_TitleMatchMode         <em>; Same.</em>
    return RetValue  <em>; Return SendMessage's reply back to our caller.</em>
}</pre>
</div>

<p>ネットワーク接続でデータが到着したときに通知を受け取るOnMessageの使い方のデモは、<a href="../scripts/index.htm#WinLIRC">WinLIRCクライアントスクリプト</a>をご覧ください。</p>

</body>
</html>
