<!DOCTYPE HTML>
<html lang="ja">
<head>
<title>InputHook - 構文と使用法｜AutoHotkey v2</title>
<meta name="description" content="InputHook関数は、キーボード入力の収集や傍受に使用できるオブジェクトを作成します。" />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>InputHook</h1>

<p>キーボード入力の収集や傍受に使用できるオブジェクトを作成します。</p>

<pre class="Syntax">InputHook := <span class="func">InputHook</span>(<span class="optional">Options, EndKeys, MatchList</span>)</pre>
<h2 id="Parameters">パラメータ</h2>
<dl>

  <dt>Options</dt>
  <dd>
    <p>型：<a href="../Concepts.htm#strings">文字列</a></p>
    <p>A string of zero or more of the following options (in any order, with optional spaces in between):</p>
    <p id="option-b"><strong>B:</strong> Sets <a href="#BackspaceIsUndo">BackspaceIsUndo</a> to false, which causes <kbd>Backspace</kbd> to be ignored.</p>
    <p id="option-c"><strong>C:</strong> Sets <a href="#CaseSensitive">CaseSensitive</a> to true, making <em>MatchList</em> case sensitive.</p>
    <p id="option-i"><strong>I:</strong> Sets <a href="#MinSendLevel">MinSendLevel</a> to 1 or a given value, causing any input with <a href="SendLevel.htm">send level</a> below this value to be ignored. 例えば、<code>I2</code>は、レベルが0（デフォルト）または1の入力は無視し、レベル2の入力を捕捉することができます。</p>
    <p id="option-l"><strong>L:</strong> Length limit (e.g. <code>L5</code>). 入力の最大許容長を示します。テキストがこの長さに達すると、入力は終了し、EndReasonにはMaxという単語が設定されます（ただし、テキストが<em>MatchList</em>のフレーズのいずれかに一致する場合は、EndReasonにはMatchという単語が設定されます）。未指定の場合、長さの上限は1023となります。</p>
    <p><code>L0</code>を指定すると、テキストの収集と長さの制限が無効になりますが、どのキーがテキストを生成しているとカウントされるかは影響しません（「<a href="#VisibleText">VisibleText</a>」を参照）。<a href="#OnChar">OnChar</a>、<a href="#OnKeyDown">OnKeyDown</a>、<a href="#KeyOpt">KeyOptと組み合わせて</a>使用すると便利です。 <em><a href="#EndKeys">EndKeys</a></em>.</p>
    <p id="option-m"><strong>M:</strong> Modified keystrokes such as <kbd>Ctrl</kbd>+<kbd>A</kbd> through <kbd>Ctrl</kbd>+<kbd>Z</kbd> are recognized and transcribed if they correspond to real ASCII characters. <kbd>Ctrl</kbd>+<kbd>C</kbd>を認識するこの例について考えてみましょう：</p>
    <pre>CtrlC := Chr(3)  <em>; CtrlCの文字をCtrlC varに格納</em>します。
ih := InputHook("L1 M")
ih.Start()
ih.Wait()
if (ih.Input = CtrlC)
    MsgBox "You pressed Control-C."</pre>
    <p class="note"><strong>Note:</strong> The characters <kbd>Ctrl</kbd>+<kbd>A</kbd> through <kbd>Ctrl</kbd>+<kbd>Z</kbd> correspond to <a href="Chr.htm">Chr(1)</a> through <a href="Chr.htm">Chr(26)</a>. Also, the M option might cause some keyboard shortcuts such as <kbd>Ctrl</kbd>+<kbd>←</kbd> to misbehave while an Input is in progress.</p>
    <p id="option-t"><strong>T:</strong> Sets <a href="#Timeout">Timeout</a> (e.g. <code>T3</code> or <code class="no-highlight">T2.5</code>).</p>
    <p id="vis"><strong>V:</strong> Sets <a href="#VisibleText">VisibleText</a> and <a href="#VisibleNonText">VisibleNonText</a> to true. 通常、ユーザーの入力はブロックされます（システムから隠されます）。ユーザーのキー入力をアクティブウィンドウに送るには、このオプションを使用します。</p>
    <p id="asterisk"><strong>*:</strong> Wildcard. <a href="#FindAnywhere">FindAnywhere</a>をtrueに設定し、ユーザーが入力した内容のどこにでもマッチを見つけることができるようにします。</p>
    <p id="E"><strong>E:</strong> Handle single-character end keys by character code instead of by keycode. これにより、アクティブウィンドウのキーボードレイアウトがスクリプトのキーボードレイアウトと異なる場合、より一貫した結果が得られます。It also prevents key combinations which don't actually produce the given end characters from ending input; for example, if @ is an end key, on the US layout <kbd>Shift</kbd>+<kbd>2</kbd> will trigger it but <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>2</kbd> will not (if the E option is used). If the C option is also used, the end character is case-sensitive.</p>
  </dd>

  <dt id="EndKeys">EndKeys</dt>
  <dd>
    <p>型：<a href="../Concepts.htm#strings">文字列</a></p>
    <p>0個以上のキーのリストで、どれかが押されると入力が終了します（終了キー自体は入力バッファに書き込まれません）。この方法でInputを終了させると、EndReasonにEndKeyという単語が設定され、<a href="#EndKey">EndKey</a>プロパティにキーの名前が設定されます。</p>
    <p><em>EndKeys</em> uses a format similar to the <a href="Send.htm">Send</a> function. 例えば、<code>{Enter}.{Esc}</code>と指定すると、<kbd>Enter</kbd>、<kbd>.</kbd>、<kbd>Esc</kbd>のいずれかが入力を終了させることになる。中括弧そのものを終了キーとして使用する場合は、<code>{{}</code>と <code>{}}</code>を指定します。</p>
    <p>To use <kbd>Ctrl</kbd>, <kbd>Alt</kbd>, or <kbd>Shift</kbd> as end keys, specify the left and/or right version of the key, not the neutral version. 例えば、<code>{Control}</code>ではなく、<code>{LControl}{RControl}</code>を指定します。</p>
    <p>Although modified keys such as <kbd>Alt</kbd>+<kbd>C</kbd> (!c) are not supported, non-alphanumeric characters such as <code>?!:@&amp;{}</code> by default require <kbd>Shift</kbd> or <kbd>AltGr</kbd> to be pressed or not pressed depending on how the character is normally typed. If the E option is present, single character key names are interpreted as characters instead, and in those cases the modifier keys must be in the correct state to produce that character. When the E and M options are both used, <kbd>Ctrl</kbd>+<kbd>A</kbd> through <kbd>Ctrl</kbd>+<kbd>Z</kbd> are supported by including the corresponding ASCII control characters in <em>EndKeys</em>.</p>
    <p><code>vkFF}や</code> <code>{sc001}の</code>ような明示的なキーコードを指定することも可能です。これは、キーに名前がなく、押しても何も表示されないような場合に便利です。Its key code can be determined by following the steps at the bottom of the <a href="../KeyList.htm#SpecialKeys">key list page</a>.</p>
  </dd>

  <dt id="MatchList">MatchList</dt>
  <dd>
    <p>型：<a href="../Concepts.htm#strings">文字列</a></p>
    <p>カンマで区切られたキーフレーズのリストで、どれか一つでもあれば入力は終了します（この場合、EndReasonにはMatchという単語が設定されます）。マッチングを行うには、ユーザーが入力した内容全体がフレーズの1つと正確に一致する必要があります（<a href="#asterisk">* option</a>が存在する場合を除きます）。また、<strong>区切りであるカンマの周りにあるスペースやタブ</strong>は、マッチ文字列の一部であることを意味し、<strong>重要な</strong>意味を持ちます。例えば、<em>MatchList</em>が <code>ABC , XYZ</code>の場合、ユーザーはABCの後かXYZの前にスペースを入力しなければ、マッチングが発生しません。</p>
    <p>カンマが2つ続くと、文字通りのカンマ1つとなります。例えば、次のようにすると、文字列の末尾にリテラルコンマが1つ入ることになります：<code>string1,,,string2</code>. 同様に、次のリストには、その中にリテラルなカンマを持つ項目が1つだけ含まれています：<code>single,,item</code>.</p>
    <p><em>MatchList</em>の項目は個々のパラメータとして扱われないため、リストをすべて変数に格納することができます。例えば、<em>MatchList</em>は <code>List1 "," List2 "," List3</code>からなり、それぞれの変数にマッチフレーズの大きなサブリストが含まれていることがあります。</p>
  </dd>

</dl>

<h2 id="stack">Input Stack</h2>
<p>InputHookオブジェクトは、いつでもいくつでも作成でき、進行中ですが、開始する順番によって、入力の収集方法に影響があります。</p>
<p><a href="#Start">Start</a>メソッドで入力が開始されると、スタックの一番上に置かれ、入力が終了したときだけスタックから取り除かれます。キーボードイベントは、最近開始されたものから順に各Inputに渡されます。入力が与えられたキーボードイベントを抑制する場合、そのイベントはそれ以上スタック下に渡されません。</p>
<p><a href="Send.htm">送信された</a>キーストロークの<a href="SendLevel.htm">送信レベル</a>がInputHookの<a href="#MinSendLevel">MinSendLevel</a>以下の場合、<a href="Send.htm">送信された</a>キーストロークは無視されます。このような場合、キーストロークは、スタックの下位にある入力によって処理される可能性がある。</p>
<p>複数のInputHooksを<a href="#MinSendLevel">MinSendLevel</a>と組み合わせて使用することで、送信されたキーストロークと実際のキーストロークの両方を個別に収集することができます。</p>

<h2 id="object">InputHook Object</h2>
<p>InputHook関数は、以下のメソッドとプロパティを持つInputHookオブジェクトを返します。</p>
<ul class="indent">
  <li><a href="#Methods">Methods</a>:
    <ul>
      <li><a href="#KeyOpt">KeyOpt</a>:キーまたはキーのリストに対するオプションを設定します。</li>
      <li><a href="#Start">Start</a>:入力の収集を開始します。</li>
      <li><a href="#Stop">Stop</a>:入力を終了し、EndReason に Stopped という単語を設定します。</li>
      <li><a href="#Wait">Wait</a>:Inputが終了するまで待機します（InProgressがfalse）。</li>
    </ul>
  </li>
  <li><a href="#General_Properties">General Properties</a>:
    <ul>
      <li><a href="#EndKey">EndKey</a>: Returns the name of the end key which was pressed to terminate the Input.</li>
      <li><a href="#EndMods">EndMods</a>:Input終了時に論理的にダウンしていたモディファイアの文字列を返します。</li>
      <li><a href="#EndReason">EndReason</a>: Returns an EndReason string indicating how Input was terminated.</li>
      <li><a href="#InProgress">InProgress</a>: Returns 1 (true) if the Input is in progress, otherwise 0 (false).</li>
      <li><a href="#Input">Input</a>:前回Inputを起動してから収集したテキストを返します。</li>
      <li><a href="#Match">Match</a>:Inputを終了させた<em>MatchList</em>の項目を返します。</li>
      <li><a href="#OnEnd">OnEnd</a>: Retrieves or sets the function object which is called when Input is terminated.</li>
      <li><a href="#OnChar">OnChar</a>: Retrieves or sets the function object which is called after a character is added to the input buffer.</li>
      <li><a href="#OnKeyDown">OnKeyDown</a>: Retrieves or sets the function object which is called when a notification-enabled key is pressed.</li>
      <li><a href="#OnKeyUp">OnKeyUp</a>: Retrieves or sets the function object which is called when a notification-enabled key is released.</li>
    </ul>
  </li>
  <li><a href="#Option_Properties">Option Properties</a>:
    <ul>
      <li><a href="#BackspaceIsUndo">BackspaceIsUndo</a>: Controls whether the Backspace key removes the most recently pressed character from the end of the Input buffer.</li>
      <li><a href="#CaseSensitive">CaseSensitive</a>:<em>MatchList</em>が大文字と小文字を区別するかどうかを制御します。</li>
      <li><a href="#FindAnywhere">FindAnywhere</a>:各マッチが入力テキストの部分文字列となり得るかどうかを制御します。</li>
      <li><a href="#MinSendLevel">MinSendLevel</a>: Retrieves or sets the minimum send level of input to collect.</li>
      <li><a href="#NotifyNonText">NotifyNonText</a>: Controls whether the OnKeyDown and OnKeyUp callbacks are called whenever a non-text key is pressed.</li>
      <li><a href="#Timeout">Timeout</a>:タイムアウト値を秒単位で取得または設定します。</li>
      <li><a href="#VisibleNonText">VisibleNonText</a>:テキストを生成しないキーまたはキーの組み合わせを表示するかどうかを制御します（ブロックされません）。</li>
      <li><a href="#VisibleText">VisibleText</a>:テキストを生成するキーまたはキーの組み合わせを表示するかどうかを制御します（ブロックされません）。</li>
    </ul>
  </li>
</ul>

<h3 id="Methods">メソッド</h3>
<div class="methodShort" id="KeyOpt"><h3>KeyOpt</h3>
<p>キーまたはキーのリストに対するオプションを設定します。</p>
<pre class="Syntax">InputHook<span class="func">.KeyOpt</span>(Keys, KeyOptions)</pre>
<dl>
  <dt>Keys</dt>
  <dd>
  <p>型：<a href="../Concepts.htm#strings">文字列</a></p>
  <p>キーの一覧です。中括弧は、<a href="Send.htm">送信</a>機能と同様に、キー名、仮想キーコード、スキャンコードを囲むために使用されます。例えば、<code>{Enter}.{{}</code>は、<kbd>Enter</kbd>, <kbd>.</kbd> および <kbd>{</kbd>に適用されます。キーを名前、<code>{vkNN}</code>、または<code>{scNNN}</code>で指定すると、3つの異なる結果が得られます；詳細は以下を参照してください。</p>
  <p id="all-keys">文字列<code>{All}</code>（大文字・小文字を区別しない）を単独で指定すると、すべてのVKとすべてのSCに<em>KeyOptions</em>が適用されます。その後、KeyOptを2回目に呼び出すと、特定のキーからオプションを削除することができます。</p></dd>
  <dt>KeyOptions</dt>
  <dd>
  <p>型：<a href="../Concepts.htm#strings">文字列</a></p>
  <p>以下の1文字オプションのうち1つ以上（スペースとタブは無視されます）。</p>
  <p id="KeyOpt-minus"><strong>-</strong> (minus):<code>-</code>に続くオプションのうち、次の<code>+</code>まで削除します。</p>
  <p id="KeyOpt-plus"><strong>+</strong> (plus):それ以外の場合は、何の効果もなく、以前の<code>-</code>をキャンセルします。</p>
  <p id="KeyOpt-e"><strong>E:</strong> End key. 有効な場合、キーを押すとInputが終了し、<a href="#EndReason">EndReason</a>にEndKeyという単語が、<a href="#EndKey">EndKey</a>プロパティにキーの正規化された名前が設定されます。Unlike the <em>EndKeys</em> parameter, the state of <kbd>Shift</kbd> or <kbd>AltGr</kbd> is ignored. For example, <code>@</code> and <code class="no-highlight">2</code> are both equivalent to <code>{vk32}</code> on the US keyboard layout.</p>
  <p id="KeyOpt-i"><strong>I:</strong> Ignore text. このキーによって通常生成されるテキストはすべて無視され、キーは非テキストキーとして扱われる（<a href="#VisibleNonText">VisibleNonText</a>参照）。そのキーが通常テキストを生成しない場合、効果はありません。</p>
  <p id="KeyOpt-n"><strong>N:</strong> Notify. キーが押されるたびに<a href="#OnKeyDown">OnKeyDown</a>および<a href="#OnKeyUp">OnKeyUp</a>コールバックが呼び出されるようにします。</p>
  <p id="KeyOpt-s"><strong>S:</strong> Suppresses (blocks) the key after processing it. <code>S</code>が使用されるまでは、<a href="#VisibleText">VisibleText</a>または<a href="#VisibleNonText">VisibleNonText</a>に優先します。<code>+S</code>は <code>-V</code>を意味します。</p>
  <p id="KeyOpt-v"><strong>V:</strong> Visible. キーが抑制される（ブロックされる）のを防ぐ。<code>V</code>が使用されるまで、<a href="#VisibleText">VisibleText</a>または<a href="#VisibleNonText">VisibleNonText</a>をオーバーライドします。<code>+V</code>は <code>-S</code>を意味します。</p>
  </dd>
</dl>
<p id="KeyOpt-remarks">オプションは、仮想キーコードとスキャンコードの両方で設定でき、累積されます。</p>
<p>キーが名前で指定されている場合、オプションはVKまたはSCで設定されます。2つの物理キーが同じVKを共有し、SCによって異なる場合（<kbd>Up</kbd>と <kbd>NumpadUp</kbd>など）、SCによって扱われます。一方、VK番号を使用する場合は、そのVKを生成するすべての物理キーに適用されます（これは、アクティブなキーボードレイアウトに依存するため、時間と共に変化する可能性があります）。</p>
<p>VK番号でオプションを削除しても、SCで設定されていたオプションには影響しませんし、その逆も同様です。ただし、キー名でオプションが削除され、そのキー名がVKで扱われる場合、対応するSCについてもオプションが削除されます（スクリプトのキーボードレイアウトに準じます）。これにより、<a href="#all-keys">すべてのキー</a>にオプションを適用した後に、キー名を指定して除外することができます。</p>
<p>VKで<code>+V</code>を設定し、SCで<code>+S</code>を設定した場合（またはその逆）、<code>+V</code>が優先されます。</p>
</div>

<div class="methodShort" id="Start"><h3>Start</h3>
<p>入力の収集を開始します。</p>
<pre class="Syntax">InputHook<span class="func">.Start</span>()</pre>
<p>入力がすでに進行している場合は、効果がありません。</p>
<p>新しく開始された入力は、<a href="#stack">InputHookスタック</a>の最上位に置かれ、以前に開始された入力を上書きすることができます。</p>
<p>このメソッドは、<a href="InstallKeybdHook.htm">キーボードフック</a>をインストールします（まだインストールされていない場合）。</p>
</div>

<div class="methodShort" id="Stop"><h3>Stop</h3>
<p>入力を終了し、<a href="#EndReason">EndReason</a>に Stopped という単語を設定します。</p>
<pre class="Syntax">InputHook.<span class="func">Stop</span>()</pre>
<p>入力中でない場合は、効果がありません。</p>
</div>

<div class="methodShort" id="Wait"><h3>Wait</h3>
<p>Inputが終了するまで待機する（<a href="#InProgress">InProgress</a>がfalse）。</p>
<pre class="Syntax">InputHook.<span class="func">Wait</span>(<span class="optional">MaxTime</span>)</pre>
<dl>
  <dt>MaxTime</dt>
  <dd>
    <p>型：<a href="../Concepts.htm#numbers">Float</a></p>
    <p>待機する最大秒数です。<em>MaxTime</em>秒後に Input がまだ進行している場合、このメソッドは戻り、Input は終了しません。</p>
  </dd>
</dl>
<p>Returns <a href="#EndReason">EndReason</a>.</p>
</div>

<h3 id="General_Properties">一般特性</h3>
<div class="methodShort" id="EndKey"><h3>EndKey</h3>
<p>Input を終了させるために押された<a href="#EndKeys">終了キー</a>の名前を返します。</p>
<pre class="Syntax">KeyName := InputHook.EndKey</pre>
<p>EndKeyは、<em>EndKeys</em>でどのように書かれていたかにかかわらず、キーの「正規化」された名前を返すことに注意してください。例えば、<code>{Esc}</code>と <code>{vk1B}</code>はどちらも<code>Escape</code>を生成します。<a href="GetKeyName.htm">GetKeyName</a>を使用すると、正規化された名前を取得することができます。</p>
<p><a href="#E">E オプション</a>が使用された場合、EndKey は入力された実際の文字を返します（該当する場合）。それ以外の場合は、スクリプトのアクティブなキーボードレイアウトに従って、キー名が決定されます。</p>
<p>EndKey は、<a href="#EndReason">EndReason</a>が "EndKey" でない場合、空文字列を返す。</p>
</div>

<div class="methodShort" id="EndMods"><h3>EndMods</h3>
<p>Input終了時に論理的にダウンしていたモディファイアの文字列を返します。</p>
<pre class="Syntax">Mods := InputHook.EndMods</pre>
<p>すべてのモディファイアが論理的にダウン（押された）した場合、完全な文字列は次のようになります：</p>
<pre>&lt;^&gt;^&lt;!&gt;!&lt;+&gt;+&lt;#&gt;#</pre>
<p>これらの修飾語は、<a href="../Hotkeys.htm">ホットキー</a>の場合と同じ意味を持ちます。各モディファイアは必ず &lt; (左) または &gt; （右）で修飾されます。対応するキー名は以下の通りです：LCtrl, RCtrl, LAlt, RAlt, LShift, RShift, LWin, RWin.</p>
<p><a href="InStr.htm">InStr</a>は、与えられた修飾語（<code>&gt;!</code>や <code>^</code>など）が存在するかどうかをチェックするために使用することができます。次の行で、<em>Mods</em>を <code>^!+#</code>のような中立的な修飾語の文字列に変換することができます：</p>
<pre>Mods := RegExReplace(Mods, "[&lt;&gt;](.)(?:&gt;\1)?", "$1")</pre>
<p>一瞬のタイミングのため、このプロパティは、Inputが終了した直後や<a href="#OnEnd">OnEnd</a>コールバックで使用されても、<a href="GetKeyState.htm">GetKeyState</a>よりも信頼性が高い場合があります。</p>
</div>

<div class="methodShort" id="EndReason"><h3>EndReason</h3>
<p>Input がどのように終了したかを示す<a href="#EndReasons">EndReason の文字列</a>を返す。</p>
<pre class="Syntax">Reason := InputHook.EndReason</pre>
<p>入力がまだ進行中の場合は空文字列を返します。</p>
</div>

<div class="methodShort" id="InProgress"><h3>InProgress</h3>
<p>Returns 1 (true) if the Input is in progress, otherwise 0 (false).</p>
<pre class="Syntax">Boolean := InputHook.InProgress</pre>
</div>

<div class="methodShort" id="Input"><h3>Input</h3>
<p>前回Inputを起動してから収集したテキストを返します。</p>
<pre class="Syntax">String := InputHook.Input</pre>
<p>このプロパティは、Inputの実行中、または終了後に使用することができます。</p>
</div>

<div class="methodShort" id="Match"><h3>Match</h3>
<p><em><a href="#MatchList">マッチリスト</a></em>入力終了の原因となった項目を返します。 </p>
<pre class="Syntax">String := InputHook.Match</pre>
<p>Returns the matched item with its original case, which may differ from what the user typed if the C option was omitted. Returns an empty string if <a href="#EndReason">EndReason</a> is not "Match".</p>
</div>

<div class="methodShort" id="OnEnd"><h3>OnEnd</h3>
<p>Input終了時に呼び出される<a href="../misc/Functor.htm">関数オブジェクト</a>を取得または設定します。</p>
<pre class="Syntax">MyFunc := InputHook.OnEnd</pre>
<pre class="Syntax">InputHook.OnEnd := MyFunc</pre>
<p>型：<a href="../misc/Functor.htm">関数オブジェクト</a>または<a href="../Concepts.htm#nothing">空文字列</a>を指定します。既定値：空の文字列</p>
<p>この関数には1つのパラメータが渡されます：InputHookオブジェクトへの参照。</p>
<p>この関数は新しい<a href="../misc/Threads.htm">スレッド</a>として呼び出されるため、<a href="SendMode.htm">SendMode</a>や <a href="DetectHiddenWindows.htm">DetectHiddenWindows</a>などの設定にデフォルト値が設定され、新しい状態で開始されます。</p>
</div>

<div class="methodShort" id="OnChar"><h3>OnChar</h3>
<p>入力バッファに文字が追加された後に呼び出される<a href="../misc/Functor.htm">関数オブジェクト</a>を取得または設定します。</p>
<pre class="Syntax">MyFunc := InputHook.OnChar</pre>
<pre class="Syntax">InputHook.OnChar := MyFunc</pre>
<p>型：<a href="../misc/Functor.htm">関数オブジェクト</a>または<a href="../Concepts.htm#nothing">空文字列</a>を指定します。既定値：空の文字列</p>
<p>この関数には、以下のパラメータが渡されます：<code>InputHook, Char</code>. <em>Char</em>は、文字または文字を含む文字列です。</p>
<p>複数の文字が存在することは、最後のキー押下の前にデッドキーが使用されていたことを示しますが、2つのキーは1つの文字に変換することができませんでした。例えば、あるキーボードレイアウトでは、<kbd>`</kbd><kbd>e</kbd>は <code>è</code>を、<kbd>`</kbd><kbd>z</kbd>は <code>`z</code>を出力します。</p>
<p>終了キーが押されても、この関数が呼び出されることはありません。</p>
</div>

<div class="methodShort" id="OnKeyDown"><h3>OnKeyDown</h3>
<p>通知可能なキーが押されたときに呼び出される<a href="../misc/Functor.htm">関数オブジェクト</a>を取得または設定します。</p>
<pre class="Syntax">MyFunc := InputHook.OnKeyDown</pre>
<pre class="Syntax">InputHook.OnKeyDown := MyFunc</pre>
<p>型：<a href="../misc/Functor.htm">関数オブジェクト</a>または<a href="../Concepts.htm#nothing">空文字列</a>を指定します。既定値：空の文字列</p>
<p>キーダウンの通知は、まず<a href="#KeyOpt">KeyOpt</a>または<a href="#NotifyNonText">NotifyNonText</a>で有効化する必要があります。</p>
<p>この関数には、以下のパラメータが渡されます：<code>InputHook, VK, SC</code>. <em>VK</em>と <em>SC</em>は整数です。キー名を取得する場合は、<code>GetKeyName(Format("vk{:x}sc{:x}", VK, SC))</code>を使用することです。</p>
<p>この関数は新しい<a href="../misc/Threads.htm">スレッド</a>として呼び出されるため、<a href="SendMode.htm">SendMode</a>や <a href="DetectHiddenWindows.htm">DetectHiddenWindows</a>などの設定にデフォルト値が設定され、新しい状態で開始されます。</p>
<p>終了キーが押されても、この関数が呼び出されることはありません。</p>
</div>

<div class="methodShort" id="OnKeyUp"><h3>OnKeyUp</h3>
<p>通知可能なキーがリリースされたときに呼び出される<a href="../misc/Functor.htm">関数オブジェクト</a>を取得または設定します。</p>
<pre class="Syntax">MyFunc := InputHook.OnKeyUp</pre>
<pre class="Syntax">InputHook.OnKeyUp := MyFunc</pre>
<p>型：<a href="../misc/Functor.htm">関数オブジェクト</a>または<a href="../Concepts.htm#nothing">空文字列</a>を指定します。既定値：空の文字列</p>
<p>キーアップ通知は、まず<a href="#KeyOpt">KeyOpt</a>または<a href="#NotifyNonText">NotifyNonText</a>で有効化する必要があります。キーが押されたときに、テキストとみなされるか非テキストとみなされるかは、キーが押されたときに判断されます。InputHookがキーダウンを検出せずにキーアップを検出した場合、非テキストとみなされます。</p>
<p>この関数には、以下のパラメータが渡されます：<code>InputHook, VK, SC</code>. <em>VK</em>と <em>SC</em>は整数です。キー名を取得する場合は、<code>GetKeyName(Format("vk{:x}sc{:x}", VK, SC))</code>を使用することです。</p>
<p>この関数は新しい<a href="../misc/Threads.htm">スレッド</a>として呼び出されるため、<a href="SendMode.htm">SendMode</a>や <a href="DetectHiddenWindows.htm">DetectHiddenWindows</a>などの設定にデフォルト値が設定され、新しい状態で開始されます。</p>
</div>

<h3 id="Option_Properties">オプションプロパティ</h3>
<div class="methodShort" id="BackspaceIsUndo"><h3>BackspaceIsUndo</h3>
<p><kbd>Backspace</kbd>が、最近押された文字をInputバッファの最後から削除するかどうかを制御します。</p>
<pre class="Syntax">Boolean := InputHook.BackspaceIsUndo</pre>
<pre class="Syntax">InputHook.BackspaceIsUndo := Boolean</pre>
<p>型：<a href="../Concepts.htm#boolean">Integer（boolean）</a>。既定値：true. Option B sets the value to false.</p>
<p><kbd>Backspace</kbd>がアンドゥとして機能する場合、テキスト入力キーとして扱われます。具体的には、キーが抑制されるかどうかは、<a href="#VisibleNonText">VisibleNonText</a>ではなく、<a href="#VisibleText">VisibleText</a>に依存します。</p>
<p><kbd>Backspace</kbd>は、<kbd>Ctrl</kbd>などの修飾キーと組み合わせて押された場合、常に無視されます（物理的な状態ではなく、論理的な修飾の状態がチェックされます）。</p>
<p class="warning"><strong>注：</strong>入力テキストが表示されていて（エディターなど）、その中を矢印キーなどで移動する場合、<kbd>Backspace</kbd>はキャレット（挿入点）の後ろの文字ではなく、やはり最後の文字を削除します。</p>
</div>

<div class="methodShort" id="CaseSensitive"><h3>CaseSensitive</h3>
<p><em>MatchList</em>が大文字と小文字を区別するかどうかを制御します。</p>
<pre class="Syntax">Boolean := InputHook.CaseSensitive</pre>
<pre class="Syntax">InputHook.CaseSensitive := Boolean</pre>
<p>型：<a href="../Concepts.htm#boolean">Integer（boolean）</a>。既定値：false. Option C sets the value to true.</p>
</div>

<div class="methodShort" id="FindAnywhere"><h3>FindAnywhere</h3>
<p>各マッチが入力テキストの部分文字列となり得るかどうかを制御します。</p>
<pre class="Syntax">Boolean := InputHook.FindAnywhere</pre>
<pre class="Syntax">InputHook.FindAnywhere := Boolean</pre>
<p>型：<a href="../Concepts.htm#boolean">Integer（boolean）</a>。既定値：false. Option * sets the value to true.</p>
<p>trueの場合、ユーザーが入力した文字列の範囲内であればどこでもマッチします（マッチするのは入力テキストの部分文字列でもかまいません）。Falseの場合、ユーザーが入力した内容全体が、<em>MatchList</em>のフレーズのいずれかに一致しなければならない。いずれの場合も、<em>MatchList</em>のフレーズのうち1つは全文入力する必要があります。</p>
</div>

<div class="methodShort" id="MinSendLevel"><h3>MinSendLevel</h3>
<p>収集する入力の最小<a href="SendLevel.htm">送信</a>レベルを取得または設定します。</p>
<pre class="Syntax">Level := InputHook.MinSendLevel</pre>
<pre class="Syntax">InputHook.MinSendLevel := Level</pre>
<p>型：<a href="../Concepts.htm#numbers">整数</a>既定値：0. Option I sets the value to 1 (or a given value).</p>
<p><em>Level</em>は 0～101 の整数を指定します。この値より<em>低い</em>送信レベルを持つイベントは無視されます。例えば、101を指定すると<a href="Send.htm">SendEvent</a>で生成されたすべての入力が無視され、1を指定するとデフォルトの送信レベル（0）の入力のみが無視されます。</p>
<p><a href="Send.htm#SendInput">SendInput</a>および<a href="Send.htm#SendPlay">SendPlay</a>メソッドは、この設定にかかわらず、常に無視されます。AutoHotkey以外のソースで生成された入力は、この設定の結果、決して無視されることはありません。</p>
</div>

<div class="methodShort" id="NotifyNonText"><h3>NotifyNonText</h3>
<p>テキスト以外のキーが押されたときに、<a href="#OnKeyDown">OnKeyDown</a>および<a href="#OnKeyUp">OnKeyUp</a>コールバックを呼び出すかどうかを制御します。</p>
<pre class="Syntax">Boolean := InputHook.NotifyNonText</pre>
<pre class="Syntax">InputHook.NotifyNonText := Boolean</pre>
<p>型：<a href="../Concepts.htm#boolean">Integer（boolean）</a>。既定値：false.</p>
<p>Trueに設定すると <kbd>Left</kbd> または <kbd>Alt</kbd>+<kbd>F</kbd>を押したときなど、テキストを生成しないすべてのキー入力に対して通知を行うことができます。このプロパティを設定しても、キーの<a href="#KeyOpt">オプション</a>には影響しません。なぜなら、テキストの生成は、キーが押された時点のアクティブウィンドウのキーボードレイアウトに依存するからです。 </p>
<p>NotifyNonText は、VK コードが一致する前のキーダウンがテキストと非テキストのどちらに分類されるかを考慮して、キーアップイベントに適用されます。例えば、NotifyNonTextがtrueの場合、<kbd>Ctrl</kbd>+<kbd>A</kbd>を押すと、<kbd>Ctrl</kbd>と <kbd>A</kbd>の両方で<a href="#OnKeyDown">OnKeyDown</a>と <a href="#OnKeyUp">OnKeyUp</a>が呼び出されますが、<a href="#KeyOpt">KeyOpt</a>でそのキーに対する通知を有効にしていなければ、<kbd>A</kbd>単独で押してもOnKeyDownやOnKeyUpは呼ばれません。</p>
<p>どのキーがテキストを生成するものとしてカウントされるかの詳細については、<a href="#VisibleText">VisibleText</a>を参照してください。</p>
</div>

<div class="methodShort" id="Timeout"><h3>タイムアウト</h3>
<p>タイムアウト値を秒単位で取得または設定します。</p>
<pre class="Syntax">Seconds := InputHook.Timeout</pre>
<pre class="Syntax">InputHook.Timeout := Seconds</pre>
<p>型：<a href="../Concepts.htm#numbers">浮動小数点数</a>既定値：0.0 (none). Option T also sets the timeout value.</p>
<p>通常、タイムアウトは<a href="#Start">Start</a>が呼ばれた時点で開始されるが、Inputの実行中に本プロパティに値が代入された場合は、再開されます。タイムアウト時間が経過しても入力が継続している場合は、入力は終了し、<a href="#EndReason">EndReason</a>に Timeout という単語が設定されます。</p>
</div>

<div class="methodShort" id="VisibleNonText"><h3>VisibleNonText</h3>
<p>テキストを生成しないキーまたはキーの組み合わせを表示するかどうかを制御します（ブロックされません）。</p>
<pre class="Syntax">Boolean := InputHook.VisibleNonText</pre>
<pre class="Syntax">InputHook.VisibleNonText := Boolean</pre>
<p>型：<a href="../Concepts.htm#boolean">Integer（boolean）</a>。既定値：true. Option V sets the value to true.</p>
<p>trueの場合、テキストを生成しないキーやキーの組み合わせは、ホットキーのトリガーになったり、アクティブウィンドウに渡されたりすることがあります。false の場合、ブロックされます。</p>
<p>どのキーがテキストを生成するものとしてカウントされるかの詳細については、<a href="#VisibleText">VisibleText</a>を参照してください。</p>
</div>

<div class="methodShort" id="VisibleText"><h3>VisibleText</h3>
<p>テキストを生成するキーまたはキーの組み合わせを表示するかどうかを制御します（ブロックされません）。</p>
<pre class="Syntax">Boolean := InputHook.VisibleText</pre>
<pre class="Syntax">InputHook.VisibleText := Boolean</pre>
<p>型：<a href="../Concepts.htm#boolean">Integer（boolean）</a>。既定値：false. Option V sets the value to true.</p>
<p>trueの場合、テキストを生成するキーとキーの組み合わせは、ホットキーをトリガーしたり、アクティブウィンドウに渡されることがあります。false の場合、ブロックされます。</p>
<p>入力バッファにテキストが追加されるようなキー操作は、他のアプリケーションでは通常そうでなくても、テキストを生成したものとしてカウントされます。For instance, <kbd>Ctrl</kbd>+<kbd>A</kbd> produces text if the <a href="#option-m">M option</a> is used, and <kbd>Esc</kbd> produces the control character <code>Chr(27)</code>.</p>
<p>デッドキーは、通常、即効性はありませんが、テキストを生成するものとしてカウントされます。デッドキーを押すと、次のキーでも文字が出るかもしれません（デッドキーの文字だけなら）。</p>
<p><kbd>Backspace</kbd>、<a href="#BackspaceIsUndo">アンドゥとして機能</a>する場合のみ、テキストを生成するものとしてカウントされます。</p>
<p>The <a href="../KeyList.htm#modifier">standard modifier keys</a> and <kbd>CapsLock</kbd>, <kbd>NumLock</kbd> and <kbd>ScrollLock</kbd> are always visible (not blocked).</p>
</div>

<h2 id="EndReasons">EndReason</h2>
<p>EndReason プロパティは、以下の文字列のいずれかを返します：</p>
<table class="info">
  <tr>
    <th>String</th>
    <th abbr="説明">説明</th>
  </tr>
  <tr>
    <td>Stopped</td>
    <td>Stopメソッドが呼び出されたか、Startがまだ呼び出されていない状態で、初めて呼び出されます。</td>
  </tr>
  <tr>
    <td>Max</td>
    <td>Inputが最大許容長に達し、<em>MatchList</em>の、どの項目とも一致しない。</td>
  </tr>
  <tr>
    <td>タイムアウト</td>
    <td>入力のタイムアウト</td>
  </tr>
  <tr>
    <td>Match</td>
    <td>Inputが<em>MatchList</em>の項目の1つに一致します。<a href="#Match">Match</a>プロパティには、一致した項目が含まれます。</td>
  </tr>
  <tr>
    <td>EndKey</td>
    <td>
      <p><em>EndKey</em>のいずれかが押され、入力が終了<a href="#EndKey">EndKey</a>プロパティには、中括弧のない終端キー名または文字が格納されます。</p>
    </td>
  </tr>
  <tr>
    <td></td>
    <td>入力中の場合、EndReason は空白となります。</td>
  </tr>
</table>

<h2 id="Remarks">備考</h2>
<p><a href="#Start">Start</a>メソッドは、入力が収集される前に呼び出される必要があります。</p>
<p>InputHookは、スクリプトの異なる部分が最小限の競合で入力を監視できるように設計されています。<a href="#ExSac">任意の単語</a>や、その他のパターンを監視するなど、連続的に動作させることも可能です。また、ホットキーに干渉することなく、ユーザー入力の収集や特定（または<a href="#ExKeyWaitAny">非特定</a>）キーの一時的な上書きなど、一時的に動作させることも可能です。</p>
<p><a href="../Hotkeys.htm">キーボードホットキー</a>は、入力中も有効ですが、必要な修飾キーが抑制されている場合、またはホットキーが<em>reg</em>メソッドを使用し、そのサフィックスキーが抑制されている場合は、有効にすることができません。例えば、ホットキー<code>^+a::</code>はInputHookによって上書きされる<em>かも</em>しれませんが、InputHookが<kbd>Ctrl</kbd>または<kbd>Shift</kbd>を抑制しない限り、ホットキー<code>$^+a::</code>は優先されます。</p>
<p>キーは、以下の要素（順番）により、抑制（ブロック）されるか、されないかが決まります：</p>
<ul>
  <li>このVKまたはSCに対して<a href="#KeyOpt-v">Vオプション</a>が有効な場合、抑制されません。</li>
  <li>このVKまたはSCに対して<a href="#KeyOpt-s">Sオプション</a>が有効である場合は、抑制されます。</li>
  <li>If the key is a <a href="../KeyList.htm#modifier">standard modifier key</a> or <kbd>CapsLock</kbd>, <kbd>NumLock</kbd> or <kbd>ScrollLock</kbd>, it is not suppressed.</li>
  <li>キーがテキストを生成するかどうかに応じて、<a href="#VisibleText">VisibleText</a>または<a href="#VisibleNonText">VisibleNonText</a>が参照されます。プロパティが false の場合、キーは抑制されます。どのキーがテキストを生成するものとしてカウントされるかの詳細については、<a href="#VisibleText">VisibleText</a>を参照してください。</li>
</ul>
<p><a href="InstallKeybdHook.htm">キーボードフック</a>は、入力中は必要ですが、入力終了時に不要になれば自動的にアンインストールされます。</p>
<p>このスクリプトは、入力が進行している間は<a href="../Scripts.htm#persistent">自動的に永続化</a>されるため、実行中の<a href="../misc/Threads.htm">スレッド</a>がない場合でも入力の監視を継続します。入力が終了すると、スクリプトは自動的に終了することがあります（実行中のスレッドがなく、他の理由でスクリプトが永続的でない場合）。</p>
<p>AutoHotkeyは、Input Method Editors（IME）をサポートしていません。キーボードフックは、キーボードイベントを受信し、<a href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-tounicodeex">ToUnicodeEx</a>またはToAsciiExを使用してテキストに変換します（1文字をカプセル化する<a href="https://learn.microsoft.com/windows/win32/inputdev/virtual-key-codes#vk_packet">VK_PACKET</a>イベントの場合を除きます）。</p>
<p>If you use multiple languages or keyboard layouts, InputHook uses the keyboard layout of the active window rather than the script's (regardless of whether the Input is <a href="#vis">visible</a>).</p>
<p>柔軟性には欠けるが、一般的に<a href="../Hotstrings.htm">ホットストリング</a>は使いやすいです。</p>

<h2 id="comparison">InputHookとInputの比較(v1)</h2>
<p>AutoHotkey v1.1では、InputHookがInputコマンドの代わりとなり、より柔軟な操作性を提供します。Inputコマンドはv2.0で削除されましたが、以下のコードはほぼ同等です：</p>
<pre>
<em>; Input OutputVar, % Options, % EndKeys, % MatchList  ; v1</em>
ih := InputHook(Options, EndKeys, MatchList)
ih.Start()
ErrorLevel := ih.Wait()
if (ErrorLevel = "EndKey")
    ErrorLevel .= ":" ih.EndKey
OutputVar := ih.Input
</pre>
<p>Inputコマンドは、開始した前のInputを終了させますが、InputHookは、一度に<a href="#stack">複数のInput</a>を行うことができます。</p>
<p><em>Options</em>の解釈は同じですが、初期設定が異なります：</p>
<ul>
  <li>Inputコマンドは入力の長さを16383に制限し、InputHookは1023に制限しています。これは<a href="#option-l">Lオプション</a>で上書きすることができ、絶対的な最大値は存在しません。</li>
  <li>Inputコマンドは、デフォルトでテキストと非テキストの両方のキーストロークをブロックし、<a href="#vis">Vオプション</a>が存在する場合はどちらもブロックしません。一方、InputHookはデフォルトでテキストキー入力のみをブロックするため（<a href="#VisibleNonText">VisibleNonText</a>のデフォルトはtrue）、入力中にほとんどのホットキーが使用可能です。</li>
</ul>
<p>Inputコマンドは進行中の<a href="../misc/Threads.htm">スレッド</a>をブロックするのに対し、InputHookはスレッドを継続、あるいは終了（中断したスレッドを再開させる）させることができます。スクリプトは待つ代わりに、Inputが終了したときに呼び出される<a href="#OnEnd">OnEnd</a>関数を登録することができます。</p>
<p>InputコマンドはInputが終了した後にしかユーザーの入力を返さないが、InputHookの<a href="#Input">Input</a>プロパティはいつでも取得できます。スクリプトは、Inputプロパティを継続的にチェックする代わりに、文字が追加されるたびに呼び出される<a href="#OnChar">OnChar</a>関数を登録することができます。</p>
<p>InputHookでは、<a href="#KeyOpt">KeyOpt</a>メソッドにより、個々のキーに対してより多くの制御を行うことができます。これには、エンドキーの追加や削除、特定のキーの抑制や非抑制、特定のキーによって生成されるテキストの無視などが含まれます。</p>
<p>Inputコマンドとは異なり、InputHookはInputを終了させること<em>なく</em>、テキストを生成しないキーを検出するために使用することができます。<a href="#OnKeyDown">OnKeyDown</a>関数を登録し、<a href="#KeyOpt">KeyOpt</a>または<a href="#NotifyNonText">NotifyNonText</a>を使用して、どのキーが注目されるかを指定することで実現します。</p>
<p><em>MatchList</em>の項目が原因でInputが終了した場合、<a href="#Match">Match</a>プロパティを参照することで、正確にどのようなマッチがあったかを判断することができます（これは、<a href="#asterisk">* option</a>がある場合に便利です）。</p>
<p>Inputコマンドの終了後、スクリプトは<a href="GetKeyState.htm">GetKeyState</a>を参照することができますが、Inputの終了時にどのキーが押されたかが正確に反映されない場合があります。InputHookの<a href="#EndMods">EndMods</a>プロパティは、Inputが終了した時点の修飾キーの論理状態を反映しています。</p>
<p>後方互換性に関連するいくつかの相違点があります：</p>
<ul>
  <li>Inputコマンドは、キーボードレイアウトによっては他の文字が小文字であっても、エンドキー<kbd>A</kbd>-<kbd>Z</kbd>を大文字で保存します。<a href="Send.htm">Send</a>に値を渡すと、プレーンなキーストロークではなく、シフトしたキーストロークが生成されます。一方、InputHookの<a href="#EndKeys">EndKeys</a>プロパティは、常に正規化された名前を返します。つまり、<kbd>Shift</kbd>や他の修飾子を使わずにキーを押したときに生じるどの文字も、正規化された名前を返します。</li>
  <li><p><em>EndKeys</em>で使用されるキー名が、2つの物理キー（<kbd>NumpadUp</kbd>と <kbd>Up</kbd>など）で共有されるVKに対応する場合、Inputコマンドは主キーをVKで、副キーをSCで処理するが、InputHookは両方をSCで処理します。<code>VKによる</code>鍵の取り扱いに<code>{vkNN}</code>表記を用いることができます。</p>
  <p>終了キーがVKで処理される場合、両方の物理キーでInputを終了させることができます。例えば、<code>{NumpadUp}</code>の場合、Inputコマンドは<kbd>Up</kbd>を押すことで終了しますが、ErrorLevelはVKのみを考慮するため、<code>EndKey:NumpadUp</code>となります。</p>
  <p>エンドキーがSCで処理される場合、Inputコマンドは常に任意のVKの既知のセカンダリSCに対して名前を生成し、それ以外のキーに対しては常に<code>sc<i>NNN</i></code>を生成する（たとえ名前を持っていても）。これに対して、InputHookはキーに名前がある場合に名前を生成します。</p></li>
</ul>

<h2 id="Related">関連</h2>
<p><a href="KeyWait.htm">KeyWait</a>, <a href="../Hotstrings.htm">Hotstrings</a>, <a href="InputBox.htm">InputBox</a>, <a href="InstallKeybdHook.htm">InstallKeybdHook</a>, <a href="../misc/Threads.htm">Threads</a></p>

<h2 id="Examples">例</h2>
<div class="ex" id="ExKeyWaitAny">
<p><a class="ex_number" href="#ExKeyWaitAny"></a> ユーザーが任意の1つのキーを押すのを待ちます。</p>
<pre>
MsgBox KeyWaitAny()

<em>; また同じですが、キーをふさがないようにします。</em>
MsgBox KeyWaitAny("V")

KeyWaitAny(Options:="")
{
    ih := InputHook(Options)
    if !InStr(Options, "V")
        ih.VisibleNonText := false
    ih.KeyOpt("{All}", "E")  <em>; End</em>
    ih.Start()
    ih.Wait()
    return ih.EndKey  <em>; Return the key name</em>
}
</pre>
</div>
<div class="ex" id="ExKeyWaitCombo">
<p><a class="ex_number" href="#ExKeyWaitCombo"></a> Ctrl/Alt/Shift/Winと組み合わせた任意のキーで待機します。</p>
<pre>
MsgBox KeyWaitCombo()

KeyWaitCombo(Options:="")
{
    ih := InputHook(Options)
    if !InStr(Options, "V")
        ih.VisibleNonText := false
    ih.KeyOpt("{All}", "E")  <em>; End</em>
    <em>; Exclude the modifiers</em>
    ih.KeyOpt("{LCtrl}{RCtrl}{LAlt}{RAlt}{LShift}{RShift}{LWin}{RWin}", "-E")
    ih.Start()
    ih.Wait()
    return ih.EndMods . ih.EndKey  <em>; Return a string like &lt;^&lt;+Esc</em>
}
</pre>
</div>
<div class="ex" id="ExSac">
<p><a class="ex_number" href="#ExSac"></a> シンプルなオートコンプリート：曜日を問わず駄洒落はさておき、これはほぼ機能的な例です。スクリプトを実行し、今日の入力を開始し、<kbd>Tab</kbd>キーを押して完了するか、<kbd>Esc</kbd>キーを押して終了するだけでよいです。</p>
<pre>WordList := "Monday`nTuesday`nWednesday`nThursday`nFriday`nSaturday`nSunday"

Suffix := ""

SacHook := InputHook("V", "{Esc}")
SacHook.OnChar := SacChar
SacHook.OnKeyDown := SacKeyDown
SacHook.KeyOpt("{Backspace}", "N")
SacHook.Start()

SacChar(ih, char)  <em>; Called when a character is added to SacHook.Input.</em>
{
    global Suffix := ""
    if RegExMatch(ih.Input, "`nm)\w+$", &amp;prefix)
        &amp;&amp; RegExMatch(WordList, "`nmi)^" prefix[0] "\K.*", &amp;Suffix)
        Suffix := Suffix[0]
    
if CaretGetPos(&amp;cx, &amp;cy)
        ToolTip Suffix, cx + 15, cy
    else
        ToolTip Suffix

<em>; ツールチップを表示している間だけ、インターセプトタブを表示します。</em>
    ih.KeyOpt("{Tab}", Suffix = "" ? "-NS" : "+NS")
}

SacKeyDown(ih, vk, sc)
{
    if (vk = 8) <em>; Backspace</em>
        SacChar(ih, "")
    else if (vk = 9) <em>; Tab</em>
        Send "{Text}" Suffix
}
</pre>
</div>
<div class="ex" id="ExAnyKey">
<p><a class="ex_number" href="#ExAnyKey"></a> Waits for the user to press any key. Keys that produce no visible character -- such as the modifier keys, function keys, and arrow keys -- are listed as end keys so that they will be detected too.</p>
<pre>ih := InputHook("L1", "{LControl}{RControl}{LAlt}{RAlt}{LShift}{RShift}{LWin}{RWin}{AppsKey}{F1}{F2}{F3}{F4}{F5}{F6}{F7}{F8}{F9}{F10}{F11}{F12}{Left}{Right}{Up}{Down}{Home}{End}{PgUp}{PgDn}{Del}{Ins}{BS}{CapsLock}{NumLock}{PrintScreen}{Pause}")
ih.Start()
ih.Wait()</pre>
</div>
<div class="ex" id="ExHotkey">
<p><a class="ex_number" href="#ExHotkey"></a> This is a working hotkey example. Since the hotkey has the tilde (~) prefix, its own keystroke will pass through to the active window. Thus, if you type <code>[btw</code> (or one of the other match phrases) in any editor, the script will automatically perform an action of your choice (such as replacing the typed text). For an alternative version of this example, see <a href="Switch.htm#ExInput">Switch</a>.</p>
<pre>~[::
{
    msg := ""
    ih := InputHook("V T5 L4 C", "{enter}.{esc}{tab}", "btw,otoh,fl,ahk,ca")
    ih.Start()
    ih.Wait()
    if (ih.EndReason = "Max")
        msg := 'You entered "{1}", which is the maximum length of text.'
    else if (ih.EndReason = "Timeout")
        msg := 'You entered "{1}" at which time the input timed out.'
    else if (ih.EndReason = "EndKey")
        msg := 'You entered "{1}" and terminated the input with {2}.'

if msg  <em>; If an EndReason was found, skip the rest below.</em>
    {
        MsgBox Format(msg, ih.Input, ih.EndKey)
        return
    }

<em>; Otherwise, a match was found.</em>
    if (ih.Input = "btw")
        Send("{backspace 4}by the way")
    else if (ih.Input = "otoh")
        Send("{backspace 5}on the other hand")
    else if (ih.Input = "fl")
        Send("{backspace 3}Florida")
    else if (ih.Input = "ca")
        Send("{backspace 3}California")
    else if (ih.Input = "ahk")
        Run("https://www.autohotkey.com")
}</pre>
</div>

</body>
</html>
