<!DOCTYPE HTML>
<html lang="ja">
<head>
<title>OnError - 構文と使用法｜AutoHotkey v2</title>
<meta name="description" content="OnError 関数は、処理されないエラーが発生したときに、指定された関数が自動的に呼び出されるようにする。" />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>OnError</h1>
<p>未処理のエラーが発生した場合に、指定された関数が自動的に呼び出されるようにします。</p>

<pre class="Syntax"><span class="func">OnError</span> Function <span class="optional">, AddRemove</span></pre>

<h2 id="Parameters">パラメータ</h2>
<dl>

  <dt>機能</dt>
  <dd>
    <p>型：<a href="../misc/Functor.htm">機能オブジェクト</a></p>
    <p>処理されないエラーが発生したときに呼び出す関数オブジェクトです。この関数のパラメータと戻り値について、<a href="#Function">以下</a>に説明します。</p>
  </dd>
  
  <dt>AddRemove</dt>
  <dd>
    <p>型：<a href="../Concepts.htm#numbers">整数</a></p>
    <p>省略した場合、デフォルトは1（以前に登録された関数の後に呼び出す）です。それ以外の場合は、次のいずれかの番号を指定してください：</p>
    <ul>
      <li>1 = 以前に登録した機能の後に機能を呼び出します。</li>
      <li>-1 = 過去に登録された機能よりも先に機能を呼び出します。</li>
      <li>0 = 関数を呼び出しません。</li>
    </ul>
  </dd>

</dl>

<h2 id="Function">機能</h2>
<p>この関数は2つのパラメータを受け取る必要があります：</p>
<pre class="Syntax"><i>FunctionName</i>(Thrown, Mode)</pre>
<dl>
  <dt>Thrown</dt>
  <dd>
    <p>型：<a href="Any.htm">任意</a></p>
    <p>投げられた値（通常は<a href="Error.htm">Errorオブジェクト</a>）。</p>
  </dd>
  <dt>Mode</dt>
  <dd>
    <p>型：<a href="../Concepts.htm#strings">文字列</a></p>
    <p>以下の文字列のいずれか1つ：</p>
    <ul>
      <li><code>"Return"</code>:<em>Thrown</em>は継続可能なランタイムエラーです。コールバックが-1を返した場合はスレッドを継続し、それ以外の場合はスレッドを終了します。</li>
      <li><code>"Exit"</code>:<em>Thrown</em>は、継続不可能なランタイムエラーまたはスクリプトによって<a href="Throw.htm">スロー</a>される値です。スレッドが終了します。</li>
      <li><code>"ExitApp"</code>:DllCallで検出された破損などの重大なランタイムエラーが発生した場合、<em>スロー</em>されます。プログラムが終了します。</li>
    </ul>
  </dd>
</dl>

<h3 id="Return_Value">戻り値</h3>
<p>コールバック関数は、以下のいずれかの値を返すことができます（その他の値は将来の使用のために予約されており、避ける必要があります）：</p>
<ul>
  <li><code>0</code>, <code>""</code> or no <code>return</code>:エラー処理を通常通り行うことができるようにします。</li>
  <li><code>1</code>:デフォルトのエラーダイアログと残りのエラーコールバックを抑制します。</li>
  <li><code>-1</code>:上記と同様ですが、<em>Mode</em>が <code>"Return"</code>の場合、現在のスレッドの実行を継続することが許可されます。</li>
</ul>

<h2 id="Remarks">備考</h2>
<p>通常であればエラーメッセージが表示されるようなエラーや例外が発生した場合にのみ、<em>関数</em>が呼び出されます。OnErrorはスクリプトがロードされた後でないと呼び出せないため、ロードタイムエラーでは呼び出せません。</p>
<p><em>関数</em>は、現在の<a href="../misc/Threads.htm">スレッド</a>が終了する前に（つまり、コールスタックが巻き戻される前に）、呼び出されます。</p>

<h2 id="Related">関連</h2>
<p><a href="Try.htm">Try</a>, <a href="Catch.htm">Catch</a>, <a href="Throw.htm">Throw</a>, <a href="OnExit.htm">OnExit</a></p>

<h2 id="Examples">例</h2>
<div class="ex" id="ExBasic">
<p><a class="ex_number" href="#ExBasic"></a> スクリプトによって発生したエラーをユーザーに表示するのではなく、テキストファイルにログを記録します。</p>
<pre>
OnError LogError
i := Integer("cause_error")

LogError(exception, mode) {
    FileAppend "Error on line " exception.Line ":" exception.Message "`n"
        , "errorlog.txt"
    return true
}
</pre>
</div>

<div class="ex" id="ExAccumulator">
<p><a class="ex_number" href="#ExAccumulator"></a> OnErrorを使用して、代替のエラー処理方法を実装します。Caveat:<a href="Try.htm">Try</a>が有効な間はOnErrorは無効です。</p>
<pre>
AccumulateErrors()
{
    local ea := ErrorAccumulator()
    ea.Start()
    return ea
}

class ErrorAccumulator
{
    Errors := []                        <em>; Array for accumulated errors.</em>
    _cb := AccumulateError.Bind(this.Errors)
    Start() =&gt; OnError(this._cb, -1)    <em>; Register our cb before others.</em>
    Stop() =&gt; OnError(this._cb, 0)      <em>; Unregister our cb.</em>
    Last =&gt; this.Errors[-1]             <em>; Most recent error.</em>
    Count =&gt; this.Errors.Length         <em>; Number of accumulated errors.</em>
    __item[i] =&gt; this.Errors[i]         <em>; Shortcut for indexing.</em>
    __delete() =&gt; this.Stop()           <em>; For tying to function scope.</em>
}

<em>; これはOnErrorコールバック関数である。'errors' には Bind() で値を与えます。</em>
AccumulateError(errors, e, mode)
{
    if mode != "Return" <em>; Not continuable.</em>
        return
    if e.What = "" <em>; Expression defect or similar, not a built-in function.</em>
        return
    try {
        <em>; Try to print the error to stdout.</em>
        FileAppend Format("{1} ({2}) : ({3}) {4}`n", e.File, e.Line, e.What, e.Message), "*"
        if HasProp(e, "extra")
            FileAppend "     Specifically:" e.Extra "`n", "*"
    }
    errors.Push(e)
    return -1 <em>; Continue.</em>
}

RearrangeWindows()
{
    <em>; Start accumulating errors in 'err'.</em>
    local err := AccumulateErrors()

<em>; Do some things that might fail...</em>
    MonitorGetWorkArea , &amp;left, &amp;top, &amp;right, &amp;bottom
    width := (right-left)//2, height := bottom-top
    WinMove left, top, width, height, A_ScriptFullPath
    WinMove left+width, top, width, height, "AutoHotkey v2 Help"

<em>; Check if any errors occurred.</em>
    if err.Count
        MsgBox err.Count " error(s); last error at line #" err.Last.Line
    else
        MsgBox "No errors"

<em>; Stop is called automatically when the variable goes out of scope,
    ; since only we have a reference to the object.  This causes OnError
    ; to be called to unregister the callback.
;err.Stop()</em>
}

<em>; Call the test function which suppresses and accumulates errors.</em>
RearrangeWindows()
<em>; Call another function to show normal error behaviour is restored.</em>
WinMove 0, 0, 0, 0, "non-existent window"
</pre>
</div>

</body>
</html>
