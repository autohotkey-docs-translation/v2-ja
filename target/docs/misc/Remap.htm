<!DOCTYPE HTML>
<html lang="ja">
<head>
<title>リマッピングキー（キーボード、マウス、コントローラ）｜AutoHotkey v2</title>
<meta name="description" content="マウスやコントローラーのボタンもリマップできる無料のキーボードリマッパー。また、キー操作やマウスクリックを送信することで、繰り返し作業を自動化することもできる。">
<meta name="keywords" content="keyboard,remapper,remap,remapping,keys,key,keystrokes,clicks,mouse,buttons,button,controller,gamepad,joystick,hotkeys,hotkey">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>キーのリマッピング<span class="headnote">（キーボード、マウス、コントローラー）</span></h1>

<h2 id="toc">目次</h2>
<ul>
  <li><a href="#intro">はじめに</a></li>
  <li><a href="#Remap">キーボードとマウスのリマッピング</a></li>
  <li><a href="#remarks">備考</a></li>
  <li><a href="#moving-the-mouse-cursor">キーボードによるマウスカーソルの移動</a></li>
  <li><a href="#registry">レジストリの "スキャンコードマップ"によるリマッピング</a></li>
  <li><a href="#related">関連する話題</a></li>
</ul>

<h2 id="intro">はじめに</h2>
<p><strong>制限</strong>以下に説明するAutoHotkeyのリマッピング機能は、一般的にWindowsレジストリ経由で直接リマッピングするほど純粋で効果的ではありません。各アプローチの利点と欠点については、<a href="#registry">レジストリの再マッピング</a>を参照のこと。</p>
<h2 id="Remap">キーボードとマウスのリマッピング</h2>
<p>組み込みの再マッピング機能の構文は<code>OriginKey::DestinationKey</code>です。例えば、以下の行だけで構成される<a href="../Scripts.htm">スクリプト</a>は、<kbd>A</kbd>を <kbd>B</kbd>のように動作させる：</p>
<pre>a::b</pre>
<p>上記の例では、<kbd>B</kbd>自体は変更されていない。<kbd>B</kbd>は、次の例のように他のキーにリマップしない限り、"b"キーストロークを送信し続ける：</p>
<pre>a::b
b::a</pre>
<p>上記の例では小文字を使用しているが、これは対応する大文字もリマップするため、ほとんどの目的には小文字が推奨される（つまり、<kbd>CapsLockが</kbd>「オン」または<kbd>Shift</kbd>が押されたままだと大文字が送信される）。対照的に、右側に大文字を指定すると、強制的に大文字になる。例えば、次の行では、"a"または "A"を入力すると、大文字の "B"が表示される（<kbd>CapsLock</kbd>がオフの場合）：</p>
<pre>a::B</pre>
<p>逆に、左サイドに含まれていて右サイドに含まれていないモディファイアは、キーが送信されると自動的に解除される。例えば、次の2行は、Shift+AまたはCtrl+Aを押すと小文字の "b"が表示される：</p>
<pre>A::b
^a::b</pre>

<h3 id="RemapMouse">マウスリマッピング</h3>
<p>キーボードの代わりにマウスをリマップするには、同じ方法を使います。事例：</p>
<table class="info">
  <tr>
    <th style="min-width: 11em;">Example</th>
    <th abbr="説明">説明</th>
  </tr>
  <tr>
    <td><code>MButton::Shift</code></td>
    <td>真ん中のボタンを<kbd>Shift</kbd>のように動作させる。</td>
  </tr>
  <tr>
    <td><code>XButton1::LButton</code></td>
    <td>マウスの第4ボタンをマウスの左ボタンのように動作させる。</td>
  </tr>
  <tr>
    <td><code>RAlt::RButton</code></td>
    <td>右<kbd>Alt</kbd>をマウスの右ボタンのように動作させる。</td>
  </tr>
</table>

<h3 id="other-useful-remappings">その他の便利なリマッピング</h3>
<table class="info">
  <tr>
    <th style="min-width: 11em;">Example</th>
    <th abbr="説明">説明</th>
  </tr>
  <tr>
    <td><code>CapsLock::Ctrl</code></td>
    <td><kbd>CapsLock</kbd>を <kbd>Ctrlに</kbd>する。<kbd>CapsLock</kbd>のオン/オフ機能を保持するには、まずリマッピング<code>+CapsLock::CapsLock</code>を追加する。<kbd>Shift</kbd>を押しながら<kbd>CapsLock</kbd>を押すと、<kbd>CapsLock</kbd>のオン/オフが切り替わります。どちらのリマッピングも修飾キーを押したままにできるため、より特殊な<code>+CapsLock::CapsLock</code>リマッピングを最初に配置しなければ動作しない。</td>
  </tr>
  <tr>
    <td><code>XButton2::^LButton</code></td>
    <td>マウスの第5ボタン(XButton2)をコントロールクリックする。</td>
  </tr>
  <tr>
    <td><code>RAlt::AppsKey</code></td>
    <td>右の<kbd>Alt</kbd>を <kbd>Menu</kbd>（コンテキストメニューを開くキー）にする。</td>
  </tr>
  <tr>
    <td><code>RCtrl::RWin</code></td>
    <td>正しい<kbd>Ctrl</kbd>が正しい<kbd>Win</kbd>になる。</td>
  </tr>
  <tr>
    <td><code>Ctrl::Alt</code></td>
    <td><kbd>Ctrl</kbd>を <kbd>Alt</kbd>のように動作させる。ただし、<a href="#AltTab">alt-tabの問題</a>を参照。</td>
  </tr>
  <tr>
    <td><code>^x::^c</code></td>
    <td><kbd>Ctrl</kbd>+<kbd>X</kbd>が <kbd>Ctrl</kbd>+<kbd>C</kbd>になる。また、<kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>X</kbd>が<kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>C</kbd>などを生成する。</td>
  </tr>
  <tr>
    <td><code>RWin::Return</code></td>
    <td>右<kbd>Win</kbd>は単に<a href="../lib/Return.htm">リターン</a>させることで無効にする。</td>
  </tr>
</table>
<p>これらの例を "Remap.ahk"のような新しいテキストファイルにコピーし、ファイルを起動することで試すことができる。</p>
<p>キーとマウスボタンの名前の完全なリストは、<a href="../KeyList.htm">キーリスト</a>を参照してください。</p>
<h2 id="remarks">備考</h2>
<p><a href="../lib/_HotIf.htm">#HotIf</a>ディレクティブは、選択したリマッピングを指定したウィンドウでのみ（または指定した条件が満たされている間）有効にするために使用できます。事例：</p>
<pre>#HotIf WinActive("ahk_class Notepad")
a::b  <em>; Makes the 'a' key send a 'b' key, but only in Notepad.</em>
#HotIf  <em>; This puts subsequent remappings and hotkeys in effect for all windows.</em></pre>
<p>キーやボタンのリマッピングは、以下の点で「完了」となります：</p>
<ul>
  <li><kbd>Ctrl</kbd>や<kbd>Shift</kbd>などの修飾子を押しながら原点キーを入力すると、その修飾子が移動先のキーに有効になります。例えば、<code>b::aは</code>、<kbd>Ctrl+</kbd><kbd>B</kbd>を押すと<kbd>Ctrl</kbd>+<kbd>A</kbd>になる。</li>
  <li><kbd>CapsLockは</kbd>通常、通常のキーと同じようにリマップキーに影響します。</li>
  <li>デスティネーションキーまたはボタンは、オリジンキーを押し続けている間、押し続けられる。ただし、リマッピングに対応していないゲームもあります。その場合、キーボードとマウスはリマッピングされていないものとして動作します。</li>
  <li>リマップされたキーは、押したまま自動リピートされます（マウスボタンにリマップされたキーを除く）。</li>
</ul>
<p id="HookHotkeys">リマップキーは通常のホットキーをトリガーできますが、デフォルトではマウスホットキーや<a href="../lib/_UseHook.htm">フックホットキー</a>をトリガーすることはできません（どのホットキーが "フック "なのかは<a href="../lib/ListHotkeys.htm">ListHotkeys</a>を使って調べてください）。例えば、<code>a::b</code>のリマッピングが有効な場合、<kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>A</kbd>を押すと、<code>^!b</code>ホットキーがトリガーされます。<code>^!b</code>がフックホットキーである場合、<kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>A</kbd>で<kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>B</kbd>と同じ動作をさせたい場合は、<code>^!a</code>をホットキーとして定義できます。事例：</p>
<pre>a::b
^!a::
^!b::ToolTip "You pressed " ThisHotkey
</pre>
<p>Alternatively, <a href="../lib/_InputLevel.htm">#InputLevel</a> can be used to override the default behaviour. 事例：</p>
<pre>#InputLevel 1
a::b

#InputLevel 0
^!b::ToolTip "You pressed " ThisHotkey
</pre>
<p id="SendPlay"><a href="../Scripts.htm#auto">スクリプト起動</a>時に<a href="../lib/SendMode.htm">SendMode</a>が使用されると、すべてのリマッピングに影響する。しかし、リマッピングは<a href="../lib/Send.htm#blind">Send "{Blind}"</a>を使用し、<a href="../lib/SendMode.htm">SendPlayモードは</a>{Blind}を完全にはサポートしていないため、一部のリマッピングはSendPlayモードでは正しく機能しない可能性があります（特に<kbd>Ctrl</kbd>、<kbd>Shift</kbd>、<kbd>Alt</kbd>、<kbd>Win</kbd>）。これを回避するには、リマッピングがある場合は、<a href="../Scripts.htm#auto">スクリプトの起動</a>時に<a href="../lib/Send.htm#SendPlay">SendMode</a> <code>"Play"</code>を使用しないようにします。あるいは、リマッピングをホットキーに変換し（後述）、SendEvent対Sendを明示的に呼び出すこともできる。</p>
<p id="EscapeBrace"><em>DestinationKey</em>が <code>{</code>の場合は、<code>x::`{</code>のように<a href="EscapeChar.htm">エスケープ</a>しなければならない。そうでない場合は、<a href="../Hotkeys.htm">ホットキー</a>の機能の開始ブレースとして解釈される。</p>
<p id="actually">スクリプトが起動すると、各リマッピングは<a href="../Hotkeys.htm">ホットキー</a>のペアに変換されます。例えば、<code>a::b</code>を含むスクリプトは、実際には代わりに以下の2つのホットキーを含む：</p>
<pre>*<strong>a</strong>::
{
    SetKeyDelay -1   <em>; If the destination key is a mouse button, SetMouseDelay is used instead.</em>
    Send "<a href="../lib/Send.htm#blind">{Blind}</a>{<strong>b</strong> DownR}"  <em>; <a href="../lib/Send.htm#DownR">DownR</a> is like Down except that other Send functions in the script won't assume "b" should stay down during their Send.</em>
}

*<strong>a up</strong>::
{
    SetKeyDelay -1  <em>; See note below for why press-duration is not specified with either of these SetKeyDelays.</em>
    Send "{Blind}{<strong>b</strong> Up}"
}</pre>
<p>ただし、上記のホットキーは以下の状況で変化する：</p>
<ol>
  <li>送信元キーが左<kbd>Ctrl</kbd>、送信先キーが<kbd>Alt</kbd>の場合、<code>Send "{Blind}{LAlt DownR}"</code>という行は、<code>Send "{Blind}<strong>{LCtrl up}</strong>{LAlt DownR}"</code>に置き換えられる。ソースが右<kbd>Ctrl</kbd>の場合も、<code>{RCtrl up}</code>が使われる以外は同じである。</li>
  <li>キーボードのキーがマウスボタンにリマップされる場合（例：<code>RCtrl::RButton</code>）、上記のホットキーはSetKeyDelayの代わりにSetMouseDelayを使用します。さらに、上記の最初のホットキーは以下のように置き換えられ、キーボードのオートリピート機能によるマウスクリックの繰り返しを防ぎます：
    <pre>*RCtrl::
{
    SetMouseDelay -1
    if not GetKeyState("RButton")  <em>; i.e. the right mouse button isn't down yet.</em>
        Send "{Blind}{RButton DownR}"
}</pre>
  </li>
  <li>ソースが<a href="../Hotkeys.htm#combo">カスタムの組み合わせ</a>である場合、ワイルドカード修飾子（*）はホットキーが機能するように省略されます。</li>
</ol>
<p>Note that SetKeyDelay's second parameter (<a href="../lib/SetKeyDelay.htm#dur">press duration</a>) is omitted in the hotkeys above. This is because press-duration does not apply to down-only or up-only events such as <code>{b down}</code> and <code>{b up}</code>. However, it does apply to changes in the state of the modifier keys (Shift, Ctrl, Alt, and Win), which affects remappings such as <code>a::B</code> or <code>a::^b</code>. Consequently, any press-duration a script puts into effect during <a href="../Scripts.htm#auto">script startup</a> will apply to all such remappings.</p>
<p>Since remappings are translated into hotkeys as described above, the <a href="../lib/Suspend.htm">Suspend</a> function affects them. Similarly, the <a href="../lib/Hotkey.htm">Hotkey</a> function can disable or modify a remapping. For example, the following two functions would disable the remapping <code>a::b</code>.</p>
<pre>Hotkey "*a", "Off"
Hotkey "*a up", "Off"</pre>
<p id="AltTab">Alt-tab issues: If you remap a key or mouse button to become <kbd>Alt</kbd>, that key will probably not be able to alt-tab properly. A possible work-around is to add the hotkey <code>*Tab::Send "{Blind}{Tab}"</code> -- but be aware that it will likely interfere with using the real <kbd>Alt</kbd> to alt-tab. Therefore, it should be used only when you alt-tab solely by means of remapped keys and/or <a href="../Hotkeys.htm#alttab">alt-tab hotkeys</a>.</p>
<p>In addition to the keys and mouse buttons on the <a href="../KeyList.htm">Key List</a> page, the source key may also be a virtual key (VKnn) or scan code (SCnnn) as described on the <a href="../KeyList.htm#SpecialKeys">special keys</a> page. The same is true for the destination key except that it may optionally specify a scan code after the virtual key. For example, <code>sc01e::vk42sc030</code> is equivalent to <code>a::b</code> on most keyboard layouts.</p>
<p>To disable a key rather than remapping it, make it a hotkey that simply <a href="../lib/Return.htm">returns</a>. For example, <code>F1::return</code> would disable <kbd>F1</kbd>.</p>
<p>The following keys are not supported by the built-in remapping method:</p>
<ul>
  <li>The mouse wheel (WheelUp/Down/Left/Right).</li>
  <li>"Pause" as a destination key name (since it matches the name of a built-in function). Instead use <code>vk13</code> or the corresponding scan code.</li>
  <li>Curly braces {} as destination keys. Instead use the <a href="../lib/Send.htm#vk">VK/SC method</a>; e.g. <code>x::+sc01A</code> and <code>y::+sc01B</code>.</li>
</ul>
<h2 id="moving-the-mouse-cursor">キーボードによるマウスカーソルの移動</h2>
<p>The keyboard can be used to move the mouse cursor as demonstrated by the fully-featured <a href="../scripts/index.htm#NumpadMouse">Keyboard-To-Mouse script</a>. Since that script offers smooth cursor movement, acceleration, and other features, it is the recommended approach if you plan to do a lot of mousing with the keyboard. By contrast, the following example is a simpler demonstration:</p>
<pre>*#up::MouseMove 0, -10, 0, "R"  <em>; Win+UpArrow hotkey =&gt; Move cursor upward</em>
*#Down::MouseMove 0, 10, 0, "R"  <em>; Win+DownArrow =&gt; Move cursor downward</em>
*#Left::MouseMove -10, 0, 0, "R"  <em>; Win+LeftArrow =&gt; Move cursor to the left</em>
*#Right::MouseMove 10, 0, 0, "R"  <em>; Win+RightArrow =&gt; Move cursor to the right</em>

*&lt;#RCtrl::  <em>; LeftWin + RightControl =&gt; Left-click (hold down Control/Shift to Control-Click or Shift-Click).</em>
{
    SendEvent "{Blind}{LButton down}"
    KeyWait "RCtrl"  <em>; Prevents keyboard auto-repeat from repeating the mouse click.</em>
    SendEvent "{Blind}{LButton up}"
}

*&lt;#AppsKey::  <em>; LeftWin + AppsKey =&gt; Right-click</em>
{
    SendEvent "{Blind}{RButton down}"
    KeyWait "AppsKey"  <em>; Prevents keyboard auto-repeat from repeating the mouse click.</em>
    SendEvent "{Blind}{RButton up}"
}</pre>
<h2 id="registry">レジストリの "スキャンコードマップ"によるリマッピング</h2>
<p><strong>Advantages:</strong></p>
<ul>
  <li>Registry remapping is generally more pure and effective than <a href="#Remap">AutoHotkey's remapping</a>. For example, it works in a broader variety of games, it has no known <a href="#AltTab">alt-tab issues</a>, and it is capable of firing AutoHotkey's hook hotkeys  (whereas AutoHotkey's remapping requires a <a href="#HookHotkeys">workaround</a>).</li>
  <li>If you choose to make the registry entries manually (explained below), absolutely no external software is needed to remap your keyboard. Even if you use <a href="https://www.bleepingcomputer.com/download/keytweak/">KeyTweak</a> to make the registry entries for you, KeyTweak does not need to stay running all the time (unlike AutoHotkey).</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
  <li>Registry remapping is relatively permanent: a reboot is required to undo the changes or put new ones into effect.</li>
  <li>Its effect is global: it cannot create remappings specific to a particular user, application, or locale.</li>
  <li>It cannot send keystrokes that are modified by <kbd>Shift</kbd>, <kbd>Ctrl</kbd>, <kbd>Alt</kbd>, or <kbd>AltGr</kbd>. For example, it cannot remap a lowercase character to an uppercase one.</li>
  <li>It supports only the keyboard (AutoHotkey has <a href="#RemapMouse">mouse remapping</a> and some <a href="RemapController.htm">limited controller remapping</a>).</li>
</ul>
<p><strong>How to Apply Changes to the Registry:</strong> There are at least two methods to remap keys via the registry:</p>
<ol>
  <li>Use a program like <a href="https://www.bleepingcomputer.com/download/keytweak/">KeyTweak</a> (freeware) to visually remap your keys. It will change the registry for you.</li>
  <li>Remap keys manually by creating a .reg file (plain text) and loading it into the registry. This is demonstrated in the <a href="https://www.autohotkey.com/board/index.php?showtopic=8359#entry52760">archived forums</a>.</li>
</ol>
<h2 id="related">関連する話題</h2>
<ul>
  <li><a href="../KeyList.htm">List of keys, mouse buttons and controller controls</a></li>
  <li><a href="../lib/GetKeyState.htm">GetKeyState</a></li>
  <li><a href="RemapController.htm">Remapping a controller</a></li>
</ul>
</body>
</html>
